
<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1">

    <title>Bayesian Statistics</title>

    <link rel="stylesheet" type="text/css" href="../style.css">
    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/color-brewer.min.css">
    <link rel="stylesheet" href="http://ai-code.tech/ai_notes_html/css/custom.css">
</head>

<body>

    <p><mathjax>$$
\DeclareMathOperator{\Exp}{Exp}
\DeclareMathOperator{\Gam}{Gam}
\DeclareMathOperator{\Bin}{Bin}
\DeclareMathOperator{\Bet}{Beta}
\DeclareMathOperator{\Uni}{Uniform}
\def\argmax{\operatorname*{argmax}}
\def\argmin{\operatorname*{argmin}}
$$</mathjax></p>
<h1>贝叶斯统计</h1>
<h1>Bayesian Statistics</h1>
<p><strong>Bayesian statistics</strong> is an approach to statistics contrasted with frequentist approaches.</p>
<p>As is with frequentist statistical inference, Bayesian inference is concerned with estimating parameters from some observed data. However, whereas frequentist inference returns point estimates - that is, single values - for these parameters, Bayesian inference instead expresses these parameters themselves as probability distributions. This is intuitively appealing as we are <em>uncertain</em> about the parameters we've inferred; with Bayesian inference we can represent this uncertainty.</p>
<p>This is to say that in Bayesian inference, we don't assign an explicit value to an unknown parameter. Rather, we define it over a probability distribution as well: what values is the parameter <em>likely</em> to take on? That is, we treat the parameter itself as a random variable.</p>
<p>We may say for instance that an unknown parameter <mathjax>$\theta$</mathjax> is drawn from an exponential distribution:</p>
<p><mathjax>$$
\theta \sim \Exp(\alpha)
$$</mathjax></p>
<p>Here <mathjax>$\alpha$</mathjax> is a <strong>hyperparameter</strong>, that is, it is a parameter for our parameter <mathjax>$\theta$</mathjax>.</p>
<p>Fundamentally, this is Bayesian inference:</p>
<p><mathjax>$$
P(\theta|X)
$$</mathjax></p>
<p>Where the parameters <mathjax>$\theta$</mathjax> are the unknown, so we express them as a probability distribution, given the observations <mathjax>$X$</mathjax>. This probability distribution is the <strong>posterior distribution</strong>.</p>
<p>So we must decide (specify) probability distributions for both the data sample and for the unknown parameters. These decisions involve making a lot of assumptions. Then you must compute a posterior distribution, which often cannot be calculated analytically - so other methods are used (such as simulations, described later).</p>
<p>From the posterior distribution, you can calculate point estimates, credible intervals, quantiles, and make predictions.</p>
<p>Finally, because of the assumptions which go into specifying the initial distributions, you must test your model and see if it fits the data and seems reasonable.</p>
<p>Thus Bayesian inference amounts to:</p>
<ol>
<li>Specifying a sampling model for the observed data <mathjax>$X$</mathjax>, conditioned on the unknown parameter <mathjax>$\theta$</mathjax> (which we treat as a random variable), such that <mathjax>$X \sim f(X|\theta)$</mathjax>, where <mathjax>$f(X|\theta)$</mathjax> is either the PDF or the PMF (as appropriate).</li>
<li>Specifying a marginal or distribution <mathjax>$\pi(\theta)$</mathjax> for <mathjax>$\theta$</mathjax>, which is the prior distribution ("prior" for short): <mathjax>$\theta \sim \pi(\theta)$</mathjax></li>
<li>From this we wish to compute the posterior, that is, uncover the distribution for <mathjax>$\theta$</mathjax> given the observed data <mathjax>$X$</mathjax>, like so: <mathjax>$\pi(\theta|X) = \frac{\pi(\theta)L(\theta|X)}{\int \pi(\theta) L(\theta|X) d\theta}$</mathjax>, where <mathjax>$L(\theta|X) \propto f(\theta|X)$</mathjax> in <mathjax>$\theta$</mathjax>, called the likelihood of <mathjax>$\theta$</mathjax> given <mathjax>$X$</mathjax>. More often than not, the posterior must be approximated through Markov Chain Monte Carlo (detailed later).</li>
</ol>
<h3>Frequentist vs Bayesian approaches</h3>
<p>For frequentists, probability is thought of in terms of frequencies, i.e. the probability of the event is the amount of times it happened over the total amount of times it could have happened.</p>
<p>In frequentist statistics, the observed data is considered random; if you gathered more observations they would be different according to the underlying distribution. The parameters of the model, however, are considered fixed.</p>
<p>For Bayesians, probability is belief or certainty about an event. Observed data is considered fixed, but the model parameters are random (uncertain) instead and considered to be drawn from some probability distribution.</p>
<p>Another way of phrasing this is that frequentists are concerned with uncertainty in the data, whereas Bayesians are concerned with uncertainty in the parameters.</p>
<h2>Bayes' Theorem</h2>
<p>In frequentist statistics, many different estimators may be used, but in Bayesian statistics the only estimator is Bayes' Formula (aka Bayes' Rule or Bayes' Theorem).</p>
<p>Bayes' Theorem, aka Bayes' Rule:</p>
<ul>
<li><mathjax>$H$</mathjax> is the hypothesis (more commonly represented as the parameters <mathjax>$\theta$</mathjax>)</li>
<li><mathjax>$D$</mathjax> is the data</li>
</ul>
<p><mathjax>$$
P(H|D) = \frac{P(H)P(D|H)}{P(D)}
$$</mathjax></p>
<ul>
<li><mathjax>$P(H)$</mathjax> = the probability of the hypothesis before seeing the data. The <strong>prior</strong>.</li>
<li><mathjax>$P(H|D)$</mathjax> = probability of the hypothesis, given the data. The <strong>posterior</strong>.</li>
<li><mathjax>$P(D|H)$</mathjax> = the probability of the data under the hypothesis. The <strong>likelihood</strong>.</li>
<li><mathjax>$P(D)$</mathjax> = the probability of data under <em>any</em> hypothesis. The <strong>normalizing constant</strong>.</li>
</ul>
<p>For an example of likelihood:</p>
<p>If I want to predict the sides of a dice I rolled, and then I rolled an 8, then <mathjax>$P(D|\text{a six sided die}) = 0$</mathjax>. That is, it is impossible to have my observed data under the hypothesis of having a six sided die.</p>
<p>A key insight to draw from Bayes' Rule is that <mathjax>$P(H|D) \propto P(H)P(D|H)$</mathjax>, that is, the posterior is proportional to the product of the prior and the likelihood.</p>
<p>Note that the normalizing constant <mathjax>$P(D)$</mathjax> usually cannot be directly computed and is equivalent to <mathjax>$\int P(D|H)P(H) dH$</mathjax> (which is usually intractable since their are usually multiple parameters of interest, resulting in a multidimensional integration problem. If <mathjax>$\theta$</mathjax>, the parameters, is one dimensional, then you could integrate it rather easily).</p>
<p>One workaround is to do approximate inference with non-normalized posteriors, since we know that the posterior is proportional to the numerator term:</p>
<p><mathjax>$$
P(H|D) \propto P(H)P(D|H)
$$</mathjax></p>
<p>Another workaround to approximate the posterior using simulation methods such as Monte Carlo.</p>
<p>Given a set of hypotheses <mathjax>$H_0, H_1, \dots, H_n$</mathjax>, the distribution for the priors of these hypotheses is the <em>prior distribution</em>, i.e. <mathjax>$P(H_0), P(H_1), \dots, P(H_n)$</mathjax>.</p>
<p>The distribution of the posterior probabilities is the <em>posterior distribution</em>, i.e. <mathjax>$P(H_0|D), P(H_1|D), \dots, P(H_n|D)$</mathjax>.</p>
<h3>Likelihood</h3>
<p>Likelihood is not the same as probability (thus it does not have to sum to 1), but it is <em>proportional</em> to probability. More specifically, the likelihood of a hypothesis <mathjax>$H$</mathjax> given some data <mathjax>$D$</mathjax> is proportional to the probability of <mathjax>$D$</mathjax> given that <mathjax>$H$</mathjax> is true:</p>
<p><mathjax>$$
L(H|D) = k P(D|H)
$$</mathjax></p>
<p>Where <mathjax>$k$</mathjax> is a constant such that <mathjax>$k &gt; 0$</mathjax>.</p>
<p>With the probability <mathjax>$P(D|H)$</mathjax>, we fix <mathjax>$H$</mathjax> and allow <mathjax>$D$</mathjax> to vary. In the case of likelihood, this is reversed: we fix <mathjax>$D$</mathjax> and allow the hypotheses to vary.</p>
<p>The <strong>Law of Likelihood</strong> states that the hypothesis for which the probability of the data is greater is the more likely hypothesis. For example, <mathjax>$H_1$</mathjax> is a better hypothesis than <mathjax>$H_2$</mathjax> if <mathjax>$P(D|H_1) &gt; P(D|H_2)$</mathjax>.</p>
<p>We can also quantify <em>how much</em> better <mathjax>$H_1$</mathjax> is than <mathjax>$H_2$</mathjax> with the ratio of their likelihoods, i.e. <mathjax>$\frac{L(H_1|D)}{L(H_2|D)}$</mathjax>, which is proportional to <mathjax>$\frac{P(D|H_1)}{P(D|H_2)}$</mathjax>.</p>
<p>Likelihoods are meaningless in isolation (because of the constant <mathjax>$k$</mathjax>), they must be compared to other likelihoods, such that the constants cancel out, i.e. as ratios like the example above, to be meaningful.</p>
<p>A <strong>Bayes factor</strong> is an extension of likelihood ratios: it is a weighted average likelihood ratio based on the prior distribution of hypotheses. So we have some prior bias as to what hypotheses we expect, i.e. how probable we expect some hypotheses to be, and we weigh the likelihood ratios by these expected probabilities.</p>
<h2>Choosing a prior distribution</h2>
<p>With Bayesian inference, we must <em>choose</em> a prior distribution, then apply data to get our posterior distribution. The prior is chosen based on domain knowledge or intuition or perhaps from the results of previous analysis; that is, it is chosen subjectively - there is no prescribed formula for picking a prior. If you have no idea what to pick, you can just pick a uniform distribution as your prior.</p>
<p>Your choice of prior will affect the posterior that you get, and the subjectivity of this choice is what makes Bayesian statistics controversial - but it's worth noting that all of statistics, whether or frequentist or Bayesian, involves many subjective decisions (e.g. frequentists must decide on an estimator to use, what data to collect and how, and so on) - what matters most is that you are explicit about your decisions and why you made them.</p>
<p>Say we perform an Bayesian analysis and get a posterior. Then we get some new data for the same problem. We can re-use the posterior from before as our prior, and when we run Bayesian analysis on the new data, we will get a new posterior which reflects the additional data. We don't have to re-do any analysis on the data from before, all we need is the posterior generated from it.</p>
<p>For any unknown quantity we want to model, we say it is drawn from some prior of our choosing. This is usually some parameter describing a probability distribution, but it could be other values as well. This is central to Bayesian statistics - all unknowns are represented as distributions of possible values. In Bayesian statistics: if there's a value and you don't know what it is, come up with a prior for it and add it to your model!</p>
<p>If you think of distributions as landscapes or surfaces, then the data deforms the prior surface to mold it into the posterior distribution.</p>
<p>The surface's "resistance" to this shaping process depends on the selected prior distribution.</p>
<p>When it comes to selecting Bayesian priors, there are two broad categories:</p>
<ul>
<li><strong>objective priors</strong> - these let the data influence the posterior the most</li>
<li><strong>subjective priors</strong> - these allow the practitioner to asset their own views in to the prior. This prior can be the posterior from another problem or just come from domain knowledge.</li>
</ul>
<p>An example objective prior is a <strong>uniform</strong> (flat) prior where every value has equal weighting. Using a uniform prior is called <em>The Principle of Indifference</em>. Note that a uniform prior restricted within a range is <em>not</em> objective - it has to be over <em>all</em> possibilities.</p>
<p>Note that the more data you have (as <mathjax>$N$</mathjax> increases), the choice of prior becomes less important.</p>
<h3>Conjugate priors</h3>
<p><strong>Conjugate priors</strong> are priors which, when combined with the likelihood, result in a posterior which is in the same family. These are very convenient because the posterior can be calculated analytically, so there is no need to use approximation such as Markov Chain Monte Carlo (see below).</p>
<p>For example, a binomial likelihood is a conjugate with a beta prior - their combination results in a beta-binomial posterior.</p>
<p>For example, the Gaussian family of distributions are conjugate to itself (<em>self conjugate</em>) - a Gaussian likelihood with a Gaussian prior results in a Gaussian posterior.</p>
<p>For example, when working with count data you will probably use the Poisson distribution for your likelihood, which is conjugate with gamma distribution priors, resulting in a gamma posterior.</p>
<p>Unfortunately, conjugate priors only really show up in simple one-dimensional models.</p>
<p>More generally, we can define a conjugate prior like so:</p>
<p>Say random variable <mathjax>$X$</mathjax> comes from a well-known distribution, <mathjax>$f_{\alpha}$</mathjax> where <mathjax>$\alpha$</mathjax> are the possibly unknown parameters of <mathjax>$f$</mathjax>. It could be a normal, binomial, etc distribution.</p>
<p>For the given distribution <mathjax>$f_{\alpha}$</mathjax>, there may exist a prior distribution <mathjax>$p_{\beta}$</mathjax> such that</p>
<p><mathjax>$$
\overbrace{p_{\beta}}^{\text{prior}} \cdot \overbrace{f_{\alpha}(X)}^{\text{data}} = \overbrace{p_{\beta'}}^{\text{posterior} }
$$</mathjax></p>
<h4>Beta-Binomial Model</h4>
<p>The Beta-Binomial model is a useful Bayesian model because it provides values between 0 and 1, which is useful for estimating probabilities or percentages.</p>
<p>It involves, as you might expect, a beta and a binomial distribution.</p>
<p>So say we have <mathjax>$N$</mathjax> trials and observe <mathjax>$n$</mathjax> successes. We describe these observations by a binomial distribution, <mathjax>$n \sim \Bin(N, p)$</mathjax> for which <mathjax>$p$</mathjax> is unknown. So we want to come up with some distribution for <mathjax>$p$</mathjax> (remember, with Bayesian inference, you do not produce point estimates, that is, a single value, but a distribution for your unknown value to describe the uncertainty of its true value).</p>
<p>For frequentist inference we'd estimate <mathjax>$\hat p = \frac{n}{N}$</mathjax> which isn't quite good for low numbers of <mathjax>$N$</mathjax>.</p>
<p>This being Bayesian inference, we first must select a prior. <mathjax>$p$</mathjax> is a probability and therefore is bound to <mathjax>$[0, 1]$</mathjax>. So we could choose a uniform prior over that interval; that is <mathjax>$p \sim \Uni(0,1)$</mathjax>.</p>
<p>However, <mathjax>$\Uni(0, 1)$</mathjax> is equivalent to a beta distribution where <mathjax>$\alpha=1, \beta=1$</mathjax>, i.e. <mathjax>$\Bet(1,1)$</mathjax>. The beta distribution is bound between 0 and 1 so it's a good choice for estimating probabilities.</p>
<p>We prefer a beta prior over a uniform prior because, given binomial observations, the posterior will also be a beta distribution.</p>
<p>It works out nicely mathematically:</p>
<p><mathjax>$$
\begin{aligned}
p &amp;\sim \Bet(\alpha, \beta) \\
n &amp;\sim \Bin(N, p) \\
p \, | \, n, N &amp;\sim \Bet(\alpha + n, \beta + N - n)
\end{aligned}
$$</mathjax></p>
<p>So with these two distributions, we can directly compute the posterior with no need for simulation (e.g. MCMC).</p>
<p>How do you choose the parameters for a Beta prior? Well, it depends on the particular problem, but a conservative one, for when you don't have a whole lot of info to go on, is <mathjax>$\Bet(\frac{1}{2}, \frac{1}{2})$</mathjax>, known as <strong>Jeffrey's prior</strong>.</p>
<h5>Example</h5>
<p>We run 100 trials and observe 10 successes. What is the probability <mathjax>$p$</mathjax> of a successful trial?</p>
<p>Our knowns are <mathjax>$N=100, n=10$</mathjax>. A binomial distribution describes these observations, but we have the unknown parameter <mathjax>$p$</mathjax>.</p>
<p>For our prior for <mathjax>$p$</mathjax> we choose <mathjax>$\Bet(1,1)$</mathjax> since it is equivalent to a uniform prior over <mathjax>$[0,1]$</mathjax> (i.e. it is an objective prior).</p>
<p>We can directly compute the posterior now:</p>
<p><mathjax>$$
\begin{aligned}
p \, | \, n, N &amp;\sim \Bet(\alpha + n, \beta + N - n) \\
p &amp;\sim \Bet(11, 91)
\end{aligned}
$$</mathjax></p>
<p>Then we can draw samples from the distribution and compute its mean or other descriptive statistics such as the credible interval.</p>
<h3>Sensitivity Analysis</h3>
<p>The strength of the prior affects the posterior - the stronger your prior beliefs, the more difficult it is to change those beliefs (it requires more data/evidence). You can conduct <strong>sensitivity analysis</strong> to try your approach with various different priors to get an idea of how different priors affect your resulting posterior.</p>
<h3>Empirical Bayes</h3>
<p>Empirical Bayes is a method which combines frequentist and Bayesian approaches by using frequentist methods to select the hyperparameters.</p>
<p>For instance, say you want to estimate the <mathjax>$\mu$</mathjax> parameter for a normal distribution.</p>
<p>You could use the empirical sample mean from the observed data:</p>
<p><mathjax>$$
\mu_p = \frac{1}{N}\sum^N_{i=0} X_i
$$</mathjax><br />
Where <mathjax>$\mu_p$</mathjax> denotes the prior <mathjax>$\mu$</mathjax>.</p>
<p>Though if working with not much data, this kind of ends like double-counting your data.</p>
<h2>Markov Chain Monte Carlo (MCMC)</h2>
<p>With Bayesian inference, in order to describe your posterior, you often must evaluate complex multidimensional integrals (i.e. from very complex, multidimensional probability distributions), which can be computationally intractable.</p>
<p>Instead you can generate sample points from the posterior distribution and use those samples to compute whatever descriptions you need. This technique is called <strong>Monte Carlo integration</strong>, and the process of drawing repeated random samples in this way is called <strong>Monte Carlo simulation</strong>. In particular, we can use a family of techniques known as <strong>Markov Chain Monte Carlo</strong>, which combine Monte Carlo integration and simulation with Markov chains, to generate samples for us.</p>
<h3>Monte Carlo Integration</h3>
<p>Monte Carlo integration is a way to approximate complex integrals using random number generation.</p>
<p>Say we have a complex integral:</p>
<p><mathjax>$$
\int h(x)dx
$$</mathjax></p>
<p>If we can decompose <mathjax>$h(x)$</mathjax> into the product of a function <mathjax>$f(x)$</mathjax> and a probability density function <mathjax>$P(x)$</mathjax> describing the probabilities of the inputs <mathjax>$x$</mathjax>, then:</p>
<p><mathjax>$$
\int h(x)dx = \int f(x)P(x)dx = E_{P(x)}[f(x)]
$$</mathjax></p>
<p>That is, the result of this integral is the expected value of <mathjax>$f(x)$</mathjax> over the density <mathjax>$P(x)$</mathjax>.</p>
<p>We can approximate this expected value by taking the mean of many, many samples (<mathjax>$n$</mathjax> samples):</p>
<p><mathjax>$$
\int h(x)dx = E_{P(x)}[f(x)] \approx \frac{1}{n} \sum^n_{i=1} f(x_i)
$$</mathjax></p>
<p>This process of approximating the integral is <em>Monte Carlo integration</em>.</p>
<p>For very simple cases of known distributions, we can sample directly, e.g.</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="c"># Say we think the distribution is a Poisson distribution</span>
<span class="c"># and the parameter of our distribution, lambda,</span>
<span class="c"># is unknown and what we want to discover.</span>
<span class="n">lam</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c"># Collect 100000 samples</span>
<span class="n">sim_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">poisson</span><span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">100000</span><span class="p">)</span>

<span class="c"># Get whatever descriptions we want, e.g.</span>
<span class="n">mean</span> <span class="o">=</span> <span class="n">sim_vals</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

<span class="c"># For poisson, the mean is lambda, so we expect</span>
<span class="c"># them to be approximately equal (given a large enough sample size)</span>
<span class="nb">abs</span><span class="p">(</span><span class="n">lam</span> <span class="o">-</span> <span class="n">mean</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mf">0.001</span>
</pre></div>


<h3>Markov Chains</h3>
<p>Markov chains are a stochastic process in which the next state depends only on the current state.</p>
<p>Consider a random variable <mathjax>$X$</mathjax> and a time index <mathjax>$t$</mathjax>. The state of <mathjax>$X$</mathjax> at time <mathjax>$t$</mathjax> is notated <mathjax>$X_t$</mathjax>.</p>
<p>For a Markov chain, the state <mathjax>$X_{t+1}$</mathjax> depends only on the current state <mathjax>$X_t$</mathjax>, that is:</p>
<p><mathjax>$$
P(X_{t+1} = x_{t+1}|X_t = x_t, X_{t-1} = x_{t-1}, \dots, X_0 = x_0) = P(X_{t+1} = x_{t+1}| X_t = x_t)
$$</mathjax></p>
<p>Where <mathjax>$P(X_{t+1} = x_{t+1})$</mathjax> is the <strong>transition probability</strong> of <mathjax>$X_{t+1} = x_{t+1}$</mathjax>. The collection of transition probabilities is called a <strong>transition matrix</strong> (for discrete states); more generally is is called a <strong>transition kernel</strong>.</p>
<p>If we consider <mathjax>$t$</mathjax> going to infinity, the Markov chain settles on a <strong>stationary distribution</strong>, where <mathjax>$P(X_t) = P(X_{t-1})$</mathjax>. The stationary distribution does not depend on the initial state of the network. Markov chains are <em>erdogic</em>, i.e. they "mix", which means that the influence of the initial state weakens with time (the rate at which it mixes is its <em>mixing speed</em>).</p>
<p>If we call the <mathjax>$k \times k$</mathjax> transition matrix <mathjax>$P$</mathjax> and the marginal probability of a state at time <mathjax>$t$</mathjax> is a <mathjax>$k \times 1$</mathjax> vector <mathjax>$\pi$</mathjax>, then the distribution of the state at time <mathjax>$t+1$</mathjax> is <mathjax>$\pi'P$</mathjax>. If <mathjax>$\pi'P = \pi'$</mathjax>, then <mathjax>$pi$</mathjax> is the stationary distribution of the Markov chain.</p>
<h3>Markov Chain Monte Carlo</h3>
<p>MCMC is useful because often we may encounter distributions which aren't easily expressed mathematically (e.g. their functions may have very strange shapes), but we still want to compute some descriptive statistics (or make other computations) from them. MCMC allows us to work with such distributions without needing precise mathematical formulations of them.</p>
<p>More generally, MCMC is really useful if you don't want to (or can't) find the underlying function describing something. As long as you can simulate that process in some way, you don't need to know the exact function - you can just generate enough sample data to work with in its stead. So MCMC is a brute force but effective method.</p>
<p>Rather than directly compute the integral for posterior distributions in Bayesian analysis, we can instead use MCMC to draw several (thousands, millions, etc) samples from the probability distribution, then use these samples to compute whatever descriptions we'd like about the distribution (often this is some expected value of a function, <mathjax>$E[f(x)]$</mathjax>, where its inputs are drawn from distribution, i.e. <mathjax>$x \sim p$</mathjax>, where <mathjax>$p$</mathjax> is some probability distribution).</p>
<p>You start with some random initial sample and, based on that sample, you pick a new sample. This is the Markov Chain aspect of MCMC - the next sample you choose depends only on the current sample. This works out so that you spend most your time with high probability samples (b/c they have higher transition probabilities) but occasionally jump out to lower probability samples. Eventually the MCMC chain will converge on a random sample.</p>
<p>So we can take all these <mathjax>$N$</mathjax> samples and, for example, compute the expected value:</p>
<p><mathjax>$$
E[f(x)] \approx \frac{1}{N} \sum^N_{i=1}f(x_i)
$$</mathjax></p>
<p>Because of the random initialization, there is a "<strong>burn-in</strong>" phase in which the sampling model needs to be "warmed up" until it reaches an equilibrium sampling state, the <em>stationary distribution</em>. So you discard the first hundred or thousand or so samples as part of this burn-in phase. You can (eventually) arrive at this stationary distribution <em>independent of where you started</em> which is why the random initialization is ok - this is an important feature of Markov Chains.</p>
<p>MCMC is a general technique of which there are several algorithms.</p>
<h4>Rejection Sampling</h4>
<p>Monte Carlo integration allows us to draw samples from a posterior distribution with a known parametric form. It does not, however, enable us to draw samples from a posterior distribution without a known parametric form. We may instead use <strong>rejection sampling</strong> in such cases.</p>
<p>We can take our function <mathjax>$f(x)$</mathjax> and if it has bounded/finite <em>support</em> ("support" is the <mathjax>$x$</mathjax> values where <mathjax>$f(x)$</mathjax> is non-zero, and can be thought of the range of meaningful <mathjax>$x$</mathjax> values for <mathjax>$f(x)$</mathjax>), we can calculate its maximum and then define a bounding rectangle with it, encompassing all of the support values. This envelope function should contain all possible values of <mathjax>$f(x)$</mathjax>  Then we can randomly generate points from within this box and check if they are under the curve (that is, less than <mathjax>$f(x)$</mathjax> for the point's <mathjax>$x$</mathjax> value). If a point is not under the curve, we reject it. Thus we approximate the integral like so:</p>
<p><mathjax>$$
\frac{\text{points under curve}}{\text{points generated}} \times \text{box area} = \lim_{n \to \infty} \int_A^B f(x)dx
$$</mathjax></p>
<p>In the case of unbounded support (i.e. infinite tails), we instead choose some <em>majorizing</em> or <em>enveloping</em> function <mathjax>$g(x)$</mathjax> (<mathjax>$g(x)$</mathjax> is typically a probability density itself and is called a <em>proposal density</em>) such that <mathjax>$cg(x) \geq f(x) \, , \forall x \in (-\infty, \infty)$</mathjax>, where <mathjax>$c$</mathjax> is some constant. This functions like the bounding box from before. It completely encloses <mathjax>$f$</mathjax>. Ideally we choose <mathjax>$g(x)$</mathjax> so that it is close to the target distribution, that way most of our sampled points can be accepted.</p>
<p>Then, for each <mathjax>$x_i$</mathjax> we draw (i.e. sample), we also draw a uniform random value <mathjax>$u_i$</mathjax>. Then if <mathjax>$u_i &lt; \frac{f(x_i)}{cg(x_i)}$</mathjax>, we accept <mathjax>$x_i$</mathjax>, otherwise, we reject it.</p>
<p>The intuition here is that the probability of a given point being accepted is proportional to the function <mathjax>$f$</mathjax> at that point, so when there is greater density in <mathjax>$f$</mathjax> for that point, that point is more likely to be accepted.</p>
<p>In multidimensional cases, you draw candidates from every dimension simultaneously.</p>
<h4>Metropolis-Hastings</h4>
<p>The <strong>Metropolis-Hastings</strong> algorithm uses Markov chains with rejection sampling.</p>
<p>The proposal density <mathjax>$g(\theta_t)$</mathjax> is chosen as in rejection sampling, but it depends on <mathjax>$\theta_{t-1}$</mathjax>, i.e. <mathjax>$g(\theta_t|\theta_{t-1})$</mathjax>.</p>
<p>First select some initial <mathjax>$\theta$</mathjax>, <mathjax>$\theta_1$</mathjax>.</p>
<p>Then for <mathjax>$n$</mathjax> iterations:</p>
<ul>
<li>Draw a candidate <mathjax>$\theta_t^c \sim g(\theta_t|\theta_{t-1})$</mathjax></li>
<li>Compute the Metropolis-Hastings ratio: <mathjax>$R = \frac{f(\theta_t^c)g(\theta_{t-1}|\theta_t^c)}{f(\theta_{t-1})g(\theta_t^c|\theta_{t-1})}$</mathjax></li>
<li>Draw <mathjax>$u \sim \Uni$</mathjax></li>
<li>If <mathjax>$u &lt; R$</mathjax>, accept <mathjax>$\theta_t = \theta_t^c$</mathjax>, otherwise, <mathjax>$\theta_t = \theta_{t-1}$</mathjax></li>
</ul>
<p>There are a few required properties of the Markov chain for this to work properly:</p>
<ul>
<li>The stationary distribution of the chain must be the target density:<ul>
<li>The chain must be <em>recurrent</em> - that is, for all <mathjax>$\theta \in \Theta$</mathjax> in the <em>target density</em> (the density we wish to approximate), the probability of returning to any state <mathjax>$\theta_i \in Theta = 1$</mathjax>. That is, it must be possible <em>eventually</em> for any state in the state space to be reached.</li>
<li>The chain must be <em>non-null</em> for all <mathjax>$\theta \in \Theta$</mathjax> in the target density; that is, the expected time to recurrence is finite.</li>
<li>The chain must have a stationary distribution equal to the target density.</li>
</ul>
</li>
<li>The chain must be <em>ergodic</em>, that is:<ul>
<li>The chain must be <em>irreducible</em> - that is, any state <mathjax>$\theta_i$</mathjax> can be reached from any other state <mathjax>$\theta_j$</mathjax> in a finite number of transitions (i.e. the chain should not get stuck in any infinite loops)</li>
<li>The chain must be <em>aperiodic</em> - that is, there should not be a fixed number of transitions to get from any state <mathjax>$\theta_i$</mathjax> to any state <mathjax>$\theta_j$</mathjax>. For instance, it should not always take three steps to get from one place to another - that would be a period. Another way of putting this - there are no fixed cycles in the chain.</li>
</ul>
</li>
</ul>
<p>It can been proven that the stationary distribution of the Metropolis-Hastings algorithm is the target density (proof omitted).</p>
<p>Th ergodic property (whether or not the chain "mixes" well) can be validated with some <em>convergence diagnostics</em>  A common method is to plot the chain's values as their drawn and see if the values tend to concentrate around a constant; if not, you should try a different proposal density.</p>
<p>Alternatively, you can look at an autocorrelation plot, which measures the internal correlation (from -1 to 1) over time, called "lag". We expect that the greater the lag, the less the points should be autocorrelated - that is, we expect autocorrelation to smoothly decrease to 0 with increasing lag. If autocorrelation remains high, then the chain is not fully exploring the space. Autocorrelation can be improved by <em>thinning</em>, which is a technique where only every <mathjax>$k$</mathjax>th draw is kept and others are discarded.</p>
<p>Finally, you also have the options of running multiple chains, each with different starting values, and combining those samples.</p>
<p>You should also use burn-in.</p>
<h4>Gibbs Sampling</h4>
<p>It is easy to sample from simple distributions. For example, for a binomial distribution, you can basically just flip a coin. For a multinomial distribution, you can basically just roll a dice.</p>
<p>If you have a multinomial, multivariate distribution, e.g. <mathjax>$P(x_1, x_2, \dots, x_n)$</mathjax>, things get more complicated. If the variables are independent, you can factorize the multivariate distribution as a product of univariate distributions, treating each as a univariate multinomial distribution, i.e. <mathjax>$P(x_1, x_2, \dots, x_n) = P(x_1) \times P(x_2) \times \dots \times P(x_n)$</mathjax>. Then you can just sample from each distribution individually, i.e. as a dice roll.</p>
<p>However - what if these aren't independent, and we want to sample from the <em>joint distribution</em> <mathjax>$P(x_1, x_2, \dots, x_n)$</mathjax>? We can't factorize it into simpler distributions like before.</p>
<p>With Gibbs sampling we can approximate this joint distribution under the condition that we can easily sample from the conditional distribution for each variable, i.e. <mathjax>$P(x_i | x_1, \dots, x_{i-1}, x_{i+1}, \dots, x_n)$</mathjax>. (This condition is satisfied on Bayesian networks.)</p>
<p>We take advantage of this and iteratively sample from these conditional distributions and using the most recent value for each of the other variables (starting with random values at first). For example, sampling <mathjax>$x_1|x_2, \dots, x_n$</mathjax>, then fixing this value for <mathjax>$x_1$</mathjax> while sampling <mathjax>$x_2|x_1, x_3, \dots, x_n$</mathjax>, then fixing both <mathjax>$x_1$</mathjax> and <mathjax>$x_2$</mathjax> while sampling <mathjax>$x_3|x_1, x_2, x_4, \dots, x_n$</mathjax>, and so on.</p>
<p>If you iterate through this a large number of times you get an approximation of samples taken from the actual joint distribution.</p>
<p>Another way to look at Gibbs sampling:</p>
<p>Say you have random variables <mathjax>$c, r, t$</mathjax> (cloudy, raining, thundering) and you have the following probability tables:</p>
<table>
<thead>
<tr>
<th>c</th>
<th>P(c)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0.5</td>
</tr>
<tr>
<td>1</td>
<td>0.5</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>c</th>
<th>r</th>
<th>P(r&#124;c)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0.9</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0.1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0.1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0.9</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>c</th>
<th>r</th>
<th>t</th>
<th>P(t&#124;c,r)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0.9</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0.1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0.5</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0.5</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0.6</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0.4</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0.1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0.9</td>
</tr>
</tbody>
</table>
<p>We can first pick some starting sample, e.g. <mathjax>$c=1,r=0,t=1$</mathjax>.</p>
<p>Then we fix <mathjax>$r=0, t=1$</mathjax> and randomly pick another <mathjax>$c$</mathjax> value according to the probabilities in the table (here it is equally likely that we get <mathjax>$c=0$</mathjax> or <mathjax>$c=1$</mathjax>). Say we get <mathjax>$c=0$</mathjax>. Now we have a new sample <mathjax>$c=0,r=0,t=1$</mathjax>.</p>
<p>Now we fix <mathjax>$c=0,t=1$</mathjax> and randomly pick another <mathjax>$r$</mathjax> value. Here <mathjax>$r$</mathjax> is dependent only on <mathjax>$c$</mathjax>. <mathjax>$c=0$</mathjax> so we have a <mathjax>$0.9$</mathjax> probability of picking <mathjax>$r=0$</mathjax>. Say that we do. We have another sample <mathjax>$c=0,r=0,t=1$</mathjax>, which happens to be the same as the previous sample.</p>
<p>Now we fix <mathjax>$c=0,r=0$</mathjax> and pick a new <mathjax>$t$</mathjax> value. <mathjax>$t$</mathjax> is dependent on both <mathjax>$c$</mathjax> and <mathjax>$r$</mathjax>. <mathjax>$c=0,r=0$</mathjax>, so we have a <mathjax>$0.9$</mathjax> chance of picking <mathjax>$t=0$</mathjax>. Say that we do. Now we have another sample <mathjax>$c=0,r=0,t=0$</mathjax>. Then we repeat this process until convergence (or for some specified number of iterations).</p>
<p>Your samples will reflect the actual joint distribution of these values, since more likely samples are, well, more likely to be generated.</p>
<h2>Variational Inference</h2>
<p>MCMC can take a long time to get good answers - in theory if you run it infinitely it will generate enough samples to get a perfectly accurate distribution, but that's not a fair criterion (many algorithms do well if they have infinite time).</p>
<p>With <em>variational inference</em> we don't need to take samples - instead we fit an approximate joint distribution <mathjax>$Q(x; \theta)$</mathjax> to approximate the true joint posterior <mathjax>$P(x)$</mathjax>, turning it into an optimization problem (we try to get them as close as possible according to the KL divergence <mathjax>$\text{KL}[Q(x;\theta)||P(x)]$</mathjax>. So we are interested in the parameters <mathjax>$\theta$</mathjax>.</p>
<p>The <em>mean-field</em> form of variational inference assumes that <mathjax>$Q$</mathjax> factorizes into independent single-variable factors, i.e. <mathjax>$Q(x) = \prod_i Q_i(x_i|\theta_i)$</mathjax>.</p>
<h2>Bayesian point estimates</h2>
<p>Bayesian inference returns a distribution (the posterior) but we often need a single value (or a vector in multivariate cases). So we choose a value from the posterior. This value is a <strong>Bayesian point estimate</strong>.</p>
<p>Selecting the MAP (<em>maximum a posterior</em>) value is insufficient because it neglects the shape of the distribution.</p>
<p>Suppose <mathjax>$P(\theta|X)$</mathjax> is the posterior distribution of <mathjax>$\theta$</mathjax> after observing data <mathjax>$X$</mathjax>.</p>
<p>The <em>expected loss</em> of choosing estimate <mathjax>$\hat \theta$</mathjax> to estimate <mathjax>$\theta$</mathjax> (the true parameter), also known as the <em>risk</em> of estimate <mathjax>$\hat \theta$</mathjax> is:</p>
<p><mathjax>$$
l(\hat \theta) = E_{\theta} [L(\theta, \hat \theta)]
$$</mathjax></p>
<p>Where <mathjax>$L(\theta, \hat \theta)$</mathjax> is some loss function.</p>
<p>You can approximate the expected loss using the Law of Large Numbers, which just states that as sample size grows, the expected value approaches the actual value. That is, as <mathjax>$N$</mathjax> grows, the expected loss approaches 0.</p>
<p>For approximating expected loss, it looks like:</p>
<p><mathjax>$$
\frac{1}{N} \sum^N_{i=1} L(\theta_i, \hat \theta) \approx E_{\theta}[L(\theta, \hat \theta)] = l(\hat \theta)
$$</mathjax></p>
<p>You want to select the estimate <mathjax>$\hat \theta$</mathjax> which minimizes this expected loss:</p>
<p><mathjax>$$
\argmin_{\hat \theta} E_{\theta}[L(\theta, \hat \theta)]
$$</mathjax></p>
<h2>Credible Intervals (Credible Regions)</h2>
<p>In Bayesian statistics, The closest analog to confidence intervals in frequentist statistics is the <strong>credible interval</strong>. It is <em>much</em> easier to interpret than the confidence interval because it is exactly what most people confuse the confidence interval to be. For instance, the 95% credible interval is the interval in which we expect to find <mathjax>$\theta$</mathjax> 95% of the time.</p>
<p>Mathematically this is expressed as:</p>
<p><mathjax>$$
P(a(y) &lt; \theta &lt; b(y)|Y=y) = 0.95
$$</mathjax></p>
<p>We condition on <mathjax>$Y$</mathjax> because in Bayesian statistics, the data is fixed and the parameters are random.</p>
<h2>Bayesian Regression</h2>
<p>The Bayesian methodology can be applied to regression as well. In conventional regression the parameters are treated as fixed values that we uncover. In Bayesian regression, the parameters are treated as random variables, as they are elsewhere in Bayesian statistics. We define prior distributions for each parameter - in particular, normal priors, so that for each parameter we define a prior mean as well as a covariance matrix for all the parameters.</p>
<p>So we specify:</p>
<ul>
<li><mathjax>$b_0$</mathjax> - a vector of prior means for the parameters</li>
<li><mathjax>$B_0$</mathjax> - a covariance matrix such that <mathjax>$\sigma^2 B_0$</mathjax> is the prior covariance matrix of <mathjax>$\beta$</mathjax></li>
<li><mathjax>$v_0 &gt; 0$</mathjax> - the degrees of freedom for the prior</li>
<li><mathjax>$\sigma_0^2 &gt; 0$</mathjax> - the variance for the prior (which essentially functions as your strength of belief in the prior - the lower the variance, the more concentrated your prior is around the mean, thus the stronger your belief)</li>
</ul>
<p>So the prior for your parameters then is a normal distribution parameterized by <mathjax>$(b_0, B_0)$</mathjax>.</p>
<p>Then <mathjax>$v_0$</mathjax> and <mathjax>$\sigma_0^2$</mathjax> give a prior for <mathjax>$\sigma^2$</mathjax>, which is an inverse gamma distribution parameterized by <mathjax>$(v_0, \sigma_0^2 v_0)$</mathjax>.</p>
<p>Then there are a few formulas:</p>
<p><mathjax>$$
\begin{aligned}
b_1 &amp;= (B_0^{-1}  + X'X)^{-1}(B_0^{-1}b_0 + X'X\hat \beta) \\
B_1 &amp;= (B_0^{-1} + X'X)^{-1} \\
v_1 &amp;= v_0 + n \\
v_1 \sigma_1^2 &amp;= v_0 \sigma_0^2 + S + r \\
S &amp;= \text{sum of squared errors of the regression} \\
r &amp;= (b_0-\hat \beta)'(B_0 + (X'X)^{-1})^{-1}(b_0 - \hat \beta) \\
f(\beta~|~\sigma^2,y,x) &amp;= \Phi(b_1, \sigma^2 B_1) \\
f(\sigma^2~|~y,x) &amp;= \text{inv.gamma}(\frac{v_1}{2}, \frac{v_1\sigma_1^2}{2}) \\
f(\beta~|~y,x) &amp;= \int f(\beta~|~\sigma^2,y,x) f(\sigma^2~|~y,x)d\sigma^2 = t(b_1, \sigma_1^2B_1,\text{degrees of freedom}=v_1)
\end{aligned}
$$</mathjax></p>
<p>So the resulting distribution of parameters is a multivariate <mathjax>$t$</mathjax> distribution.</p>
<h2>A Bayesian example</h2>
<p>Let's say we have a coin. We are uncertain whether or not it's a fair coin. What can we learn about the coin's fairness from a Bayesian approach?</p>
<p>Let's restate the problem. We can represent the outcome of a coin flip with a random variable, <mathjax>$X$</mathjax>. If the coin is not fair, we expect to see heads 100% of the time. That is, if the coin is unfair, <mathjax>$P(X=\text{heads}) = 1$</mathjax>. Otherwise, we expect it to be around <mathjax>$P(X=\text{heads}) = 0.5$</mathjax>.</p>
<p>It's reasonable to assume that <mathjax>$X$</mathjax> is drawn from a binomial distribution, so we'll use that. The binomial distribution is parameterized by <mathjax>$n$</mathjax>, the number of trials, and <mathjax>$p$</mathjax>, the probability of a "success" (in this case, a heads), on a given flip. We can restate our previous statements about the coin's fairness in terms of this parameter <mathjax>$p$</mathjax>. That is, if the coin is unfair, we expect <mathjax>$p=1$</mathjax>, otherwise, we expect it to be around <mathjax>$p=0.5$</mathjax>.</p>
<p>Thus <mathjax>$p$</mathjax> is the unknown parameter we are interested in, and with the Bayesian approach, we consider it a random variable as well; i.e. drawn from some distribution. First we must state what we believe this distribution to be <em>prior</em> to any evidence (i.e. decide on a prior to use). Because <mathjax>$p$</mathjax> is a probability, the beta distribution seems like a good choice since it is bound to <mathjax>$[0,1]$</mathjax> like a probability. The beta distribution has the additional advantage of being a <em>conjugate prior</em>, so the posterior is analytically derived and requires no simulation.</p>
<p>The beta distribution is parameterized by <mathjax>$\alpha$</mathjax> and <mathjax>$\beta$</mathjax> (i.e. they are our hyperparameters, <mathjax>$\Bet(\alpha, \beta)$</mathjax>). Here we can choose values for <mathjax>$\alpha$</mathjax> and <mathjax>$\beta$</mathjax> depending on how we choose to proceed. Let's be conservative and use an uninformative prior, that is, a uniform/flat prior, acting as if we don't feel strongly about the coin's bias either way prior to flipping the coin. The beta distribution <mathjax>$\Bet(1,1)$</mathjax> is flat.</p>
<p>The posterior for a beta prior will not be derived here, but it is <mathjax>$\Bet(\alpha + k, \beta + (n-k))$</mathjax>, where <mathjax>$k$</mathjax> is the number of successes (heads) in our evidence, and <mathjax>$n$</mathjax> is the total number of trials in our evidence.</p>
<p>Now we can flip the coin a few times to gather our evidence.</p>
<p>Below are some illustrations of possible evidence with the prior and the resulting posterior.</p>
<figure><img alt="Some possible outcomes with a flat prior" src="../assets/flat_prior.svg" /><figcaption>Some possible outcomes with a flat prior</figcaption>
</figure>
<p>A few things to note here:</p>
<ul>
<li>When the evidence has even amounts of tails and heads, the posterior centers around <mathjax>$p=0.5$</mathjax>.</li>
<li>When the evidence has even one tail, the possibility of <mathjax>$p=1$</mathjax> drops to nothing.</li>
<li>When the evidence has no tails, the posterior places more weight on an unfair coin, but there is still some possibility of <mathjax>$p=0.5$</mathjax>. As the number of evidence increases, however, and still no tails show up, the posterior will have even more weight pushed towards <mathjax>$p=1$</mathjax>.</li>
<li>When the is a lot of evidence containing even amounts of tails and heads, there is greater confidence that <mathjax>$p=0.5$</mathjax> (that is, there's smaller variance around it).</li>
</ul>
<p>What if instead of a flat prior, we had assumed that the coin was fair to begin with? In this scenario, the <mathjax>$\alpha$</mathjax> and <mathjax>$\beta$</mathjax> values function like counts for heads and tails. So to assume a fair coin we could say, <mathjax>$\alpha=10, \beta=10$</mathjax>. If we have a really strong belief that it is a fair coin, we could say <mathjax>$\alpha=100, \beta=100$</mathjax>. The higher these values are, the stronger our belief.</p>
<figure><img alt="Some possible outcomes with a informative prior" src="../assets/informative_prior.svg" /><figcaption>Some possible outcomes with a informative prior</figcaption>
</figure>
<p>Since our prior belief is stronger than it was with a flat prior, the same amount of evidence doesn't change the prior belief as much. For instance, now if we see a streak of heads, we are less convinced it is unfair.</p>
<p>In either case, we could take the expected value of <mathjax>$p$</mathjax>'s posterior distribution as our estimate for <mathjax>$p$</mathjax>, and then use that as evidence for a fair or unfair coin.</p>
<h3>References</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=ps5MYi81IsE">POLS 506: Simple Bayesian Models</a>. Justin Esarey.</li>
<li><a href="https://www.youtube.com/watch?v=cxWzsCoYT8Q">POLS 506: Basic Monte Carlo Procedures and Sampling</a>. Justin Esarey.</li>
<li><a href="https://www.youtube.com/watch?v=j4nEAqUUnVw">POLS 506: Metropolis-Hastings, the Gibbs Sampler, and MCMC</a>. Justin Esarey.</li>
<li><a href="https://www.youtube.com/watch?v=12eZWG0Z5gY">Markov chain Monte Carlo (MCMC) introduction</a>. <a href="https://www.youtube.com/channel/UCcAtD_VYwcYwVbTdvArsm7w">mathematicalmonk</a>.</li>
<li><a href="http://jeremykun.com/2015/04/06/markov-chain-monte-carlo-without-all-the-bullshit/">Markov Chain Monte Carlo Without all the Bullshit</a>. Jeremy Kun.</li>
<li><a href="http://homepages.dcc.ufmg.br/~assuncao/pgm/aulas2014/mcmc-gibbs-intro.pdf">http://homepages.dcc.ufmg.br/~assuncao/pgm/aulas2014/mcmc-gibbs-intro.pdf</a></li>
<li><a href="http://nitro.biosci.arizona.edu/courses/EEB596/handouts/Gibbs.pdf">Markov Chain Monte Carlo and Gibbs Sampling</a>. B. Walsh.</li>
<li><a href="https://plot.ly/ipython-notebooks/computational-bayesian-analysis/">Computational Methods in Bayesian Analysis</a>. Chris Fonnesbeck.</li>
<li><a href="http://greenteapress.com/thinkbayes/">Think Bayes</a>. Version 1.0.6. Allen Downey.</li>
<li><a href="https://www.youtube.com/watch?v=heFaYLKVZY4">Computational Statistics II</a> (<a href="https://github.com/fonnesbeck/scipy2015_tutorial">code</a>). Chris Fonnesbeck. SciPy 2015.</li>
<li><a href="https://github.com/fonnesbeck/scipy2014_tutorial">Bayesian Statistical Analysis</a>. Chris Fonnesbeck. SciPy 2014.</li>
<li><a href="https://github.com/CamDavidsonPilon/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers">Probabilistic Programming and Bayesian Methods for Hackers</a>. Cam Davidson Pilon.</li>
<li><a href="https://jakevdp.github.io/blog/2015/08/07/frequentism-and-bayesianism-5-model-selection/">Frequentism and Bayesianism V: Model Selection</a>. Jake Vanderplas.</li>
<li><a href="http://alexanderetz.com/2015/04/15/understanding-bayes-a-look-at-the-likelihood/">Understanding Bayes: A Look at the Likelihood</a>. Alex Etz.</li>
<li><a href="https://www.cs.jhu.edu/~jason/tutorials/variational.html">High-Level Explanation of Variational Inference</a>. Jason Eisner.</li>
<li><a href="http://twiecki.github.io/blog/2016/06/01/bayesian-deep-learning/">Bayesian Deep Learning</a>. Thomas Wiecki.</li>
<li><a href="http://www.orchid.ac.uk/eprints/40/1/fox_vbtut.pdf">A Tutorial on Variational Bayesian Inference</a>. Charles Fox, Stephen Roberts.</li>
<li><a href="https://www.cs.princeton.edu/courses/archive/fall11/cos597C/lectures/variational-inference-i.pdf">Variational Inference</a>. David M. Blei.</li>
<li><a href="https://youtu.be/LlzVlqVzeD8">Probabilistic Programming Data Science with PyMC3</a>. Thomas Wiecki.</li>
</ul>
    
    <script src="http://cdn.bootcss.com/jquery/1.11.1/jquery.js"></script>
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>
    <script>
        $(document).ready(function() {
            $('pre').each(function(i, e) {hljs.highlightBlock(e)});
            MathJax.Hub.Config({
                tex2jax: {
                    inlineMath: [["$","$"]],
                    displayMath: [['$$','$$']],
                    processEscapes: true
                },
                "HTML-CSS": {
                    linebreaks: { automatic: true }
                }
            });
            MathJax.Hub.Startup.onload();
        });
    </script>
    <script src="http://ai-code.tech/ai_notes_html/js/custom.js"></script>


</body>
</html>
