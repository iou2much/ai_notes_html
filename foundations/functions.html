
<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1">

    <title>Functions</title>

    <link rel="stylesheet" type="text/css" href="../style.css">
    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/color-brewer.min.css">
    <link rel="stylesheet" href="http://ai-code.tech/ai_notes_html/css/custom.css">
</head>

<body>

    <p><mathjax>$$
\DeclareMathOperator{\Img}{im}
$$</mathjax></p>
<h1>函数</h1>
<h1>Functions</h1>
<p>函数是不同集合间值的映射关系:</p>
<p>Fundamentally, a function is a relationship (mapping) between the values of some set <mathjax>$X$</mathjax> and some set <mathjax>$Y$</mathjax>:</p>
<p><mathjax>$$ f:X \to Y $$</mathjax></p>
<figure><img alt="A function is a mapping between domains." src="../assets/function.svg" /><figcaption>A function is a mapping between domains.</figcaption>
</figure>
<p>函数能对同一个集合内的元素自身映射.例如, <mathjax>$f(x) = x^2$</mathjax>,也可记为<mathjax>$f:x \mapsto x^2$</mathjax>, 是所有实数映射到所有实数, <mathjax>$f:\mathbb R \to \mathbb R$</mathjax>.</p>
<p>A function can map a set to itself. For example, <mathjax>$f(x) = x^2$</mathjax>, also notated <mathjax>$f:x \mapsto x^2$</mathjax>, is the mapping of all real numbers to all real numbers, or <mathjax>$f:\mathbb R \to \mathbb R$</mathjax>.</p>
<p>映射的源集合叫 <strong>定义域</strong>.</p>
<p>The set you are mapping <em>from</em> is called the <strong>domain</strong>.</p>
<p>映射的目标集合叫<strong>到达域</strong>.</p>
<p>The set that is being mapped <em>to</em> is called the <strong>codomain</strong>.</p>
<p><strong>值域</strong>是到达域的子集, 是函数真正映射到的范围.(一个函数不一定会映射到到达域中的每一个值, 但当这发生时, 值域与到达域相等)</p>
<p>The <strong>range</strong> is the subset of the codomain which the function actually maps to (a function doesn't necessarily map to <em>every</em> value in the codomain. But where it does, the range equals the codomain).</p>
<p>映射到<mathjax>$\mathbb R$</mathjax>的函数称为<strong>标量函数</strong>或<strong>实数函数</strong>.</p>
<p>Functions which map to <mathjax>$\mathbb R$</mathjax> are known as <strong>scalar-valued</strong> or <strong>real-valued</strong> functions.</p>
<p>映射到<mathjax>$\mathbb R^n$</mathjax>的函数,当<mathjax>$n &gt; 1$</mathjax>时,是<strong>向量函数</strong>.</p>
<p>Functions which map to <mathjax>$\mathbb R^n$</mathjax> where <mathjax>$n &gt; 1$</mathjax> are known as <strong>vector-valued</strong> functions.</p>
<h3>恒等函数</h3>
<h3>Identity functions</h3>
<p>恒等函数是把值映射到自身的函数:</p>
<p>An identity function maps something to itself:</p>
<p><mathjax>$$
I_X : X \to X
$$</mathjax></p>
<p>也就是说, 对<mathjax>$X$</mathjax>中的每个<mathjax>$a$</mathjax>,<mathjax>$I_X(a) = a$</mathjax>:</p>
<p>That is, for every <mathjax>$a$</mathjax> in <mathjax>$X$</mathjax>, <mathjax>$I_X(a) = a$</mathjax>:</p>
<p><mathjax>$$
I_X(a) = a, \forall \, a \in X
$$</mathjax></p>
<h3>反函数</h3>
<h3>The inverse of a function</h3>
<p>例如说有一个函数<mathjax>$f: X \to Y$</mathjax>, 对任意<mathjax>$a \in X$</mathjax>,有<mathjax>$f(a) = b$</mathjax>.<br />
Say we have a function <mathjax>$f: X \to Y$</mathjax>, where <mathjax>$f(a) = b$</mathjax> for any <mathjax>$a \in X$</mathjax>.</p>
<p>我们说<mathjax>$f$</mathjax>是<strong>可逆的</strong>, 如果存在一个函数<mathjax>$f^{-1}: Y \to X$</mathjax>,使 <mathjax>$f^{-1} \circ f = I_X$</mathjax> and <mathjax>$f \circ f^{-1} = I_Y$</mathjax>,</p>
<p>We say <mathjax>$f$</mathjax> is <strong>invertible</strong> if and only if there exists a function <mathjax>$f^{-1}: Y \to X$</mathjax> such that <mathjax>$f^{-1} \circ f = I_X$</mathjax> and <mathjax>$f \circ f^{-1} = I_Y$</mathjax>. Note that <mathjax>$\circ$</mathjax> denotes <strong>function composition</strong>, i.e. <mathjax>$f \circ g = f(g)$</mathjax>, which is the same as <mathjax>$f(g(x))$</mathjax>.</p>
<p>函数的逆是具有<strong>唯一性</strong>,它是满射且是一一映射,每一个<mathjax>$y$</mathjax>都有唯一的<mathjax>$x$</mathjax>与之对应.</p>
<p>The inverse of a function is <em>unique</em>, that is, it is <em>surjective</em> and <em>injective</em> (described below), that is, there is a unique <mathjax>$x$</mathjax> for each <mathjax>$y$</mathjax>.</p>
<h3>满射</h3>
<h3>Surjective functions</h3>
<p><strong>满射</strong>函数，是一个函数<mathjax>$f: X \to Y$</mathjax> ，对每个<mathjax>$y \in Y$</mathjax>存在_至少_一个<mathjax>$x \in X$</mathjax>,使<mathjax>$f(x) = y$</mathjax>.</p>
<p>A <strong>surjective</strong> function, also called "onto", is a function <mathjax>$f: X \to Y$</mathjax> where, for every <mathjax>$y \in Y$</mathjax> there exists <em>at least</em> one <mathjax>$x \in X$</mathjax> such that <mathjax>$f(x) = y$</mathjax>. That is, every <mathjax>$y$</mathjax> has at least one corresponding <mathjax>$x$</mathjax> value.</p>
<p>等价于:</p>
<p>This is equivalent to:</p>
<p><mathjax>$$ \text{range}(f) = Y $$</mathjax></p>
<h3>单射</h3>
<h3>Injective functions</h3>
<p><strong>单射</strong>函数，是一个函数<mathjax>$f: X \to Y$</mathjax>, 对每个<mathjax>$y \in Y$</mathjax>存在_至多_一个<mathjax>$x \in X$</mathjax>,使<mathjax>$f(x) = y$</mathjax>.</p>
<p>An <strong>injective</strong> function, also called "one-to-one", is a function <mathjax>$f: X \to Y$</mathjax> where, for every <mathjax>$y \in Y$</mathjax>, there exists <em>at most</em> one <mathjax>$x \in X$</mathjax> such that <mathjax>$f(x) = y$</mathjax>.</p>
<p>也就是说，不是全部 <mathjax>$y$</mathjax> 都必然具有对应的<mathjax>$X$</mathjax>, 但有对应的都只有一个<mathjax>$x$</mathjax>.</p>
<p>That is, not all <mathjax>$y$</mathjax> necessarily has a corresponding <mathjax>$x$</mathjax>, but those that do only have <em>one</em> corresponding <mathjax>$x$</mathjax>.</p>
<h3>满射与单射</h3>
<h3>Surjective &amp; injective functions</h3>
<p>一个函数可以同时是满射和单射，这只是意味着对每个<mathjax>$y \in Y$</mathjax>存在都有且只有一个<mathjax>$x \in X$</mathjax>,使<mathjax>$f(x) = y$</mathjax>.</p>
<p>A function can be both surjective and injective, which just means that for every <mathjax>$y \in Y$</mathjax> there exists exactly one <mathjax>$x \in X$</mathjax> such that <mathjax>$f(x) = y$</mathjax>, that is, every <mathjax>$y$</mathjax> has exactly one corresponding <mathjax>$x$</mathjax>.</p>
<p>如前所述，函数的逆函数就是满射和单射的！</p>
<p>As mentioned before, the inverse of a function is both surjective and injective!</p>
<h3>凸函数与非凸函数</h3>
<h3>Convex and non-convex functions</h3>
<blockquote>
<p>凸函数是一个连续函数，其域中每个间隔中点的值不超过这间隔两端的算术平均值。(<a href="http://mathworld.wolfram.com/ConvexFunction.html">Convex Function</a>.Weisstein, Eric W. Wolfram MathWorld</p>
<p>A convex function is a continuous function whose value at the midpoint of every interval in its domain does not exceed the arithmetic mean of its values at the ends of the interval. (<a href="http://mathworld.wolfram.com/ConvexFunction.html">Convex Function</a>. Weisstein, Eric W. Wolfram MathWorld)</p>
</blockquote>
<p>一个<strong>凸</strong>域是在该区域中任何两点都可以在不离开该区域情况下用直线连接。</p>
<p>A <strong>convex</strong> region is one in which any two points in the region can be joined by a straight line that does not leave the region.</p>
<p>这就是说，凸函数具有且只有一个最小值（这也是导数为0的唯一位置）。</p>
<p>Which is to say that a convex function has a minimum, and only one (and this is also the only position where the derivative is 0).</p>
<p>更正式地说，如果一个函数的二阶导数总是正值，那这个函数就是凸函数。一个函数也可以仅在范围<mathjax>$[a,b]$</mathjax>上为凸的,只要它的二阶导数在该范围内的任何地方都是正的。</p>
<p>More formally, a function is convex if the second derivative is positive everywhere. A function can be convex on a range <mathjax>$[a,b]$</mathjax> if its second derivative is positive everywhere in that range.</p>
<p>在更高的维度，这些导数不是标量，所以我们反而定义凸这个性质为如果_Hessian_ <mathjax>$H$</mathjax>（二阶导数的矩阵）是半正定（记为<mathjax>$H \succeq 0$</mathjax>）,这是严格的，如果凸HH是正定（记为<mathjax>$H \succ 0$</mathjax>）。更多细节请参考微积分部分。</p>
<p>In higher dimensions, these derivatives aren't scalar values, so we instead define convexity if the <em>Hessian</em> <mathjax>$H$</mathjax> (the matrix of second derivatives) is <em>positive semidefinite</em> (notated <mathjax>$H \succeq 0$</mathjax>). It is <em>strictly</em> convex if <mathjax>$H$</mathjax> is <em>positive definite</em> (notated <mathjax>$H \succ 0$</mathjax>). Refer to the Calculus section for more details on this.</p>
<figure><img alt="Convex and non-convex functions" src="../assets/convex_nonconvex.svg" /><figcaption>Convex and non-convex functions</figcaption>
</figure>
<h3>超越函数</h3>
<h3>Transcendental functions</h3>
<p>超越函数是那些非多项式函数,如:<mathjax>$\sin, \exp, \log, \text{etc}$</mathjax>.</p>
<p><strong>Transcendental</strong> functions are those that are not polynomial, e.g. <mathjax>$\sin, \exp, \log, \text{etc}$</mathjax>.</p>
<h3>对数函数</h3>
<h3>Logarithms</h3>
<p>对数函数会经常遇到, 它们有很多有用的特性, 例如可以把乘法转换为加法.</p>
<p>Logarithms are frequently encountered. They have many useful properties, such as turning multiplication into addition:</p>
<p><mathjax>$$
\log(xy) = \log(x) + \log(y)
$$</mathjax></p>
<p>在计算机运算中, 乘以非常小的数是个问题，因为会导致下溢错误。对数函数通常用于将这种乘法转换为加法，以避免下溢错误。</p>
<p>Multiplying many small numbers is problematic with computers, leading to underflow errors. Logarithms are commonly used to turn this kind of multiplication into addition and avoid underflow errors.</p>
<p>注意 <mathjax>$\log(x)$</mathjax>，在没有指定基底时，通常指自然对数，即 <mathjax>$\log_e(x)$</mathjax>，有时记为 <mathjax>$\ln(x)$</mathjax>），它的逆函数是<mathjax>$\exp(x)$</mathjax>,更多记为<mathjax>$e^x$</mathjax>。</p>
<p>Note that <mathjax>$\log(x)$</mathjax>, without any base, typically implies the natural log, i.e. <mathjax>$\log_e(x)$</mathjax>, sometimes notated <mathjax>$\ln(x)$</mathjax>, which has the inverse <mathjax>$\exp(x)$</mathjax>, more commonly seen as <mathjax>$e^x$</mathjax>.</p>
<h1>其他概念</h1>
<h1>Other useful concepts</h1>
<h2>解析法与数值法</h2>
<h2>Solving analytically vs numerically</h2>
<p>一般你会看到以<strong>解析方法</strong>(有时称为<strong>代数方法</strong>)与<strong>数值方法</strong>去解决问题有很大区别.</p>
<p>Often you may see a distinction made between solving a problem <strong>analytically</strong> (sometimes <strong>algebraeically</strong> is used) and solving a problem <strong>numerically</strong>.</p>
<p>以分析法解决问题意味着您可以利用对象和等式的属性，例如通过微积分中的方法，避免用数值替换您正在操作的变量（即，你只需要操作符号）。如果一个问题可以用解析法求解，那这个解被称为<strong>解析解</strong>（或*<em>分析</em>解）,它一个精确的解。</p>
<p>Solving a problem analytically means you can exploit properties of the objects and equations, e.g. through methods from calculus, avoiding substituting numerical values for the variables you are manipulating (that is, you only need to manipulate symbols). If a problem may be solved analytically, the resulting solution is called a <strong>closed form</strong> solution (or the <strong>analytic</strong> solution) and is an exact solution.</p>
<p>不是所有的问题都可以用解析法; 通常更复杂的数学模型没有闭型解。这些问题也常常是最有趣的。这样的问题需要近似的数值法，它通过对变量代入不同的数值许多次,来算出近似值。这个解称为<strong>近似</strong>（<strong>数值</strong>）解。</p>
<p>Not all problems can be solved analytically; generally more complex mathematical models have no closed form solution. These problems are also often the ones of most interest. Such problems need to be <em>approximated</em> numerically, which involves evaluating the equations many times by substituting different numerical values for variables. The result is an approximate (<strong>numerical</strong>) solution.</p>
<h2>线性模型与非线性模型</h2>
<h2>Linear vs nonlinear models</h2>
<p>你经常会看到类似的警告说，某算法只适用于线性模型。另一方面，一些模型也因为适用于非线性模型而受欢迎。</p>
<p>You'll often see a caveat with algorithms that they only work for linear models. On the other hand, some models are touted for their capacity for nonlinear models.</p>
<p>线性模型的一般形式为：</p>
<p>A <strong>linear model</strong> is a model which takes the general form:</p>
<p><mathjax>$$
y = \beta_0 + \beta_1 x_1 + \dots + \beta_n x_n
$$</mathjax></p>
<p>请注意，此函数不需要产生字面上的直线。“线性”约束不适用于预测变量<mathjax>$x_1, \dots, x_n$</mathjax>。例如，函数<mathjax>$y = x^2$</mathjax>是线性的。</p>
<p>Note that this function does not need to produce a literal line. The "linear" constraint does not apply to the predictor variables <mathjax>$x_1, \dots, x_n$</mathjax>. For instance, the function <mathjax>$y = x^2$</mathjax> is linear.</p>
<p>“线性”是指参数; 即函数必须是“在参数中线性”，意味着参数<mathjax>$\beta_0, \dots, \beta_n$</mathjax> 它们自己必须形成一条线（或者在任何维度空间中的等价物）。</p>
<p>"Linear" refers to the parameters; i.e. the function must be "linear in the parameters", meaning that the parameters <mathjax>$\beta_0, \dots, \beta_n$</mathjax> themselves must form a line (or its equivalent in whatever dimensional space you're working in).</p>
<p>一个<strong>非线性模型</strong>包括，带有如<mathjax>$\beta^2$</mathjax> 或<mathjax>$\beta_0 \beta_1$</mathjax>这样的参数（即，同时有多个参数,就是非线性的）或超越函数。</p>
<p>A <strong>nonlinear model</strong> includes parameters such as <mathjax>$\beta^2$</mathjax> or <mathjax>$\beta_0 \beta_1$</mathjax> (that is, multiple parameters in the same term, which is <em>not</em> linear) or transcendental functions.</p>
<h2>度量</h2>
<h2>Metrics</h2>
<p>许多人工智能和机器学习算法是基于或受益于某种度量。在本中，该术语有具体的定义。</p>
<p>Many artificial intelligence and machine learning algorithms are based on or benefit from some kind of <em>metric</em>. In this context the term has a concrete definition.</p>
<p>度量的典型例子是相似性。假设你有一堆随机变量<mathjax>$X_i$</mathjax> ,它接受标签空间<mathjax>$V$</mathjax>中的值 。如果<mathjax>$X_i$</mathjax> 和 <mathjax>$X_j$</mathjax> 通过边连接，我们要求它们的“相似”度。</p>
<p>The typical case for metrics is around similarity. Say you have a bunch of random variables <mathjax>$X_i$</mathjax> which take on values in a label space <mathjax>$V$</mathjax>. If <mathjax>$X_i$</mathjax> and <mathjax>$X_j$</mathjax> are connected by an edge, we want them to take on "similar" values.</p>
<p>我们如何定义“相似”？</p>
<p>How do we define "similar"?</p>
<p>我们将使用距离函数 <mathjax>$\mu: V \times V \to R^+$</mathjax>，满足：</p>
<p>We'll use a distance function <mathjax>$\mu: V \times V \to R^+$</mathjax>, which needs to satisfy:</p>
<ul>
<li><strong>自反性</strong>: 对所有<mathjax>$v$</mathjax>有<mathjax>$\mu(v,v)=0$</mathjax> </li>
<li><strong>对称性</strong>: 对所有<mathjax>$v_1, v_2$</mathjax> 有 <mathjax>$\mu(v_1,v_2)=\mu(v_2, v_1)$</mathjax></li>
<li>
<p><strong>三角不等性</strong>: 对所有<mathjax>$v_1, v_2, v_3$</mathjax>, 有 <mathjax>$\mu(v_1, v_2) \leq \mu(v_1, v_3) + \mu(v_3, v_2)$</mathjax>  </p>
</li>
<li>
<p><em>reflexivity</em>: <mathjax>$\mu(v,v)=0$</mathjax> for all <mathjax>$v$</mathjax></p>
</li>
<li><em>symmetry</em>: <mathjax>$\mu(v_1,v_2)=\mu(v_2, v_1)$</mathjax> for all <mathjax>$v_1, v_2$</mathjax></li>
<li><em>triangle inequality</em>: <mathjax>$\mu(v_1, v_2) \leq \mu(v_1, v_3) + \mu(v_3, v_2)$</mathjax> for all <mathjax>$v_1, v_2, v_3$</mathjax></li>
</ul>
<p>如果所有这些都得到满足，我们说 <mathjax>$\mu$</mathjax> 是一个度量。</p>
<p>If all these are satisfied, we say that <mathjax>$\mu$</mathjax> is a <strong>metric</strong>.</p>
<p>如果只自反性和对称性满足，我们用半度量代替。</p>
<p>If only reflexivity and symmetry are satisfied, we have a <strong>semi-metric</strong> instead.</p>
<p>因此，我们可以创建一个特性 <mathjax>$f_{ij}(X_i, X_j) = \mu(X_i, X_j)$</mathjax>, 然后这样工作，使：</p>
<p>So we can create a <em>feature</em> <mathjax>$f_{ij}(X_i, X_j) = \mu(X_i, X_j)$</mathjax> and then this works out such that:</p>
<p><mathjax>$$
\exp(- w_{ij} f_{ij} (X_i, X_j)), w_{ij} &gt; 0
$$</mathjax></p>
<p>距离（度量）越低，概率越高。</p>
<p>that the lower the distance (metric), the higher the probability.</p>
<h2>引用</h2>
<h2>References</h2>
<ul>
<li><a href="http://mathworld.wolfram.com/ConvexFunction.html">Convex Function</a>. Weisstein, Eric W. Wolfram MathWorld.</li>
</ul>
    
    <script src="http://cdn.bootcss.com/jquery/1.11.1/jquery.js"></script>
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>
    <script>
        $(document).ready(function() {
            $('pre').each(function(i, e) {hljs.highlightBlock(e)});
            MathJax.Hub.Config({
                tex2jax: {
                    inlineMath: [["$","$"]],
                    displayMath: [['$$','$$']],
                    processEscapes: true
                },
                "HTML-CSS": {
                    linebreaks: { automatic: true }
                }
            });
            MathJax.Hub.Startup.onload();
        });
    </script>
    <script src="http://ai-code.tech/ai_notes_html/js/custom.js"></script>


</body>
</html>
