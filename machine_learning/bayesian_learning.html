
<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1">

    <title>Bayesian Learning</title>

    <link rel="stylesheet" type="text/css" href="../style.css">
    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/color-brewer.min.css">
    <link rel="stylesheet" href="http://ai-code.tech/ai_notes_html/css/custom.css">
</head>

<body>

    <hr />
<p>prerequisites:<br />
- bayes nets</p>
<hr />
<p><mathjax>$$
\def\argmax{\operatorname*{argmax}}
\def\argmin{\operatorname*{argmin}}
$$</mathjax></p>
<h1>Bayesian Learning</h1>
<p><em>Bayesian machine learning</em> is a particular set of approaches to probabilistic machine learning (for other probabilistic models, see Supervised Learning).</p>
<p>Bayesian learning treats model parameters as random variables - in Bayesian learning, parameter estimation amounts to computing posterior distributions for these random variables based on the observed data.</p>
<p>Bayesian learning typically involves generative models - one notable exception is <strong>Bayesian linear regression</strong>, which is a discriminative model.</p>
<h2>Bayesian models</h2>
<p>Bayesian modeling treats those two problems as one.</p>
<p>We first have a prior distribution over our parameters (i.e. what are the likely parameters?) <mathjax>$P(\theta)$</mathjax>.</p>
<p>From this we compute a posterior distribution which combines both inference and learning:</p>
<p><mathjax>$$
P(y_1, \dots, y_n, \theta | x_1, \dots, x_n) = \frac{P(x_1, \dots, x_n, y_1, \dots, y_n | \theta)P(\theta)}{P(x_1, \dots, x_n)}
$$</mathjax></p>
<p>Then prediction is to compute the conditional distribution of the new data point given our observed data, which is the marginal of the latent variables and the parameters:</p>
<p><mathjax>$$
P(x_{n+1}|x_1, \dots, x_n) = \int P(x_{n+1}|\theta)P(\theta|x_1, \dots, x_n) d\theta
$$</mathjax></p>
<p>Classification then is to predict the distributions of the new datapoint given data from other classes, then finding the class which maximizes it:</p>
<p><mathjax>$$
P(x_{n+1}|x_1^c, \dots, x_n^c) = \int P(x_{n+1}|\theta^c)P(\theta^c|x_1^c, \dots, x_n^c) d\theta^c
$$</mathjax></p>
<h3>Hidden Markov Models</h3>
<p>HMMs can be thought of as clustering over time; that is, each state is a "cluster".</p>
<p>The data points and latent variables are sequences, and <mathjax>$\pi_k$</mathjax> becomes the transition probability given the state (cluster) <mathjax>$k$</mathjax>. <mathjax>$\theta^*_k$</mathjax> becomes the emission distribution for <mathjax>$x$</mathjax> given state <mathjax>$k$</mathjax>.</p>
<h3>Model-based clustering</h3>
<ul>
<li>model data from heterogeneous unknown sources</li>
<li><mathjax>$K$</mathjax> unknown sources (clusters)</li>
<li>each cluster/source is modeled using a parametric model (e.g. a Gaussian distribution)</li>
</ul>
<p>For a given data point <mathjax>$i$</mathjax>, we have:</p>
<p><mathjax>$$
z_i | \pi \sim \text{Discrete}(\pi)
$$</mathjax></p>
<p>Where <mathjax>$z_i$</mathjax> is the cluster label for which data point <mathjax>$i$</mathjax> belongs to. This is the latent variable we want to discover.</p>
<p><mathjax>$\pi$</mathjax> is the <em>mixing proportions</em> which is the vector of probabilities for each class <mathjax>$k$</mathjax>, that is:</p>
<p><mathjax>$$
\pi = (\pi_i, \dots, \pi_K) | \alpha \sim \text{Dirichlet}(\frac{\alpha}{K}, \dots, \frac{\alpha}{K})
$$</mathjax></p>
<p>That is, <mathjax>$\pi_k = P(z_i = k)$</mathjax>.</p>
<p>We also model each data point <mathjax>$x_i$</mathjax> as being drawn from a source (cluster) like so, where <mathjax>$F$</mathjax> is however we are modeling the cluster (e.g. a Gaussian), parameterized by <mathjax>$\theta^*_{z_i}$</mathjax>, that is some parameters for the <mathjax>$z_i$</mathjax>-labeled cluster:</p>
<p><mathjax>$$
x_i | z_i, \theta^*_k \sim F(\theta^*_{z_i})
$$</mathjax></p>
<p>(Note that the star, as in <mathjax>$\theta^*$</mathjax>, is used to denote the optimal solution for <mathjax>$\theta$</mathjax>.)</p>
<p>For this approach we have two priors over parameters of the model:</p>
<ul>
<li>For the mixing proportions, we typically use a Dirichlet prior (above) because it has the nice property of being a conjugate prior with multinomial distributions.</li>
<li>For each cluster <mathjax>$k$</mathjax> we use some prior <mathjax>$H$</mathjax>, that is <mathjax>$\theta^*_k | H \sim H$</mathjax>.</li>
</ul>
<p>Graphically, this is:</p>
<figure><img alt="Model-based clustering plate model" src="../assets/model_based_clustering.svg" /><figcaption>Model-based clustering plate model</figcaption>
</figure>
<h3>Naive Bayes</h3>
<p>The main assumption of Naive Bayes is that all features are independent effects of the label. This is a really strong simplifying assumption but nevertheless in many cases Naive Bayes performs well.</p>
<p>Naive Bayes is also <em>statistically efficient</em> which means that it doesn't need a whole lot of data to learn what it needs to learn.</p>
<p>If we were to draw it out as a Bayes' net:</p>
<p><mathjax>$$
\begin{aligned}
Y &amp;\to F_1 \\
Y &amp;\to F_2 \\
&amp;\dots \\
Y &amp;\to F_n
\end{aligned}
$$</mathjax></p>
<p>Where <mathjax>$Y$</mathjax> is the label and <mathjax>$F_1, F_2, \dots, F_n$</mathjax> are the features.</p>
<p>The model is simply:</p>
<p><mathjax>$$
P(Y|F_1, \dots, F_n) \varpropto P(Y) \prod_i P(F_i|Y)
$$</mathjax></p>
<p>This just comes from the Bayes' net described above.</p>
<p>The Naive Bayes learns <mathjax>$P(Y, f_1, f_2, \dots, f_n)$</mathjax> which we can normalize (divide by <mathjax>$P(f_1, \dots, f_n)$</mathjax>) to get the conditional probability <mathjax>$P(Y|f_1, \dots, f_n)$</mathjax>:</p>
<p><mathjax>$$
P(Y, f_1, \dots, f_n) =
\begin{matrix}
P(y_1, f_1, \dots, f_n) \\
P(y_2, f_1, \dots, f_n) \\
\vdots \\
P(y_k, f_1, \dots, f_n)
\end{matrix} =
\begin{matrix}
P(y_1) \prod_i P(f_i|y_1) \\
P(y_2) \prod_i P(f_i|y_2) \\
\vdots \\
P(y_k) \prod_i P(f_i|y_k)
\end{matrix}
$$</mathjax></p>
<p>So the parameters of Naive Bayes are <mathjax>$P(Y)$</mathjax> and <mathjax>$P(F_i|Y)$</mathjax> for each feature.</p>
<h2>Inference in Bayesian models</h2>
<h3>Maximum a posteriori (MAP) estimation</h3>
<p>A Bayesian alternative to MLE, we can estimate probabilities using <em>maximum a posteriori estimation</em>, where we instead choose a probability (a point estimate) that is most likely given the observed data:</p>
<p><mathjax>$$
\begin{aligned}
\tilde \pi_{MAP} &amp;= \argmax_{\pi}P(\pi|X) \\
&amp;= \argmax_{\pi} \frac{P(X|\pi)P(\pi)}{P(X)} \\
&amp;= \argmax_{\pi} P(X|\pi)P(\pi) \\
P(y|X) &amp;\approx P(y|\tilde \pi_{MAP})
\end{aligned}
$$</mathjax></p>
<p>So unlike MLE, MAP estimation uses Bayes' Rule so the estimate can use prior knowledge (<mathjax>$P(\pi)$</mathjax>) about what we expect <mathjax>$\pi$</mathjax> to be.</p>
<p>Again, this may be done with log-likelihoods:</p>
<p><mathjax>$$
\theta_{\text{MAP}} = \argmax_{\theta} p(\theta|x) = \argmax_{\theta} \log p(x|\theta) + \log p(\theta)
$$</mathjax></p>
<h2>Maximum A Posteriori (MAP)</h2>
<p>Likelihood function <mathjax>$L(\theta)$</mathjax> is the probability of the data <mathjax>$D$</mathjax> as a function of the parameters <mathjax>$\theta$</mathjax>.</p>
<p>This often has very small values so typically we work with the log-likelihood function instead:</p>
<p><mathjax>$$
\ell (\theta) = \log L(\theta)
$$</mathjax></p>
<p>The <em>maximum likelihood criterion</em> simply involves choosing the parameter <mathjax>$\theta$</mathjax> to maximize <mathjax>$\ell (\theta)$</mathjax>. This can (sometimes) be done analytically by computing the derivative and setting it to zero and yields the <em>maximum likelihood estimate</em>.</p>
<p>MLE's weakness is that if you have only a little training data, it can overfit. This problem is known as <em>data sparsity</em>. For example, you flip a coin twice and it happens to land on heads both times. Your maximum likelihood estimate for <mathjax>$\theta$</mathjax> (probability that the coin lands on heads) would be 1! We can then try to generalize this estimate to another dataset and test it by measuring the log-likelihood on the test set. If a tails shows up at all in the test set, we will have a test log-likelihood of <mathjax>$-\infty$</mathjax>.</p>
<p>We can instead use Bayesian techniques for parameter estimation. In Bayesian parameter estimation, we treat the parameters <mathjax>$\theta$</mathjax> as a random variable as well, so we learn a joint distribution <mathjax>$p(\theta, D)$</mathjax>.</p>
<p>We first require a prior distribution <mathjax>$p(\theta)$</mathjax> and the likelihood <mathjax>$p(D|\theta)$</mathjax> (as with maximum likelihood).</p>
<p>We want to compute <mathjax>$p(\theta|D)$</mathjax>, which is accomplished using Bayes' rule:</p>
<p><mathjax>$$
p(\theta|D) = \frac{p(\theta)p(D|\theta)}{\int p(\theta') p(D|\theta')d\theta'}
$$</mathjax></p>
<p>Though we work with only the numerator for as long as possible (i.e. we delay normalization until it's necessary):</p>
<p><mathjax>$$
p(\theta|D) \varpropto p(\theta)p(D|\theta)
$$</mathjax></p>
<p>The more data we observe, the less uncertainty there is around the parameter, and the likelihood term comes to dominate the prior - we say that the <em>data overwhelm the prior</em>.</p>
<p>We also have the <em>posterior predictive distribution</em> <mathjax>$p(D'|D)$</mathjax>, which is the distribution over future observables given past observations. This is computed by computing the posterior over <mathjax>$\theta$</mathjax> and then marginalizing out <mathjax>$\theta$</mathjax>:</p>
<p><mathjax>$$
p(D'|D) = \int p(\theta|D) p(D'|\theta) d\theta
$$</mathjax></p>
<p>The normalization step is often the most difficult, since we must compute an integral over potentially many, many parameters.</p>
<p>We can instead formulate Bayesian learning as an optimization problem, allowing us to avoid this integral. In particular, we can use <em>maximum a-posteriori</em> (MAP) approximation.</p>
<p>Whereas with the previous Bayesian approach (the "full Bayesian" approach) we learn a distribution over <mathjax>$\theta$</mathjax>, with MAP approximation we simply get a point estimate (that is, a single value rather than a full distribution). In particular, we get the parameters that are most likely under the posterior:</p>
<p><mathjax>$$
\begin{aligned}
\hat \theta_{\text{MAP}} &amp;= \argmax_{\theta} p(\theta|D) \\
&amp;= \argmax_{\theta} p(\theta,D) \\
&amp;= \argmax_{\theta} p(\theta)p(D|\theta) \\
&amp;= \argmax_{\theta} \log p(\theta) + \log p(D|\theta)
\end{aligned}
$$</mathjax></p>
<p>Maximizing <mathjax>$\log p(D|\theta)$</mathjax> is equivalent to MLE, but now we have an additional prior term <mathjax>$\log p(\theta)$</mathjax>. This prior term functions somewhat like a regularizer. In fact, if <mathjax>$p(\theta)$</mathjax> is a Gaussian distribution centered at 0, we have L2 regularization.</p>
<h3>Markov Chain Monte Carlo (MCMC)</h3>
<h4>Motivation</h4>
<p>With MLE and MAP estimation we get only a single value for <mathjax>$\pi$</mathjax>, and this collapsing into a single value loses information - what if we instead considered the entire distribution of values for <mathjax>$\pi$</mathjax>, i.e. <mathjax>$P(\pi|X)$</mathjax>?</p>
<p>As it stands, with MLE and MAP we only get an approximation of <mathjax>$P(y|X)$</mathjax>. But with the distribution <mathjax>$P(\pi|X)$</mathjax> we could directly compute its expected value:</p>
<p><mathjax>$$
E[P(y|X)] = \int P(y|\pi)P(\pi|X)d\pi
$$</mathjax></p>
<p>And with Bayes' Rule we have:</p>
<p><mathjax>$$
P(\pi|X) = \frac{P(X|\pi)P(\pi)}{P(X)} = \frac{P(X|\pi)P(\pi)}{\int_{\pi}P(X|\pi)P(\pi)d\pi}
$$</mathjax></p>
<p>So we have two integrals here, and unfortunately integrals can be hard (sometimes impossible) to compute.</p>
<p>With MCMC we can get the values we need without needing to calculating the integrals.</p>
<h4>Monte Carlo methods</h4>
<p>Monte Carlo methods are algorithms which perform probabilistic simulations to give you some value.</p>
<p>For example:</p>
<blockquote>
<p>Say you have a square and a circle inscribed within it, so that they are co-centric and the circle's diameter is equal to the length of a side of the square. You take some rice and uniformly scatter it in the shapes at random. You can count the total number of grains of rice in the circle (<mathjax>$C$</mathjax>) and do the same for rice in the square (<mathjax>$S$</mathjax>). The ratio <mathjax>$\frac{C}{S}$</mathjax> approximates the ratio of the area of the circle to the area of the square. The area of the circle and for the square can be thought of as integrals (adding an infinite number of infinitesimally small points), so what you have effectively done is approximate the value of integrals.</p>
</blockquote>
<h4>MCMC</h4>
<p>In the example the samples were uniformly distributed, but in practice they can be drawn from other distributions. If we collect enough samples from the distribution we can compute pretty much anything we would want to know about the distribution - mean, standard deviation, etc.</p>
<p>For example, we can compute the expected value:</p>
<p><mathjax>$$
E[f(z)] = \lim_{N \to \infty} \frac{1}{N} \sum^N_{t=1}f(z^{(t)})
$$</mathjax></p>
<p>Since we don't sample infinite points, we sample as many as we can for an approximation:</p>
<p><mathjax>$$
E[f(z)] \approx \frac{1}{T} \sum^T_{t=1}f(z^{(t)})
$$</mathjax></p>
<p>How exactly then is the sampling of <mathjax>$z^{(0)}, \dots, z^{(T)}$</mathjax> according to a given distribution accomplished?</p>
<p>We treat the sampling process as a walk around a sample space and the walk proceeds as a Markov chain; that is, the choice of the next sample depends on only the current state, based on a transition probability <mathjax>$P_{\text{trans}}(z^{(t+1)}|z^{(t)})$</mathjax>.</p>
<p>So the general walking algorithm is:</p>
<ul>
<li>Randomly initialize <mathjax>$z^{(0)}$</mathjax></li>
<li>for <mathjax>$t=1$</mathjax> to <mathjax>$T$</mathjax> do:<ul>
<li><mathjax>$z^{(t+1)} := g(z^{(t)})$</mathjax></li>
</ul>
</li>
</ul>
<p>Where <mathjax>$g$</mathjax> is just a function which returns the next sample based on <mathjax>$P_{\text{trans}}$</mathjax> and the current sample.</p>
<h4>Gibbs Sampling</h4>
<p><em>Gibbs sampling</em> is an MCMC algorithm, where <mathjax>$z$</mathjax> is a point/vector <mathjax>$[z_1, \dots, z_k]$</mathjax> and <mathjax>$k &gt; 1$</mathjax>. So here the samples are vectors of at least two terms. You don't select an entire sample at once, what you do is make a separate probabilistic choice for each dimension, where the choice is dependent on the other <mathjax>$k-1$</mathjax> dimensions, using the <em>newest</em> values for each.</p>
<p>For example, say <mathjax>$k=3$</mathjax> so you have vectors in the form <mathjax>$[z_1, z_2, z_3]$</mathjax>.</p>
<ul>
<li>First you pick a new value <mathjax>$z_1^{(t+1)}$</mathjax> based on <mathjax>$z_2^{(t)}$</mathjax> and <mathjax>$z_3^{(t)}$</mathjax>.</li>
<li>Then you pick a new value <mathjax>$z_2^{(t+1)}$</mathjax> based on <mathjax>$z_1^{(t+1)}$</mathjax> and <mathjax>$z_3^{(t)}$</mathjax>.</li>
<li>Then you pick a new value <mathjax>$z_3^{(t+1)}$</mathjax> based on <mathjax>$z_1^{(t+1)}$</mathjax> and <mathjax>$z_2^{(t+1)}$</mathjax>.</li>
</ul>
<h5>Gibbs Sampling (more)</h5>
<p>Now that we have the generative model, we can use it to calculate the probability of some set of group assignments for our data points. But how do we learn what a good set of group assignments is?</p>
<p>We can use Gibbs Sampling, that is:</p>
<ul>
<li>Take the set of data points, and randomly initialize group assignments.</li>
<li>Pick a point. Fix the group assignments of all the other points, and assign the chosen point a new group (which can be either an existing cluster or a new cluster) with a CRP-ish probability (as described in the models above) that depends on the group assignments and values of all the other points.</li>
<li>We will eventually converge on a good set of group assignments, so repeat the previous step until happy.</li>
</ul>
<h2>Nonparametric models</h2>
<p>First: a parametric model is one in which the capacity is fixed and does not increase with the amount of training data. For example, a linear classifier, a neural network with fixed number of hidden units, etc. The amount of parameters is finite, and the particular amount is determined before any data is observed (e.g. with linear regression, <em>we</em> decide the number of parameters that will be used, rather than learning it from the data).</p>
<p>Another way of thinking of it is: a parametric model tries to come up with some function from the data, then the data is thrown out. You use that learned function in place of the data for future predictions.</p>
<p>A nonparametric model doesn't throw out the data, it keeps it around for later predictions; as a result, as more data becomes available, you don't need to create an updated model like you would with the parametric approach.</p>
<h3>What is a nonparametric model?</h3>
<ul>
<li>counterintuitively, it does not mean a model without parameters. Rather, it means a model with a very large number of parameters (e.g. infinite). Here, "nonparametric" refers more to "not a parametric model", <em>not</em> "without parameters".</li>
<li>could also be defined as a parametric model where the number of parameters increases with the data, instead of fixing the number of parameters (that is, the number of things we can learn) as is the case with parametric models. I.e. the capacity of the model increases with the amount of training data.</li>
<li>can also be defined as a family of distributions that is dense in some large space relevant to the problem at hand.<ul>
<li>For example, with a regression problem, the space of possible solutions may be all continuous functions, which is infinite-dimensional (if you have infinite cardinality). A nonparametric model can span this infinite space.</li>
</ul>
</li>
</ul>
<p>To expand and visualize the last point, consider the regression problem example.</p>
<figure><img alt="Space of continuous functions" src="../assets/nonparametric_01.svg" /><figcaption>Space of continuous functions</figcaption>
</figure>
<p>This is the space of continuous functions, where <mathjax>$f^*$</mathjax> is the function we are looking for.</p>
<figure><img alt="Space of continuous functions w/ parametric model" src="../assets/nonparametric_02.svg" /><figcaption>Space of continuous functions w/ parametric model</figcaption>
</figure>
<p>With a parametric model, we have a finite number of parameters, so we can only cover a fraction of this space (the square).</p>
<figure><img alt="Space of continuous functions w/ nonparametric model" src="../assets/nonparametric_03.svg" /><figcaption>Space of continuous functions w/ nonparametric model</figcaption>
</figure>
<p>However, with a nonparametric model, we can have infinite parameters and cover the entire space. We apply some assumptions, e.g. favoring simpler functions over complex ones, so we can apply a prior to the space which assigns more mass to simpler functions (the darker parts in the accompanying figure). But every part of the space still has some mass.</p>
<p>It is possible to create a nonparametric model by nesting a parametric learning algorithm inside another parametric learning algorithm. The outer learning algorithm learns the number of parameters, whereas the inner learning algorithm performs as it normally would (learning the parameters themselves).</p>
<h3>An example</h3>
<p>An example of a nonparametric model is <strong>nearest neighbor regression</strong>, in which we simply store the training set, then, for a given new point, identify the closest point and return its associated target value.</p>
<p>That is:</p>
<p><mathjax>$$
\begin{aligned}
\hat y &amp;= y_i \\
i &amp;= \argmin ||X_i-x||^2_2
\end{aligned}
$$</mathjax></p>
<p>Another example is wrapping a parametric algorithm instead another parametric algorithm - where the number of parameters of the inner algorithm is a parameter that the outer parametric algorithm learns.</p>
<h3>Parametric models vs nonparametric models</h3>
<p>Parametric models are relatively rigid; once you choose a model, there are some limitations to what forms that model can take (i.e. how it can fit to the data), and the only real flexibility is in the parameters which can be adjusted. For instance, with linear regression, the model must take the form of <mathjax>$y = \beta_0 + \beta_1 x_1 + \dots + \beta_n x_n$</mathjax>; you can only adjust the <mathjax>$\beta_i$</mathjax> values. If the "true" model does not take this form, we probably won't be able to estimate it well because the model we chose fundamentally does not conform to it.</p>
<p>Parametric models, on the other hand, offer greater freedom of fit.</p>
<p>As an example, a histogram can be considered a nonparametric representation of a probability density - it "let's the data speak for itself", so to speak (you may hear nonparametric models described in this way). The density that forms in the histogram is determined directly by the data. You don't make any assumptions about what the distribution is beforehand - e.g. you don't have to say, "I think this might be a normal distribution", and then try to force the normal probability density function onto the data.</p>
<p>Nonparametric models don't actually mean there are no parameters, but it is perhaps better described as not having a fixed set of parameters.</p>
<h3>Why use a Bayesian nonparametric approach?</h3>
<ol>
<li>Model selection<ul>
<li>e.g. clustering - you have to specify the number of clusters. Too many and you overfit, too few and you underfit.</li>
<li>with a Bayesian approach you are not doing any optimizing (such as finding a maximum likelihood), you are just computing a posterior distribution. So there is no "fitting" happening, so you cannot overfit.</li>
<li>If you have a large model or one which grows with the amount of data, you can avoid underfitting too.</li>
</ul>
</li>
<li>
<p>(of course, you can still specify an incorrect model and get poor performance)</p>
</li>
<li>
<p>Useful properties of Bayesian nonparametric models</p>
<ul>
<li><em>Exchangeability</em> - you can permute your data without affecting learning (i.e. order of your data doesn't matter)</li>
<li>Can model Zipf, Heap, and other power laws</li>
<li>Flexible ways of building complex models from simpler parts</li>
</ul>
</li>
</ol>
<p>Nonparametric models still make modeling assumptions, they are just less constrained than most parametric models.</p>
<p>There are also <em>semiparametric</em> models in which they are nonparametric in some ways and parametric in others.</p>
<h2>The Dirichlet Process</h2>
<p>The Dirichlet process is "the cornerstone of Bayesian nonparametrics".</p>
<p>It is a stochastic process - a model over an infinite collection of random variables.</p>
<p>There are a few ways to think about Dirichlet processes:</p>
<ul>
<li>the infinite limit of a Gibbs sampler for finite mixture models</li>
<li>the Chinese Restaurant Process</li>
<li>The stick-breaking construction</li>
</ul>
<h3>Dirichlet Distribution</h3>
<p>The Dirichlet distribution is a probability distribution over all possible multinomial distributions.</p>
<p>For example, say we have some data which we want to classify into three classes <mathjax>$A, B, C$</mathjax>. Maybe the data has 0.25 probability of being in class <mathjax>$A$</mathjax>, 0.5 probability of being in <mathjax>$B$</mathjax>, and 0.25 of being in <mathjax>$C$</mathjax>. Or maybe it has 0.1 probability of being in class <mathjax>$A$</mathjax>, then 0.6 and 0.3 for <mathjax>$B$</mathjax> and <mathjax>$C$</mathjax> respectively. Or it could be another distribution - we don't know. The Dirichlet distribution is the probability distribution representing these possible multinomial distributions across our classes.</p>
<p>The Dirichlet distribution is formalized as:</p>
<p><mathjax>$$
P(p|a) = \frac{\Gamma(\sum^{K-1}_{k=0}\alpha_k)}{\prod^{K-1}_{k=0}\Gamma(\alpha_k)}\prod^{K-1}_{k=0}p_k^{a_k-1}
$$</mathjax></p>
<p>where:</p>
<ul>
<li><mathjax>$p$</mathjax> = a multinomial distribution</li>
<li><mathjax>$\alpha$</mathjax> = the parameters of the dirichlet (a <mathjax>$K$</mathjax>-dimensional vector)</li>
<li><mathjax>$K$</mathjax> = the number of categories</li>
</ul>
<p>Note that this term:</p>
<p><mathjax>$$
\frac{\Gamma(\sum^{K-1}_{k=0}\alpha_k)}{\prod^{K-1}_{k=0}\Gamma(\alpha_k)}
$$</mathjax></p>
<p>Is just a normalizing constant so that we get a distribution. So if you're just comparing ratios of these distributions you can ignore it.</p>
<p>You begin with some prior which can be derived from other data or from domain knowledge or intuition.</p>
<p>As more data comes in, we update the dirichlet (i.e. with Bayesian updates):</p>
<p><mathjax>$$
P(p|\text{data}) = \frac{P(\text{data}|p)P(p|\alpha)}{P(p)}
$$</mathjax></p>
<p>This can be done simply as updating the column in <mathjax>$\alpha$</mathjax> which corresponds to a new data point, e.g. if we have three classes and <mathjax>$\alpha = [2,4,1]$</mathjax> and we encounter a new data point which belongs to the class <mathjax>$\alpha_1$</mathjax>, we just add one to that column in <mathjax>$\alpha$</mathjax>, so it becomes <mathjax>$[2,5,1]$</mathjax>.</p>
<h4>Entropy</h4>
<p>Also known as <em>information content</em>, <em>energy</em>, <em>log likelihood</em>, or <mathjax>$-\ln(p)$</mathjax></p>
<p>It can be thought of as the amount of "surprise" for an event.</p>
<p>If an event is totally certain, it has zero entropy.</p>
<p>A coin flip as some entropy since there are only two equally-probable possibilities.</p>
<p>If you have a pair of dice, there is some entropy for rolling a 6 (because there are multiple combinations which can lead to 6) but much higher entropy for rolling a 12 (because there is only one combination which leads to a 12).</p>
<p>We can look at the entropy of the Dirichlet function:</p>
<p><mathjax>$$
\begin{aligned}
E(p|\alpha) &amp;= -\ln(\prod^{K-1}_{k_0} p_k^{\alpha_k - 1}) \\
&amp;= \sum^{K-1}_{k_0}(\alpha_k - 1)(-\ln(p_k))
\end{aligned}
$$</mathjax></p>
<p>We'll break out the entropy of a given multinomial distribution <mathjax>$p$</mathjax> into its own term:</p>
<p><mathjax>$$
e_k = -\ln(p_k)
$$</mathjax></p>
<h4>Interpreting <mathjax>$\alpha$</mathjax></h4>
<p>We can take the <mathjax>$\alpha$</mathjax> vector and normalize it. The normalized <mathjax>$\alpha$</mathjax> vector is the expected value of the dirichlet, that is, it is its mean.</p>
<p>The sum of the unnormalized <mathjax>$\alpha$</mathjax> vector is the weight of the distribution, which can be thought of as its precision. In a normal distribution, the precision is <mathjax>$\frac{1}{\text{variance}}$</mathjax>; a higher precision means a narrower normal distribution which means that values are likely to be near the mean. A lower precision means a wider distribution in which points are less likely to be near the mean.</p>
<p>So a dirichlet with a higher weight means that the multinomial distribution is more likely to be close to the expected value.</p>
<p>Dirichlet distributions can be thought of as a <em>simplex</em>, which is a generalization of a triangle in some arbitrary dimensions (e.g. in 2D it is 2-simplex, a triangle, in 3D it is 3-simplex, a pyramid, etc.). Some examples are blow with their corresponding <mathjax>$\alpha$</mathjax> vectors:</p>
<figure><img alt="Some Dirichlet simplexes with their $\alpha$ vectors" src="../assets/dirichlet_simplexes.png" /><figcaption>Some Dirichlet simplexes with their <mathjax>$\alpha$</mathjax> vectors</figcaption>
</figure>
<h3>Finite Mixture Models</h3>
<p>This is a continuation of the model-based clustering approach mentioned earlier.</p>
<p>We want to learn, via inference, values for <mathjax>$\pi$</mathjax>, <mathjax>$z_i$</mathjax>, and <mathjax>$\theta^*_k$</mathjax>.</p>
<p>We can use a form of MCMC sampling - Gibbs sampling.</p>
<p>(to do: this is incomplete)</p>
<h3>Chinese Restaurant Process</h3>
<h4>Partitions</h4>
<p>Given a set <mathjax>$S$</mathjax>, a partition <mathjax>$\varrho$</mathjax> is a disjoint family of non-empty subsets (clusters) of <mathjax>$S$</mathjax> whose union is <mathjax>$S$</mathjax>. So a partition is some configuration of clusters which encompasses the members of <mathjax>$S$</mathjax>.</p>
<p>E.g.</p>
<p><mathjax>$$
\begin{aligned}
S &amp;= \{A,B,C,D,E,F\} \\
\varrho &amp;= \{\{A,D\}, \{B,C,E\}, \{F\}\}
\end{aligned}
$$</mathjax></p>
<p>The set of all partitions of <mathjax>$S$</mathjax> is denoted <mathjax>$\mathcal P_S$</mathjax>.</p>
<p><em>Random partitions</em> are random variables taking value in <mathjax>$\mathcal P_S$</mathjax>.</p>
<h4>The Chinese Restaurant Process (CRP)</h4>
<p>The CRP is an example of random partitions and involves a sequence of customers coming into a restaurant. Each customer decides whether or not to sit at a new (empty) table or join a table with other customers. The customers are sociable so prefer to join tables with more customers, but there is still some probability that they will sit at a new table:</p>
<p><mathjax>$$
\begin{aligned}
P(\text{sit at new table}) &amp;= \frac{\alpha}{\alpha + \sum_{c \in \varrho} n_c} \\
P(\text{sit at table $c$}) &amp;= \frac{n_c}{\alpha + \sum_{c \in \varrho} n_c}
\end{aligned}
$$</mathjax></p>
<p>Where <mathjax>$n_c$</mathjax> is the number of customers at a table <mathjax>$c$</mathjax> and <mathjax>$\alpha$</mathjax> is a parameter.</p>
<p>Here the customers correspond to members of the set <mathjax>$S$</mathjax>, and tables are the clusters in a partition <mathjax>$\varrho$</mathjax> of <mathjax>$S$</mathjax>.</p>
<p>This process has a <em>rich-get-richer</em> property, in that large clusters are more likely to attract more customers, thus growing larger, and so on.</p>
<p>If you multiply all the conditional probabilities together, the overall probability of the partition <mathjax>$\varrho$</mathjax>, called the <em>exchangeable partition probability function</em> (EPPF), is:</p>
<p><mathjax>$$
P(\varrho|\alpha) = \frac{\alpha^{|\varrho|}\Gamma(\alpha)}{\Gamma(n + \alpha)} \prod_{c \in \varrho} \Gamma(|c|)
$$</mathjax></p>
<p>This probability ends up not depending on the sequence in which customers arrive - so this is an <em>exchangeable random partition</em>.</p>
<p>The <mathjax>$\alpha$</mathjax> parameter affects the number of clusters in the partition - the larger the <mathjax>$\alpha$</mathjax>, the more clusters we expect to see.</p>
<h4>Model-based Clustering with the Chinese Restaurant Process</h4>
<p>Given a dataset <mathjax>$S$</mathjax>, we want to partition it into clusters of similar items.</p>
<p>Each cluster <mathjax>$c \in \varrho$</mathjax> is described by a model <mathjax>$F(\theta^*_c)$</mathjax>, for example a Gaussian, parameterized by <mathjax>$\theta^*_c$</mathjax>.</p>
<p>We model each item in each cluster as drawn from that cluster's model.</p>
<p>We are going to use a Bayesian approach, so we introduce a prior over <mathjax>$\varrho$</mathjax> and <mathjax>$\theta^*_c$</mathjax> and the compute posteriors over both. We use a CRP mixture model; that is we use a Chinese Restaurant Process for the prior over <mathjax>$\varrho$</mathjax> and an independent and identically distributed (iid) prior <mathjax>$H$</mathjax> over the cluster parameters <mathjax>$\theta^*_c$</mathjax>.</p>
<p>So the CRP mixture model in more detail:</p>
<ul>
<li><mathjax>$\varrho \sim CRP(\alpha)$</mathjax></li>
<li><mathjax>$\theta^*_c | \varrho \sim H \text{ for } c \in \varrho$</mathjax></li>
<li><mathjax>$x_i|\theta^*_c,\varrho \sim F(\theta^*_c) \text{ for } c \in \varrho \text{ with } i \in c$</mathjax></li>
</ul>
<h2>Infinite Mixture Models and the Dirichlet Process</h2>
<p>(this is basically a paraphrasing of <a href="http://blog.echen.me/2012/03/20/infinite-mixture-models-with-nonparametric-bayes-and-the-dirichlet-process/">this post by Edwin Chen</a>.)</p>
<p>Many clustering methods require the specification of a fixed number of clusters. However, in real-world problems there may be an infinite number of possible clusters - in the case of food there may be Italian or Chinese or fast-food or vegetarian food and so on. Nonparametric Bayesian methods allow parameters to change with the data; e.g. as we get more data we can let the number of clusters grow.</p>
<p>Say we have some data, where each data point is some vector.</p>
<p>We can view our data from a generative perspective: we can assume that the true clusters in the data are each defined by some model with some parameters, such as Gaussians with <mathjax>$\mu_i$</mathjax> and <mathjax>$\sigma_i$</mathjax> parameters. We further assume that these parameters themselves come from a distribution <mathjax>$G_0$</mathjax> Then we assume the data is generated by selecting a cluster, then taking a sample from that cluster.</p>
<p>Ok, how then do we assign the data points to groups?</p>
<h3>Chinese Restaurant Process</h3>
<p>(see explanation above)</p>
<p>(As a side note, the Indian Buffet Process is an extension of the CRP in which customers can sample food from multiple tables, that is, they can belong to multiple clusters.)</p>
<p>More formally:</p>
<ul>
<li>Generate table assignments <mathjax>$g_1, \dots, g_2 \sim CRP(\alpha)$</mathjax>, that is, according to a Chinese Restaurant Process. <mathjax>$g_i$</mathjax> is the table assigned to datapoint <mathjax>$i$</mathjax>.</li>
<li>We generate table parameters <mathjax>$\phi_1, \dots, \phi_m \sim G_0$</mathjax> according to the base distribution <mathjax>$G_0$</mathjax>, where <mathjax>$\phi_k$</mathjax> is the parameter for the <mathjax>$k$</mathjax>th distinct group.</li>
<li>Given the table assignments and table parameters, generate each datapoint <mathjax>$p_i \sim F(\phi_{g_i})$</mathjax> from a distribution <mathjax>$F$</mathjax> with the specified table parameters. For example, <mathjax>$F$</mathjax> could be a Gaussian and <mathjax>$phi_i$</mathjax> might be a vector specifying the mean and standard deviation.</li>
</ul>
<h3>Polya Urn Model</h3>
<p>Basically the same as the Chinese Restaurant Process, except that while the CRP specifies a distribution over partitions (see above), the Polya Urn model does that and also assigns parameters to each group.</p>
<p>Say we have an urn containing <mathjax>$\alpha G_0(x)$</mathjax> balls of some color <mathjax>$x$</mathjax> for each possible value of <mathjax>$x$</mathjax>. <mathjax>$G_0$</mathjax> is our base distribution and <mathjax>$G_0(x)$</mathjax> is the probability of sampling <mathjax>$x$</mathjax> from <mathjax>$G_0$</mathjax>.</p>
<p>Then we iteratively pick a ball at random from the urn, place it back and also place an additional new ball of the same color of the one we drew.</p>
<p>As <mathjax>$\alpha$</mathjax> increases (that is, we draw more new ball colors from the base distribution, which is the same as placing more weight on our prior), the colors in the urn tend towards the base distribution.</p>
<p>More formally:</p>
<ul>
<li>Generate colors <mathjax>$\phi_1, \dots, \phi_n \sim Polya(G_0, \alpha)$</mathjax>, that is, according to a Polya Urn Model. <mathjax>$\phi_i$</mathjax> is the color of the <mathjax>$i$</mathjax>th ball.</li>
<li>Given the ball colors, generate each datapoint <mathjax>$p_i \sim F(\phi_i)$</mathjax> (where we are using <mathjax>$F$</mathjax> is a way like in the Chinese Restaurant Process above).</li>
</ul>
<h3>Stick-Breaking Process</h3>
<p>The stick-breaking process is also very similar to the CRP and the Polya Urn model.</p>
<p>We start with a "stick" of length one, then generate a random variable <mathjax>$\beta_1 \sim Beta(1, \alpha)$</mathjax>. Since we're drawing from the Beta distribution, <mathjax>$\beta_1$</mathjax> will be a real number between 0 and 1 with the expected value <mathjax>$\frac{1}{1 + \alpha}$</mathjax>.</p>
<p>Then break off the stick at <mathjax>$\beta_1$</mathjax>. We define <mathjax>$w_1$</mathjax> to be the length of the left stick.</p>
<p>Then we take the right piece (the one we broke off) and generate <mathjax>$\beta_1 \sim Beta(1, \alpha)$</mathjax>.</p>
<p>Then break off the stick at <mathjax>$\beta_2$</mathjax>, set <mathjax>$w_2$</mathjax> to be the length of the stick to the right, and so on.</p>
<p>Here <mathjax>$\alpha$</mathjax> again functions as a dispersion parameter; when it is low there are few, denser clusters, when it is high, there are more clusters.</p>
<p>More formally:</p>
<ul>
<li>Generate group probabilities (stick lengths) <mathjax>$w_1, \dots, w_{\infty} \sim Stick(\alpha)$</mathjax>, that is, according to a Stick-Breaking process.</li>
<li>Generate group parameters <mathjax>$\phi_1, \dots, \phi_{\infty} \sim G_0$</mathjax>, where <mathjax>$\phi_k$</mathjax> is the parameter for the <mathjax>$k$</mathjax>th distinct group.</li>
<li>Generate group assignments <mathjax>$g_1, \dots, g_n \sim Multinomial(w_1, \dots, w_{\infty})$</mathjax> for each datapoint.</li>
<li>Given group assignments and group parameters, generate each datapoint <mathjax>$p_i \sim F(\phi_{g_i})$</mathjax> (where we are using <mathjax>$F$</mathjax> is a way like in the Chinese Restaurant Process above).</li>
</ul>
<h3>Dirichlet Process</h3>
<p>The CRP, Polya Urn Model, and Stick-Breaking Process are all connected to the Dirichlet Process.</p>
<p>Suppose we have a Dirichlet process <mathjax>$DP(G_0, \alpha)$</mathjax> where <mathjax>$G_0$</mathjax> is the base distribution and <mathjax>$\alpha$</mathjax> is the dispersion parameter. Say we want to sample <mathjax>$x_i \sim G$</mathjax>, where <mathjax>$G$</mathjax> is a distribution sampled from our Dirichlet Process, <mathjax>$G \sim DP(G_0, \alpha)$</mathjax>.</p>
<p>We could generate these <mathjax>$x_i$</mathjax> values by taking a Polya Urn Model with color distribution <mathjax>$G_0$</mathjax> and dispersion <mathjax>$\alpha$</mathjax> - then <mathjax>$x_i$</mathjax> could be the color of the <mathjax>$i$</mathjax>th ball in the urn.</p>
<p>Or we could generate these <mathjax>$x_i$</mathjax> by assigning customers to tables via a CRP with dispersion <mathjax>$\alpha$</mathjax>. Then all the customers for a table is given the same value (e.g. color) sampled from <mathjax>$G_0$</mathjax>. <mathjax>$x_i$</mathjax> is the value/color given to the <mathjax>$i$</mathjax>th customer; here <mathjax>$x_i$</mathjax> can be thought of as the parameters for table <mathjax>$i$</mathjax>.</p>
<p>Or we could generate weights <mathjax>$w_k$</mathjax> via a Stick-Breaking Process with dispersion <mathjax>$\alpha$</mathjax>. Then we give each weight <mathjax>$w_k$</mathjax> a value/color <mathjax>$v_k$</mathjax> sampled from <mathjax>$G_0$</mathjax>. We assign <mathjax>$x_i$</mathjax> to <mathjax>$v_k$</mathjax> with probability <mathjax>$w_k$</mathjax>.</p>
<p>More formally:</p>
<ul>
<li>Generate a distribution <mathjax>$G \sim DP(G_0, \alpha)$</mathjax> from a Dirichlet process with base distribution <mathjax>$G_0$</mathjax> and a dispersion parameter <mathjax>$\alpha$</mathjax>.</li>
<li>Generate group-level parameters <mathjax>$x_i \sim G$</mathjax> where <mathjax>$x_i$</mathjax> is the group parameter for the <mathjax>$i$</mathjax>th datapoint. Note that <mathjax>$x_i$</mathjax> is not the same as <mathjax>$\phi_i$</mathjax>; <mathjax>$x_i$</mathjax> is the parameter associated to the group that the <mathjax>$i$</mathjax>th data point belongs to whereas <mathjax>$\phi_k$</mathjax> is the parameter of the <mathjax>$k$</mathjax>th distinct group.</li>
<li>Given group-level parameters <mathjax>$x_i$</mathjax>, generate each datapoint <mathjax>$p_i \sim F(x_i)$</mathjax> (where we are using <mathjax>$F$</mathjax> is a way like in the Chinese Restaurant Process above).</li>
</ul>
<h2>Model selection</h2>
<h3>Model fitting vs Model selection</h3>
<p><em>Model fitting</em> is just about fitting a particular model to data, e.g. minimizing error against it. Say we use high-degree polynomial as our model (i.e. use more than one predictor variable). The resulting fit model might not actually be appropriate for the data - it may overfit it, for instance, or be overly complex.</p>
<p>Now way we fit a straight line (i.e. use just one predictor variable). We might find that the straight line is a better model for the data. The process of choosing a between these models is called <em>model selection</em>.</p>
<p>So we need some way of quantifying the quality of models in order to compare them.</p>
<p>A naive approach is to use the likelihood (the product of the probabilities of each datapoint), or more commonly, the log-likelihood (the sum of the log probabilities of each datapoint) and then select the model with the greatest likelihood (this is the maximum likelihood approach). This method is problematic, however, because more complicated (higher-degree) polynomial models will always have a higher likelihood, though they are not necessarily better in the sense that we mean (they overfit the data).</p>
<figure><img alt="More complex model, greater data likelihood source" src="../assets/degree_likelihood.png" /><figcaption>More complex model, greater data likelihood <a href="https://jakevdp.github.io/blog/2015/08/07/frequentism-and-bayesianism-5-model-selection/">source</a></figcaption>
</figure>
<h3>Model fitting</h3>
<p>Say you have datapoints <mathjax>$x_1, \dots, x_n$</mathjax> and errors for those datapoints <mathjax>$e_1, \dots, e_n$</mathjax>. Say there is some true value for <mathjax>$x$</mathjax>, we'll call it <mathjax>$x_\text{true}$</mathjax>, that we want to learn.</p>
<p>A frequentist approach assumes this true value is fixed and that the data is random. So in this case, we consider the distribution <mathjax>$P(x_i, e_i|x_\text{true})$</mathjax> and want to identify a point estimate - that is, a single value - for <mathjax>$x_\text{true}$</mathjax>. This distribution tells us the probability of a point <mathjax>$x_i$</mathjax> with its error <mathjax>$e_i$</mathjax>.</p>
<p>For instance, if we assume that <mathjax>$x$</mathjax> is normally distributed:</p>
<p><mathjax>$$
P(x_i, e_i|x_\text{true}) = \frac{1}{\sqrt{2\pi e_i^2}}\exp(\frac{-(x_i - x_\text{true})^2}{2 e_i^2})
$$</mathjax></p>
<p>Then we can consider the likelihood of the data overall by taking the product of the probabilities of each individual datapoint:</p>
<p><mathjax>$$
\mathcal{L}(X, E) = \prod^n_{i=1}P(x_i, e_i|x_\text{true})
$$</mathjax></p>
<p>Though typically we work with the log likelihood to avoid underflow errors:</p>
<p><mathjax>$$
\log \mathcal{L}(X, E) = \frac{1}{2} \sum^n_{i=1} (\log(2 \pi e_i^2) + \frac{(x_i - x_\text{true})^2}{e_i^2})
$$</mathjax></p>
<p>A common frequentist approach to fitting a model is to use maximum likelihood. That is, find an estimate for <mathjax>$x_\text{true}$</mathjax> which maximizes this log likelihood:</p>
<p><mathjax>$$
\argmax_{x_\text{true}} \log \mathcal{L}
$$</mathjax></p>
<p>Equivalently, we could minimize the loss (e.g. the squared error).</p>
<p>For simple cases, we can compute the maximum likelihood estimate analytically, by solving <mathjax>$\frac{d \log \mathcal{L}}{d x_\text{true}} = 0$</mathjax></p>
<p>When all the errors <mathjax>$e_i$</mathjax> are equal, this ends up reducing to:</p>
<p><mathjax>$$
x_\text{true} = \frac{1}{n} \sum^n_{i=1} x_i
$$</mathjax></p>
<p>That is, the mean of the datapoints.</p>
<p>For more complex situations, we instead use numerical optimization (i.e. we approximate the estimate).</p>
<p>The Bayesian approach instead involves looking at <mathjax>$P(x_\text{true}|x_i, e_i)$</mathjax>, that is, we look at a probability distribution for the unknown value based on fixed data. We aren't looking for a point estimate (a single value) any more, but rather describe <mathjax>$x_\text{true}$</mathjax> as a probability distribution. If we do want a point estimate (often you have to have a concrete value to work with), we can take the expected value from the distribution.</p>
<p><mathjax>$P(x_\text{true}|x_i, e_i)$</mathjax> is computed:</p>
<p><mathjax>$$
P(x_\text{true}|x_i, e_i) = \frac{P(x_i, e_i|x_\text{true})P(x_\text{true})}{P(x_i, e_i)}
$$</mathjax></p>
<p>Which is to say, it is the posterior distribution. For simple cases, the posterior can be computed analytically, but more often you will need Markov Chain Monte Carlo to approximate it.</p>
<h3>Model Selection</h3>
<p>Just as model fitting differs between frequentist and Bayesian approaches, so does model selection.</p>
<p>Frequentists compare <em>model likelihood</em>, e.g., for two models <mathjax>$M_1, M_2$</mathjax>, they would compare <mathjax>$P(D|M_1), P(D|M_2)$</mathjax>.</p>
<p>Bayesians compare the <em>model posterior</em>, e.g. <mathjax>$P(M_1|D), P(M_2|D)$</mathjax>.</p>
<p>The parameters are left out in both cases here since we aren't concerned with how good the fit of the model is, but rather, how appropriate the model itself is as a "type" of model.</p>
<p>We can use Bayes theorem to turn the posterior into something we can compute:</p>
<p><mathjax>$$
P(M~|~D) = P(D~|~M)\frac{P(M)}{P(D)}
$$</mathjax></p>
<p>Using conditional probability, we know that <mathjax>$P(D~|~M)$</mathjax> can be computed as the integral over the parameter space of the likelihood:</p>
<p><mathjax>$$
P(D~|~M) = \int_\Omega P(D~|~\theta, M) P(\theta~|~M) d\theta
$$</mathjax></p>
<p>Computing <mathjax>$P(D)$</mathjax> - the probability of seeing your data <em>at all</em> - is really hard, impossible even. But we can avoid dealing with it by comparing <mathjax>$P(M_1~|~D)$</mathjax> and <mathjax>$P(M_2~|~D)$</mathjax> as an odds ratio:</p>
<p><mathjax>$$
O_{21} \equiv \frac{P(M_2~|~D)}{P(M_1~|~D)} = \frac{P(D~|~M_2)}{P(D~|~M_1)}\frac{P(M_2)}{P(M_1)}
$$</mathjax></p>
<p>We still have to deal with <mathjax>$\frac{P(M_2)}{P(M_1)}$</mathjax>, which is known as the <em>prior odds ratio</em> (because <mathjax>$P(M_1), P(M_2)$</mathjax> are priors). This ratio is assumed to equal 1 if there's no reason to believe or no prior evidence that one model will do better than the other.</p>
<p>The remaining ratio <mathjax>$\frac{P(D~|~M_2)}{P(D~|~M_1)}$</mathjax> is known as the <em>Bayes factor</em> and is the most important part here. The integrals needed to compute the Bayes factor can be approximated using MCMC.</p>
<h3>Model averaging</h3>
<p>We aren't required to choose just one model - rather, with <strong>Bayesian model averaging</strong> we can combine as many as we'd like.</p>
<p>The basic approach is to define a prior over our models, compute a posterior over the models given the data, and then combine the outputs of the models as a weighted average, using models' posterior probabilities as weights.</p>
<h2>References</h2>
<ul>
<li>Review of fundamentals, IFT725. Hugo Larochelle. 2012.</li>
<li><a href="https://www.umiacs.umd.edu/~resnik/pubs/LAMP-TR-153.pdf">Gibbs Sampling for the Uninitiated</a>. Philip Resnik, Eric Hardisty. June 2010.</li>
<li><a href="https://www.edx.org/course/artificial-intelligence-uc-berkeleyx-cs188-1x">CS188: Artificial Intelligence</a>. Dan Klein, Pieter Abbeel. University of California, Berkeley (edX).</li>
<li><a href="https://www.metacademy.org/roadmaps/rgrosse/bayesian_machine_learning">Bayesian Machine Learning</a>. Roger Grosse.</li>
<li><a href="https://www.youtube.com/watch?v=QSNN0no4dSI">Kernel Density Estimation and Kernel Regression</a>. Justin Esarey.</li>
<li><a href="http://www-labs.iro.umontreal.ca/~bengioy/dlbook/">Deep Learning</a>. Yoshua Bengio, Ian Goodfellow, Aaron Courville.</li>
<li><a href="https://jakevdp.github.io/blog/2015/08/07/frequentism-and-bayesianism-5-model-selection/">Frequentism and Bayesianism V: Model Selection</a>. Jake Vanderplas.</li>
<li><a href="https://www.youtube.com/watch?v=dNeW5zoNJ7g">Bayesian Nonparameterics 1</a>. Machine Learning Summer School 2013. Max Planck Institute for Intelligent Systems, Tübingen. Yee Whye Teh.</li>
<li><a href="http://www.cs.toronto.edu/~rgrosse/csc321/probabilistic_models.pdf">Lecture 15: Learning probabilistic models</a>. Roger Grosse, Nitish Srivastava.</li>
<li><a href="http://blog.echen.me/2012/03/20/infinite-mixture-models-with-nonparametric-bayes-and-the-dirichlet-process/">Infinite Mixture Models with Nonparametric Bayes and the Dirichlet Process</a>. Edwin Chen.</li>
</ul>
    
    <script src="http://cdn.bootcss.com/jquery/1.11.1/jquery.js"></script>
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>
    <script>
        $(document).ready(function() {
            $('pre').each(function(i, e) {hljs.highlightBlock(e)});
            MathJax.Hub.Config({
                tex2jax: {
                    inlineMath: [["$","$"]],
                    displayMath: [['$$','$$']],
                    processEscapes: true
                },
                "HTML-CSS": {
                    linebreaks: { automatic: true }
                }
            });
            MathJax.Hub.Startup.onload();
        });
    </script>
    <script src="http://ai-code.tech/ai_notes_html/js/custom.js"></script>


</body>
</html>
