
<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1">

    <title>Neural Nets</title>

    <link rel="stylesheet" type="text/css" href="../style.css">
    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/color-brewer.min.css">
</head>

<body>

    <h1>Neural Nets</h1>
<p>When it comes down to it, a neural net is just a very sophisticated way of fitting a curve.</p>
<p>Neural networks with at least one hidden layer are <strong>universal approximators</strong>, which means that they can approximate <em>any</em> (continuous) function. This approximation can be improved by increasing the number of hidden neurons in the network (but increases the risk of overfitting).</p>
<p>A key advantage to neural networks is that they are capable of learning features independently - without much human involvement.</p>
<p>Neural networks can also learn <strong>distributed representations</strong>. Say we have animals of some type and color. We could learn representations for each of them, e.g. with a neuron for a red cat, one for a blue dog, one for a blue cat, etc. But this would mean learning many, many representations (for instance, with three types and three colors, we learn nine representations). With distributed representations, we instead have neurons that learn the different colors and other neurons which learn the different types (for instance, with three types and three colors, we have six neurons). Thus the representation of a given case, such as a blue dog, is distributed across the neurons, and ultimately much more compact.</p>
<p>One challenge with neural networks is that it is often hard to understand <em>what</em> a neural network has learned - they may be black boxes which do what we want, but we can't peer in and clearly see how it's doing it.</p>
<h2>Biological basis</h2>
<p>Artificial neural networks (ANNs) are (conceptually) based off of biological neural networks such as the human brain.<br />
Neural networks are composed of <em>neurons</em> which send signals to each other in response to certain inputs.</p>
<p>A single neuron takes in one or more inputs (via dendrites), processes it, and fires one output (via its axon).</p>
<figure><img alt="Source: &lt;http://ulcar.uml.edu/~iag/CS/Intro-to-ANN.html&gt;" src="../assets/neuron.png" /><figcaption>Source: <a href="http://ulcar.uml.edu/~iag/CS/Intro-to-ANN.html">http://ulcar.uml.edu/~iag/CS/Intro-to-ANN.html</a></figcaption>
</figure>
<p>Note that the term "unit" is often used instead of "neuron" when discussing artificial neural networks to dissociate these from the biological version - while there is some basis in biological neural networks, there are vast differences, so it is a deceit to present them as analogous.</p>
<h2>Perceptrons</h2>
<p>A <em>perceptron</em>, first described by Frank Rosenblatt in 1957, is an artificial neuron (a computational model of a biological neuron, first introduced in 1943 by Warren McCulloch and Walter Pitts).</p>
<p>Like a biological neuron, it has multiple inputs, processes them, and returns one output.</p>
<p>Each input has a weight associated with it.</p>
<p>In the simplest artificial neuron, a "binary" or "classic spin" neuron, the neuron "fires" an output of "1" if the weighted sum of these inputs is above some <em>threshold</em>, or "-1" if otherwise.</p>
<p>A single-layer perceptron can't learn XOR:</p>
<figure><img alt="XOR" src="../assets/xor.svg" /><figcaption>XOR</figcaption>
</figure>
<p>A line can't be drawn to separate the <mathjax>$A$</mathjax>s from the <mathjax>$B$</mathjax>s; that is, this is not a linearly separable problem. Single-layer perceptrons cannot represent linearly inseparable functions.</p>
<h2>Sigmoid (logistic) neurons</h2>
<p>A sigmoid neuron is another artificial neuron, similar to a perceptron. However, while the perceptron has a binary output, the sigmoid neuron has a continuous output, <mathjax>$\sigma(w \cdot x+b)$</mathjax>, defined by a special activation function known as the <em>sigmoid function</em> <mathjax>$\sigma$</mathjax> (also known as the <em>logistic function</em>):</p>
<p><mathjax>$$
\begin{aligned}
  \sigma(z) \equiv \frac{1}{1+e^{-z}}.
\end{aligned}
$$</mathjax></p>
<p>which can also be written:</p>
<p><mathjax>$$
\begin{aligned}
  \frac{1}{1+\exp(-\sum_j w_j x_j-b)}.
\end{aligned}
$$</mathjax></p>
<p>Note that if <mathjax>$z = w \cdot x+b$</mathjax> is a large positive number, then <mathjax>$e^{-z} \approx 0$</mathjax> and thus <mathjax>$\sigma(z) \approx 1$</mathjax>. If <mathjax>$z$</mathjax> is a large negative number, then <mathjax>$e^{-z} \rightarrow \infty$</mathjax> and thus <mathjax>$\sigma(z) \approx 0$</mathjax>. So at these extremes, the sigmoid neuron behaves like a perceptron.</p>
<p>Here is the sigmoid function visualized:</p>
<figure><img alt="The sigmoid function" src="../assets/sigmoid.svg" /><figcaption>The sigmoid function</figcaption>
</figure>
<p>Which is a smoothed out step function (which is how a perceptron operates):</p>
<figure><img alt="The step function" src="../assets/step.svg" /><figcaption>The step function</figcaption>
</figure>
<p>Sigmoid neurons are useful because small changes in weights and biases will only produce small changes in output from a given neuron (rather than switching between binary output values as is the case with the step function, which is typically too drastic).</p>
<h2>Activation functions</h2>
<p>The function that determines the output of a neuron is known as the <em>activation function</em>. In the binary/classic spin case, it might look like:</p>
<pre><code>weights = [...]
inputs  = [...]
sum_w = sum([weights[i] * inputs[i] for i in range(len(inputs))])

def activate(sum_w, threshold):
    return 1 if sum_w &gt; threshold else -1
</code></pre>
<p>Or:</p>
<p><mathjax>$$
\begin{aligned}
  \mbox{output} &amp; = &amp; \left\{ \begin{array}{ll}
      -1 &amp; \mbox{if } \sum_j w_j x_j \leq \mbox{ threshold} \\
      1 &amp; \mbox{if } \sum_j w_j x_j &gt; \mbox{ threshold}
      \end{array} \right.
\end{aligned}
$$</mathjax></p>
<p>Note that <mathjax>$w \cdot x = \sum_j w_j x_j$</mathjax>, so it can be notated as a dot product where the weights and inputs are vectors.</p>
<p>In some interpretations, the "binary" neuron returns "0" or "1" instead of "-1" or "1".</p>
<p>An activation function can generally be described as some function:</p>
<p><mathjax>$$\text{output} = f(w \cdot x + b)$$</mathjax></p>
<p>where <mathjax>$b$</mathjax> is the bias (see below).</p>
<h3>Common activation functions</h3>
<figure><img alt="Sigmoid activation function" src="../assets/sigmoid.svg" /><figcaption>Sigmoid activation function</figcaption>
</figure>
<p>A common activation function is the <em>sigmoid</em> function, which takes input and squashes it to be in <mathjax>$[0,1]$</mathjax>, it has the form:</p>
<p><mathjax>$$
\sigma(x) = \frac{1}{1 + e^{-x}}
$$</mathjax></p>
<p>However, the sigmoid activation function has some problems. If the activation yields values at the tails of 0 or 1, the gradient ends up being almost 0. In backpropagation, this local gradient is multiplied with the gradient of the node's output against the total error - if this local gradient is near 0, it "kills" the gradient preventing any signal from going further backwards in the network. For this reason, when using the sigmoid activation function you must be careful of how you initialize the weights - if they are too large, you will "saturate" the network and kill the gradient in this way.</p>
<p>Furthermore, sigmoid outputs are not zero-centered:</p>
<blockquote>
<p>This is undesirable since neurons in later layers of processing in a Neural Network (more on this soon) would be receiving data that is not zero-centered. This has implications on the dynamics during gradient descent, because if the data coming into a neuron is always positive (e.g. x&gt;0 elementwise in f=wTx+b)), then the gradient on the weights w will during backpropagation become either all be positive, or all negative (depending on the gradient of the whole expression f). This could introduce undesirable zig-zagging dynamics in the gradient updates for the weights. However, notice that once these gradients are added up across a batch of data the final update for the weights can have variable signs, somewhat mitigating this issue. Therefore, this is an inconvenience but it has less severe consequences compared to the saturated activation problem above. (<a href="https://cs231n.github.io/neural-networks-1/">CS231n Convolutional Neural Networks for Visual Recognition, Module 1: Modeling one neuron</a>, Andrej Karpathy)</p>
</blockquote>
<figure><img alt="tanh activation function" src="../assets/tanh.svg" /><figcaption>tanh activation function</figcaption>
</figure>
<p>The <em>tanh</em> activation function is another option; it squishes values to be in <mathjax>$[-1, 1]$</mathjax>. However, while its output is zero-centered, it suffers from the same activation saturation issue that the sigmoid does.</p>
<p><mathjax>$$
\tanh(x)  \frac{e^z - e^{-z}}{e^z + e^{-z}}
$$</mathjax></p>
<p>Note that <mathjax>$\tanh$</mathjax> is really just a rescaled sigmoid function:</p>
<p><mathjax>$$
\sigma(x) = \frac{1 + \tanh(\frac{x}{2})}{2}
$$</mathjax></p>
<figure><img alt="ReLU activation function" src="../assets/relu.svg" /><figcaption>ReLU activation function</figcaption>
</figure>
<p>The Rectified Linear Unit (ReLU) is <mathjax>$f(x) = \max(0,x)$</mathjax>, that is, it just thresholds at 0. Compared to the sigmoid/tanh functions, it converges with stochastic gradient descent quickly. Though there is not the same saturation issue as with the sigmoid/tanh functions, ReLUs can still "die" in a different sense - their weights can be updated such that the neuron never activates again, which causes the gradient through that neuron to be zero from then on, thus resulting in the same "killing" of the gradient as with sigmoid/tanh. In practice, lowering the learning rate can avoid this.</p>
<p><em>Leaky ReLUs</em> are an attempt to fix this problem. Rather than outputting 0 when <mathjax>$x &lt; 0$</mathjax>, there will instead be a small negative slope (<mathjax>$\sim 0.01$</mathjax>) when <mathjax>$x &lt; 0$</mathjax>. That is, <mathjax>$y_i = \alpha_i x$</mathjax> when <mathjax>$x_i &lt; 0$</mathjax>, and <mathjax>$\alpha_i$</mathjax> is some fixed value. However, it does not always work well.</p>
<p>Note that <mathjax>$\alpha_i$</mathjax> in this case can also be a parameter to learn instead of a fixed value. These are called <em>parametric ReLUs</em>.</p>
<p>Another alternative is a <em>randomized leaky ReLU</em>, where <mathjax>$\alpha_i$</mathjax> is a random variable during training and fixed afterwards.</p>
<p>There are also some units which defy the conventional activation form of <mathjax>$\text{output} = f(w \cdot x + b)$</mathjax>. One is the <em>Maxout</em> neuron. It's function is <mathjax>$\max(w_1^Tx+b_1, w_2^Tx + b_2)$</mathjax>, which is a generalization of the ReLU and the leaky ReLU (both are special forms of Maxout). It has the benefits of ReLU but does not suffer the dying ReLU problem, but it's main drawback is that it doubles the number of parameters for each neuron (since there are two weight vectors and two bias units).</p>
<p>Karpathy suggests:</p>
<blockquote>
<p>Use the ReLU non-linearity, be careful with your learning rates and possibly monitor the fraction of "dead" units in a network. If this concerns you, give Leaky ReLU or Maxout a try. Never use sigmoid. Try tanh, but expect it to work worse than ReLU/Maxout. <a href="https://cs231n.github.io/neural-networks-1/">source</a></p>
</blockquote>
<table>
<thead>
<tr>
<th>Activation Function</th>
<th>Propagation</th>
<th>Backpropagation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sigmoid</td>
<td><mathjax>$y_s = \frac{1}{1+e^{-x_2}}$</mathjax></td>
<td><mathjax>$[\frac{\partial E}{\partial x}]_s = [\frac{\partial E}{\partial y}]_s \frac{1}{(1+e^{x_2})(1+e^{-x_2})}$</mathjax></td>
</tr>
<tr>
<td>Tanh</td>
<td><mathjax>$y_s = \tanh(x_s)$</mathjax></td>
<td><mathjax>$[\frac{\partial E}{\partial x}]_s = [\frac{\partial E}{\partial y}]_s \frac{1}{\cosh^2 x_s}$</mathjax></td>
</tr>
<tr>
<td>ReLu</td>
<td><mathjax>$y_s = \max(0, x_s)$</mathjax></td>
<td><mathjax>$[\frac{\partial E}{\partial x}]_s = [\frac{\partial E}{\partial y}]_s \mathbb I \{x_s &gt; 0\}$</mathjax></td>
</tr>
<tr>
<td>Ramp</td>
<td><mathjax>$y_s = \min(-1, \max(1,x_s))$</mathjax></td>
<td><mathjax>$[\frac{\partial E}{\partial x}]_s = [\frac{\partial E}{\partial y}]_s \mathbb I \{1- &lt; x_s &lt; 1\}$</mathjax></td>
</tr>
</tbody>
</table>
<p>There is also the <strong>hard-tanh</strong> activation function, which is an approximation of <mathjax>$\tanh$</mathjax> that is faster to compute and take derivatives of:</p>
<p><mathjax>$$
\text{hardtanh}(x) =
\begin{cases}
-1 &amp; x &lt; -1 \\
1 &amp; x &gt; 1 \\
x &amp; \text{otherwise}
\end{cases}
$$</mathjax></p>
<h3>Softmax function</h3>
<p>The <strong>softmax function</strong> (called such because it is like a "softened" maximum function) may be used as the output layer's activation function. It takes the form:</p>
<p><mathjax>$$
f^N_i(\text{NET}^N_i) = \frac{e^{\text{NET}^N_i}}{\sum_j^k e^{\text{NET}^N_j}}
$$</mathjax></p>
<p>To clarify, we are summing over all the output neurons in the denominator.</p>
<p>This function has the properties that it sums to 1 and that all of its outputs are positive, which are useful for modeling probability distributions.</p>
<p>The cost function to use with softmax is the (categorical) cross-entropy loss function. It has the nice property of having a very big gradient when the target value is 1 and the output is almost 0.</p>
<p>The categorical cross-entropy loss:</p>
<p><mathjax>$$
L_i = -\sum_j t_{i,j} \log(p_{i,j})
$$</mathjax></p>
<h3>Radial basis functions</h3>
<p>You can base your activation function off of <em>radial basis functions</em> (RBFs):</p>
<p><mathjax>$$
f(X) = \sum_{i=1}^N a_i p(||b_i X - c_i||)
$$</mathjax></p>
<p>where</p>
<ul>
<li><mathjax>$X$</mathjax> = input vector of attributes</li>
<li><mathjax>$p$</mathjax> = the RBF</li>
<li><mathjax>$c$</mathjax> = vector center (peak) of the RBF</li>
<li><mathjax>$a$</mathjax> = the vector coefficient/weight for each RBF</li>
<li><mathjax>$b$</mathjax> = the vector coefficient/weight for each input attribute</li>
</ul>
<p>A radial basis function (RBF) is a function which is:</p>
<ul>
<li>symmetric about its center, which is its peak (with a value of 1)</li>
<li>
<p>can be in <mathjax>$n$</mathjax> dimensions, but always returns a single scalar value <mathjax>$r$</mathjax>, the distance (usually Euclidean) b/w the input vector and the RBF's peak:</p>
<p><mathjax>$$r = ||x - x_i||$$</mathjax></p>
</li>
</ul>
<p><mathjax>$\phi$</mathjax> is used to denote a RBF.</p>
<p>A neural network that uses RBFs as its activation functions is known as <em>radial basis function neural network</em>.</p>
<p>The 1D Gaussian RBF is an example:</p>
<figure><img alt="1D Gaussian RBF" src="../assets/gaussian_rbf.svg" /><figcaption>1D Gaussian RBF</figcaption>
</figure>
<p>Defined as:</p>
<p><mathjax>$$
\phi(r) = e^{-r^2}
$$</mathjax></p>
<p>The Ricker Wavelet is another example:</p>
<figure><img alt="The Ricker Wavelet" src="../assets/ricker_rbf.svg" /><figcaption>The Ricker Wavelet</figcaption>
</figure>
<p>Defined as:</p>
<p><mathjax>$$
\phi(r) = (1-r^2) \cdot e^{-\frac{r^2}{2}}
$$</mathjax></p>
<h2>Feed-forward neural networks</h2>
<p>A <em>feed-forward</em> neural network is a simple neural network with an input layer, and output layer, and one or more intermediate layers of neurons.</p>
<p>These layers are <em>fully-connected</em> in that every neuron of the previous layer is connected to every neuron in the following layer. Such layers are also called <em>affine</em> or <em>dense</em> layers.</p>
<p>When we describe the network in terms of layers as a "<mathjax>$N$</mathjax>-layer" neural network, we leave out the input layer (i.e. a 1-layer neural network has an input and an output layer, a 2-layer one has an input, a hidden, and an output layer.). ANNs may also be described by its number of nodes (units), or, more commonly, by the number of parameters in the entire network. (CS231n Convolutional Neural Networks for Visual Recognition, Module 1: Neural Networks Part 1: Setting up the Architecture. Andrej Karpathy. <a href="https://cs231n.github.io/neural-networks-1/">https://cs231n.github.io/neural-networks-1/</a>)</p>
<p>This model is often called "feed-forward" because values go into the input layer and are fed into subsequent layers.</p>
<p>Different <em>learning algorithms</em> can train such a network so that its weights are adjusted appropriately for a given task. It's worth emphasizing that the <em>structure</em> of the network is distinct from the <em>learning algorithm</em> which tunes its weights and biases. The most popular learning algorithm for neural networks is <em>backpropagation</em>.</p>
<h2>Training neural networks</h2>
<h3>Backpropagation</h3>
<p>The most common algorithm for adjusting a neural network's weights and biases is <em>backpropagation</em>.</p>
<p>Backpropagation is just the calculation of partial derivatives (the gradient) by moving backwards through the network (from output to input), accumulating them by applying the chain rule. In particular, it computes the gradient of the loss function with respect to the weights in the network (i.e. the derivatives of the loss function with respect to each weight in the network) in order to update the weights.</p>
<p>We compute the total error for the network on the training data and then want to know how a change in an individual weight within the network affects this total error (i.e. the result of our cost function), e.g. <mathjax>$\frac{\partial E_{\text{total}}}{\partial w_i}$</mathjax>.</p>
<p>"Backpropagation" is almost just a special term for the chain rule in the context of training neural networks. This is because a neural network can be thought of as a composition of functions, in which case to compute the derivative of the overall function, you just apply the chain rule for computing derivatives.</p>
<p>To elaborate on thinking of neural network as a "composition of functions": each layer represents a function taking in the inputs of the previous layer's output, e.g. if the previous layer is a function that outputs a vector, <mathjax>$g(x)$</mathjax>, then the next layer, if we call it a function <mathjax>$f$</mathjax>, is <mathjax>$f(g(x))$</mathjax>.</p>
<p>The general procedure for training a neural network with backpropagation is:</p>
<ul>
<li>Initialize the neural network's weights and biases.</li>
<li>Training data is input into the NN to the output neurons, in feed-forward style.</li>
<li>The error of the output is then propagated backwards (from the output layer back to the input layer).</li>
<li>As the error is propagated, weights and biases are adjusted (according to a <em>learning rate</em>, detailed below) to minimize the remaining error between the actual and desired outputs.</li>
</ul>
<p>Consider the following simple neural net:</p>
<figure><img alt="Simple neural network" src="../assets/simplenn.svg" /><figcaption>Simple neural network</figcaption>
</figure>
<p>Here's a single neuron expanded:</p>
<figure><img alt="Single sigmoid neuron" src="../assets/single_neuron.svg" /><figcaption>Single sigmoid neuron</figcaption>
</figure>
<p>Remember that a neuron processes its inputs by computing the dot product of its weights and inputs (i.e. the sum of its weight-input products) and then passes this resulting <em>net input</em> into its activation function (in this case, it is the sigmoid function).</p>
<p>Say we have passed some training data through the network and computed the total error as <mathjax>$E_\text{total}$</mathjax>. To update the weight <mathjax>$w_{2,1}$</mathjax>, for example, we are looking for the partial derivative <mathjax>$\frac{\partial E_{\text{total}}}{\partial w_{2,1}}$</mathjax>, which by the chain rule is equal to:</p>
<p><mathjax>$$
\frac{\partial E_{\text{total}}}{\partial w_{2,1}} = \frac{\partial E_\text{total}}{\partial o_{2,1}} \times \frac{\partial o_{2,1}}{\partial i_{2,1}} \times \frac{\partial i_{2,1}}{\partial w_{2,1}}
$$</mathjax></p>
<p>Then we take this value and subtract it, multiplied by a learning rate <mathjax>$\eta$</mathjax> (sometimes notated <mathjax>$\alpha$</mathjax>), from the current weight <mathjax>$w_{2,1}$</mathjax> to get <mathjax>$w_{2,1}$</mathjax>'s updated weight, though updates are only actually applied after these update values have been computed for all of the network's weights.</p>
<p>If we wanted to calculate the update value for <mathjax>$w_{1,1}$</mathjax>, we do something similar:</p>
<p><mathjax>$$
\frac{\partial E_{\text{total}}}{\partial w_{1,1}} = \frac{\partial E_\text{total}}{\partial o_{1,1}} \times \frac{\partial o_{1,1}}{\partial i_{1,1}} \times \frac{\partial i_{1,1}}{\partial w_{1,1}}
$$</mathjax></p>
<p>Any activation function can be used with backprop, it just must be differentiable anywhere.</p>
<h4>The chain rule of derivatives (refresher)</h4>
<p>(adapted from the CS231n notes cited below)</p>
<p>Refresher on derivatives: say you have a function <mathjax>$f(x,y,z)$</mathjax>. The derivative of <mathjax>$f$</mathjax> with respect to <mathjax>$x$</mathjax> is called a <em>partial derivative</em>, since it is only with respect to one of the variables, is notated <mathjax>$\frac{\partial f}{\partial x}$</mathjax> and is just a function that tells you how much <mathjax>$f$</mathjax> changes due to <mathjax>$x$</mathjax> at any point. The gradient is just a vector of these partial derivatives, so that there is a partial derivative for each variable (i.e. here it would be a vector of the partial derivative of <mathjax>$f$</mathjax> wrt <mathjax>$x$</mathjax>, and then wrt <mathjax>$y$</mathjax>, and then wrt <mathjax>$z$</mathjax>).</p>
<p>As a simple example, consider the function <mathjax>$f(x,y) = xy$</mathjax>. The derivatives here are just <mathjax>$\frac{\partial f}{\partial x} = y, \frac{\partial f}{\partial y} = x$</mathjax> What does this mean? Well, take <mathjax>$\frac{\partial f}{\partial x} = y$</mathjax>. This means that, at any given point, increasing <mathjax>$x$</mathjax> by a infinitesimal amount will change the output of the function by <mathjax>$y$</mathjax> times the amount that <mathjax>$x$</mathjax> changed. So if <mathjax>$y = -3$</mathjax>, then any small change in <mathjax>$x$</mathjax> will decrease <mathjax>$f$</mathjax> by that amount times <mathjax>$-3$</mathjax>.</p>
<p>Now consider the function <mathjax>$f(x,y,z) = (x+y)z$</mathjax>. We can derive this by declaring <mathjax>$q = x+y$</mathjax> and then re-writing <mathjax>$f$</mathjax> to be <mathjax>$f=qz$</mathjax>. We can compute the gradient of <mathjax>$f$</mathjax> in this form (note that it is the same as <mathjax>$f(x,y) = xy$</mathjax> from before): <mathjax>$\frac{\partial f}{\partial q} = z, \frac{\partial f}{\partial z} = q$</mathjax>. The gradient of <mathjax>$q$</mathjax> is also simple: <mathjax>$\frac{\partial q}{\partial x} = 1, \frac{\partial q}{\partial y} = 1$</mathjax>. We can combine these gradients to get the gradient of <mathjax>$f$</mathjax> wrt to <mathjax>$x,y,z$</mathjax> instead of wrt to <mathjax>$q,z$</mathjax> as we have now. We can get the missing partial derivatives wrt to <mathjax>$x$</mathjax> and <mathjax>$y$</mathjax> by using the chain rule, which just requires that we multiply the appropriate partials:</p>
<p><mathjax>$$
\frac{\partial f}{\partial x} = \frac{\partial f}{\partial q} \frac{\partial q}{\partial x}, \frac{\partial f}{\partial y} = \frac{\partial f}{\partial q} \frac{\partial q}{\partial y}
$$</mathjax></p>
<p>In code (adapted from the CS231 notes cited below)</p>
<pre><code># set some inputs
x = -2; y = 5; z = -4

# perform the forward pass
q = x + y # q becomes 3
f = q * z # f becomes -12

# perform the backward pass (backpropagation) in reverse order:
# first backprop through f = q * z
dfdz = q # df/dz = q, so gradient on z becomes 3
dfdq = z # df/dq = z, so gradient on q becomes -4
dqdx = 1.
dqdy = 1.
# now backprop through q = x + y
dfdx = dqdx * dfdq # dq/dx = 1. And the multiplication here is the chain rule!
dfdy = dqdy * dfdq # dq/dy = 1
</code></pre>
<p>So essentially you can decompose any function into smaller, simpler functions, compute the gradients for those, then use the chain rule to aggregate them into the original function's gradient.</p>
<h4>The details</h4>
<p>Consider the neural network:</p>
<figure><img alt="A neural network" src="../assets/neural_network.svg" /><figcaption>A neural network</figcaption>
</figure>
<p>Where:</p>
<ul>
<li><mathjax>$L_i$</mathjax> is layer <mathjax>$i$</mathjax></li>
<li><mathjax>$N^i_j$</mathjax> is the <mathjax>$j$</mathjax>th node in layer <mathjax>$i$</mathjax></li>
<li><mathjax>$N$</mathjax> is the number of layers</li>
<li><mathjax>$k$</mathjax> is the number of outputs, e.g. classes, or <mathjax>$k=1$</mathjax> for regression</li>
<li><mathjax>$n_i$</mathjax> is the number of nodes in layer <mathjax>$i$</mathjax></li>
</ul>
<p>Given training data:</p>
<p><mathjax>$$
\begin{aligned}
(X^{(1)}&amp;, Y^{(1)}) \\
(X^{(2)}&amp;, Y^{(2)}) \\
&amp;\vdots \\
(X^{(m)}&amp;, Y^{(m)})
\end{aligned}
$$</mathjax></p>
<p>Where <mathjax>$X^{(i)} \in \mathbb R^{1 \times d}$</mathjax> and</p>
<ul>
<li><mathjax>$d$</mathjax> is the dimensionality of the input</li>
<li><mathjax>$m$</mathjax> is the number of training examples</li>
</ul>
<p>Thus <mathjax>$X$</mathjax> is the input matrix, <mathjax>$X \in \mathbb R^{m \times d}$</mathjax>.</p>
<p>For a node <mathjax>$N^i_j$</mathjax>:</p>
<ul>
<li><mathjax>$b^i_j$</mathjax> is the bias for the node (scalar), i.e. <mathjax>$b^i_j \in \mathbb R$</mathjax></li>
<li><mathjax>$w^i_j$</mathjax> is the weights for the node, <mathjax>$w^i_j \in \mathbb R^{1 \times n_{i-1}}$</mathjax></li>
<li><mathjax>$f^i_j$</mathjax> is the activation function for the node</li>
<li><mathjax>$\text{NET}^i_j$</mathjax> is the net input for the node, <mathjax>$\text{NET}^i_j = W^i_j \cdot \text{OUT}^{i-1} + b^i_j$</mathjax>, <mathjax>$\text{NET}^i_j \in \mathbb R$</mathjax></li>
<li><mathjax>$\text{OUT}^i_j$</mathjax> is the output for the node, <mathjax>$\text{OUT}^i_j = f^i_j(\text{NET}^i_j)$</mathjax>, <mathjax>$\text{OUT}^i_j \in \mathbb R$</mathjax></li>
</ul>
<p>For a layer <mathjax>$L^i$</mathjax>:</p>
<ul>
<li><mathjax>$b^i$</mathjax> is the bias vector for the layer, <mathjax>$b^i \in \mathbb R^{n_i \times 1}$</mathjax>, i.e.</li>
</ul>
<p><mathjax>$$
b^i = \begin{bmatrix} b^i_1 \\ b^i_2 \\ \vdots \\ b^i_{n_i} \end{bmatrix}
$$</mathjax></p>
<ul>
<li><mathjax>$W^i$</mathjax> is the weight matrix for the layer, <mathjax>$W^i \in \mathbb R^{n_i \times n_{i-1}}$</mathjax>, i.e.</li>
</ul>
<p><mathjax>$$
W^i = \begin{bmatrix} W^i_1 \\ W^i_2 \\ \vdots \\ W^i_{n_i} \end{bmatrix}
$$</mathjax></p>
<ul>
<li><mathjax>$f^i$</mathjax> is the activation function for the layer, since generally <mathjax>$f^i = f^i_1 = f^i_2 = \dots = f^i_{n_i}$</mathjax></li>
<li><mathjax>$\text{NET}^i$</mathjax> is the net input for the layer:</li>
</ul>
<p><mathjax>$$
\text{NET}^i = W^i \cdot \text{OUT}^{i-1} + b^i, \text{NET}^i \in \mathbb R^{n_i \times 1}
$$</mathjax></p>
<ul>
<li><mathjax>$\text{OUT}^i$</mathjax> is the output for the layer:</li>
</ul>
<p><mathjax>$$
\text{OUT}^i = f^i(\text{NET}^i), \text{OUT}^i \in \mathbb R^{n_i \times 1}
$$</mathjax></p>
<p>Note that <mathjax>$\text{OUT}^N = h_{\theta}(X)$</mathjax>.</p>
<p>The feed-forward step is a straightforward algorithm:</p>
<div class="highlight"><pre>OUT^0 = X
for i in 1...N
    OUT^i = f^i(W^i \cdot OUT^{i-1}+b^i)
</pre></div>


<p>With backpropagation, we are interested in the gradient <mathjax>$\nabla J$</mathjax> for each iteration. <mathjax>$\nabla J$</mathjax> includes the components <mathjax>$\frac{\partial J}{\partial W^i_j}$</mathjax> and <mathjax>$\frac{\partial J}{\partial b^i_j}$</mathjax> (that is, how the cost function changes with respect to the weights and biases in the network).</p>
<p>The main advantage of backpropagation is that it allows us to compute this gradient <em>efficiently</em>. There are other ways we could do it. For instance, we could manually calculate the partial derivatives of the cost function with respect to each individual weight, which, if we had <mathjax>$w$</mathjax> weights, would require computing the cost function <mathjax>$w$</mathjax> times, which requires <mathjax>$w$</mathjax> forward passes. Naturally, given a complex network with many, many weights, this becomes extremely costly to compute. The beauty of backpropagation is that we can compute these partial derivatives (that is, the gradient), with just a single forward pass.</p>
<p>Some notation:</p>
<ul>
<li><mathjax>$J$</mathjax> is the cost function for the network (what it is depends on the use case)</li>
<li><mathjax>$\delta^i$</mathjax> is the error for layer <mathjax>$i$</mathjax></li>
<li><mathjax>$\odot$</mathjax> is the elementwise product ("Hadamard" or "Schur" product)</li>
</ul>
<p>The error for a layer <mathjax>$i$</mathjax> is how much the cost function changes wrt to that layer's net input, i.e. <mathjax>$\delta^i = \frac{\partial J}{\partial \text{NET}^i}$</mathjax>.</p>
<p>For the output layer, this is straightforward (by applying the chain rule):</p>
<p><mathjax>$$
\delta^N = \frac{\partial J}{\partial \text{NET}^N} = \frac{\partial J}{\partial \text{OUT}^N} \frac{\partial \text{OUT}^N}{\partial \text{NET}^N}
$$</mathjax></p>
<p>Since <mathjax>$\text{OUT}^N = f^N(\text{NET}^N)$</mathjax>, then <mathjax>$\frac{\partial \text{OUT}^N}{\partial \text{NET}^N} = (f^N)'(\text{NET}^N)$</mathjax>.</p>
<p>Thus we have:</p>
<p><mathjax>$$
\delta^N = \frac{\partial J}{\partial \text{OUT}^N} (f^N)'(\text{NET}^N)
$$</mathjax></p>
<p>Note that for <mathjax>$\frac{\partial J}{\partial \text{OUT}^N}$</mathjax>, we are computing the derivative of the cost function <mathjax>$J$</mathjax> with respect to each training example's corresponding output, and then we average them (in some situations, such as when the total number of training examples is not fixed, their sum is used). It is costly to do this across all training examples if you have a large training set, in which case, the minibatch stochastic variant of gradient descent may be more appropriate. (TODO this may need clarification/revision)</p>
<p>For the hidden layer prior to the output, <mathjax>$L^{N-1}$</mathjax>, we would need to connect that layer's net input, <mathjax>$\text{NET}^{N-1}$</mathjax>, to the cost function <mathjax>$J$</mathjax>:</p>
<p><mathjax>$$
\delta^{N-1} = \frac{\partial J}{\partial \text{NET}^{N-1}} = \frac{\partial J}{\partial \text{OUT}^N} \frac{\partial \text{OUT}^N}{\partial \text{NET}^N} \frac{\partial \text{NET}^N}{\partial \text{OUT}^{N-1}} \frac{\partial \text{OUT}^{N-1}}{\partial \text{NET}^{N-1}}
$$</mathjax></p>
<p>We have already calculated the term <mathjax>$\frac{\partial J}{\partial \text{OUT}^N} \frac{\partial \text{OUT}^N}{\partial \text{NET}^N}$</mathjax> as <mathjax>$\delta^N$</mathjax>, so this can be restated:</p>
<p><mathjax>$$
\delta^{N-1} = \delta^N \frac{\partial \text{NET}^N}{\partial \text{OUT}^{N-1}} \frac{\partial \text{OUT}^{N-1}}{\partial \text{NET}^{N-1}}
$$</mathjax></p>
<p>Since <mathjax>$\text{OUT}^{N-1} = f^{N-1}(\text{NET}^{N-1})$</mathjax>, then <mathjax>$\frac{\partial \text{OUT}^{N-1}}{\partial \text{NET}^{N-1}} = (f^{N-1})'(\text{NET}^{N-1})'$</mathjax>.</p>
<p>Similarly, since <mathjax>$\text{NET}^N = W^N \cdot OUT^{N-1} + b^N$</mathjax>, then <mathjax>$\frac{\partial \text{NET}^N}{\partial \text{OUT}^{N-1}} = W^N$</mathjax>.</p>
<p>Thus:</p>
<p><mathjax>$$
\delta^{N-1} = W^N \delta^N \odot (f^{N-1})'(\text{NET}^{N-1})
$$</mathjax></p>
<p>This is how we compute <mathjax>$\delta^i$</mathjax> for all <mathjax>$i \neq N$</mathjax>, i.e. we push back (backpropagate) the next ("next" in the forward sense) layer's error, <mathjax>$\delta^{i+1}$</mathjax>, to <mathjax>$L^i$</mathjax> to get <mathjax>$\delta^i$</mathjax>. So we can generalize the previous equation:</p>
<p><mathjax>$$
\delta^i = W^{i+1} \delta^{i+1} \odot (f^i)'(\text{NET}^i), i \neq N
$$</mathjax></p>
<p>We are most interested in updating weights and biases, rather than knowing the errors themselves. That is, we are most interested in the quantities:</p>
<p><mathjax>$$
\frac{\partial J}{\partial W^i}, \frac{\partial J}{\partial b^i}
$$</mathjax></p>
<p>For any layer <mathjax>$L_i$</mathjax>.</p>
<p>These are relatively easy to derive.</p>
<p>We want to update the weights such that the error is lowered with the new weights. Thus we compute the gradient of the error with respect to the weights and biases to learn in which way the error is increasing and by how much. Then we move in the opposite direction by that amount (typically weighted by a learning rate).</p>
<p><mathjax>$$
\begin{aligned}
\frac{\partial J}{\partial b^i} &amp;= \frac{\partial J}{\partial \text{NET}^i} \frac{\partial \text{NET}^i}{\partial b^i} \\
\frac{\partial J}{\partial W^i} &amp;= \frac{\partial J}{\partial \text{NET}^i} \frac{\partial \text{NET}^i}{\partial W^i}
\end{aligned}
$$</mathjax></p>
<p>We previously showed that <mathjax>$\delta^i = \frac{\partial J}{\partial \text{NET}^i}$</mathjax>, so here we have:</p>
<p><mathjax>$$
\begin{aligned}
\frac{\partial J}{\partial b^i} &amp;= \delta^i \frac{\partial \text{NET}^i}{\partial b^i} \\
\frac{\partial J}{\partial W^i} &amp;= \delta^i \frac{\partial \text{NET}^i}{\partial W^i}
\end{aligned}
$$</mathjax></p>
<p>Then, knowing that <mathjax>$\text{NET}^i = W^i \cdot \text{OUT}^{i-1} + b^i$</mathjax>, we get:</p>
<p><mathjax>$$
\begin{aligned}
\frac{\partial \text{NET}^i}{\partial b^i} &amp;= 1 \\
\frac{\partial \text{NET}^i}{\partial W^i} &amp;= \text{OUT}^{i-1}
\end{aligned}
$$</mathjax></p>
<p>Thus:</p>
<p><mathjax>$$
\begin{aligned}
\frac{\partial J}{\partial b^i} &amp;= \delta^i \\
\frac{\partial J}{\partial W^i} &amp;= \delta^i \text{OUT}^{i-1}
\end{aligned}
$$</mathjax></p>
<p>Then we can use these for gradient descent.</p>
<p>A quick bit of notation: <mathjax>$\delta^{j,i}$</mathjax> refers to layer <mathjax>$i$</mathjax>'s error for the <mathjax>$j$</mathjax>th training example; similarly, <mathjax>$\text{OUT}^{j,i}$</mathjax> refers to layer <mathjax>$i$</mathjax>'s output for the <mathjax>$j$</mathjax>th training example.</p>
<p><mathjax>$$
\begin{aligned}
W^i &amp;\to W^i - \frac{\eta}{m} \sum_j \delta^{j,i} (\text{OUT}^{j, i-1})^T \\
b^i &amp;\to b^i - \frac{\eta}{m} \sum_j \delta^{j,i}
\end{aligned}
$$</mathjax></p>
<p>So, to clarify, we are computing <mathjax>$\frac{\partial J}{\partial b^i} = \delta^i, \frac{\partial J}{\partial W^i} = \delta^i \text{OUT}^{i-1}$</mathjax> for each training example and computing their average. As mentioned before, in some cases you may only take their sum, which just involves the removal of the <mathjax>$\frac{1}{m}$</mathjax> term, so you are effectively just scaling the change.</p>
<h4>Considerations</h4>
<p>Backpropagation is <em>not</em> a guarantee of training at all nor of quick training.</p>
<p>Possible issues include:</p>
<ul>
<li><em>network paralysis</em>: if the weights become very large, the neurons' <mathjax>$\text{OUT}$</mathjax>s may become very large, where the derivative of the activation function is very small, so weights are not really updated and get "stuck" at large values.</li>
<li><em>local minima</em>: statistical training methods can be used (such as simulated annealing), to avoid local minima but increase training time</li>
<li><em>step size</em>: if it is too small, training is too slow, if it is too large, paralysis or instability (no convergence) are possible</li>
<li><em>stability</em>: that the network does not mess up its learning of something else to learn another thing. For instance, say it learns good weights for one input, but to learn good weights for another input, it "overwrites" or "forgets" what it learned about the prior input.</li>
</ul>
<p>Note that in high dimensions, local minima are usually not a problem.</p>
<p>More typically, there are saddle points, which slow down training but can be escaped in time. This is because with many dimensions, it is unlikely that a point is a minimum is <em>all</em> dimensions (if we consider that a point is a minimum in one dimensions with probability <mathjax>$p$</mathjax>, then it has probability <mathjax>$p^n$</mathjax> to be a minimum in all <mathjax>$n$</mathjax> dimensions); it is, however, likely that it is a local minimum in some of the dimensions.</p>
<p>As training nears the global minimum, <mathjax>$p$</mathjax> increases, so if you do end up at a local minimum, it will likely be close enough to the global minimum.</p>
<h3>Statistical (stochastic) training</h3>
<p>Statistical (or "stochastic") training methods, contrasted with deterministic training methods (such as backpropagation as described abov), involve some randomness to avoid local minima. They generally work by randomly leaving local minima to possibly find the global minimum. The severity of this randomness decreases over time so that a solution is "settled" upon (this gradual "cooling" of the randomness is the key part of <em>simulated annealing</em>).</p>
<p>Simulated annealing applied as a training method to a neural network is called <em>Boltzmann training</em> (neural networks trained in this way are called <em>Boltzmann machines</em>):</p>
<ol>
<li>set <mathjax>$T$</mathjax> (the artificial temperature) to a large value</li>
<li>apply inputs, calculate outputs and objective function</li>
<li>make random weight changes, recalculate network output and change in objective function<br />
4a. if objective function improves, keep weight changes<br />
4b. if the objective function worsens, accept the change according to the probability drawn from Boltzmann distribution, <mathjax>$P(c)$</mathjax>, select a random variable <mathjax>$r$</mathjax> from a uniform distribution in <mathjax>$[0, 1]$</mathjax>; if <mathjax>$P(c) &gt; r$</mathjax>, keep the change, otherwise, don't.</li>
</ol>
<p><mathjax>$$
P(c) = exp(\frac{-c}{kT})
$$</mathjax></p>
<p>Where:</p>
<ul>
<li><mathjax>$c$</mathjax> the change in the objective function</li>
<li><mathjax>$k$</mathjax> a constant analogous to the Boltzmann's constant in simulated annealing, specific for the current problem</li>
<li><mathjax>$T$</mathjax> the artificial temperature</li>
<li><mathjax>$P(c)$</mathjax> the probability of the change <mathjax>$c$</mathjax> in the objective function</li>
</ul>
<p>Steps 3 and 4 are repeated for each of the weights in the network as <mathjax>$T$</mathjax> is gradually decreased.</p>
<p>The random weight change can be selected in a few ways, but one is just choosing it from a Gaussian distribution, <mathjax>$P(w) = exp(\frac{-w^2}{T^2})$</mathjax>, where <mathjax>$P(w)$</mathjax> is the probability of a weight change of size <mathjax>$w$</mathjax> and <mathjax>$T$</mathjax> is the artificial temperature. Then you can use Monte Carlo simulation to generate the actual weight change, <mathjax>$\Delta w$</mathjax>.</p>
<p>Boltzmann training uses the following cooling rate, which is necessary for convergence to a global minimum:</p>
<p><mathjax>$$
T(t) = \frac{T_0}{log(1+t)}
$$</mathjax></p>
<p>Where <mathjax>$T_0$</mathjax> is the initial temperature, and <mathjax>$t$</mathjax> is the artificial time.</p>
<p>The problem with Boltzmann training is that it can be very slow (the cooling rate as computed above is very low).</p>
<p>This can be resolved by using the Cauchy distribution instead of the Boltzmann distribution; the former has fatter tails so has a higher probability of selecting large step sizes. Thus the cooling rate can be much quicker:</p>
<p><mathjax>$$
T(t) = \frac{T_0}{1+t}
$$</mathjax></p>
<p>The Cauchy distribution is:</p>
<p><mathjax>$$
P(x) = \frac{T(t)}{T(t)^2 + x^2}
$$</mathjax></p>
<p>where <mathjax>$P(x)$</mathjax> is the probability of a step of size <mathjax>$x$</mathjax>.</p>
<p>This can be integrated, which makes selecting random weights much easier:</p>
<p><mathjax>$$
x_c = \rho T(t) \tan(P(x))
$$</mathjax></p>
<p>Where <mathjax>$\rho$</mathjax> is the learning rate coefficient and <mathjax>$x_c$</mathjax> is the weight change.</p>
<p>Here we can just select a random number from a uniform distribution in <mathjax>$(-\frac{\pi}{2}, \frac{\pi}{2})$</mathjax>, then substitute this for <mathjax>$P(x)$</mathjax> and solve for <mathjax>$x$</mathjax> in the above, using the current temperature.</p>
<p>Cauchy training still may be slow so we can also use a method based on <em>artificial specific heat</em> (in annealing, there are discrete energy levels where phase changes occur, at which abrupt changes in the "specific heat" occur). In the context of artificial neural networks, we define the (pseudo)specific heat to be the average rate of change of temperature with the objective function. The idea is that there are parts where the objective function is sensitive to small changes in temperature, where the average value of the objective function makes an abrupt change, so the temperature must be changed slowly here so as not to get stuck in a local minima. Where the average value of the objective function changes little with temperature, large changes in temperature can be used to quicken things.</p>
<p>Still, Cauchy training may be much slower than backprop, and can have issues of network paralysis (because it is possible to have very large random weight changes), esp. if a nonlinearity is used as the activation function (see the bit on network paralysis and the sigmoid function above).</p>
<p>Cauchy training may be combined with backprop to get the best of both worlds - it simply involves computing both the backprop and Cauchy weight updates and applying their weighted sum as the update. Then, the objective function's change is computed, and like with Cauchy training, if there is an improvement, the weight change is kept, otherwise, it is kept with a probability determined by the Boltzmann distribution.</p>
<p>The weighted sum of the individual weight updates is controlled by a coefficient <mathjax>$\eta$</mathjax>, such that the sum is <mathjax>$\eta [\alpha \Delta W_{t-1} + (1-\alpha)\delta \text{OUT}] + (1 - \eta) x_c$</mathjax>, so that if <mathjax>$\eta=0$</mathjax>, the training is purely Cauchy, and if <mathjax>$\eta=1$</mathjax>, it becomes purely backprop.</p>
<p>There is still the issue of the possibility of retaining a massive weight change due to the Cauchy distribution's infinite variance, which creates the possibility of network paralysis. The recommended approach here is to detect saturated neurons by looking at their <mathjax>$\text{OUT}$</mathjax> values - if it is approaching the saturation point (positive or negative), apply some squashing function to its weights (note that this squashing function is not restricted to the range <mathjax>$[-1, 1]$</mathjax> and in fact may work better with a larger range). This potently reduces large weights while only attenuating smaller ones, and maintains symmetry across weights.</p>
<h3>Learning rates</h3>
<p>The amount weights and biases are adjusted is determined by a <em>learning rate</em> <mathjax>$\eta$</mathjax> (sometimes called a <em>delta rule</em> or <em>delta function</em>). This often involves some constant which manages the <em>momentum</em> of learning <mathjax>$\mu$</mathjax> (see below for more on momentum). This learning constant can help "jiggle" the network out of local optima, but you want to take care that it isn't set so high that the network will also jiggle out of the global optima. As a simple example:</p>
<pre><code>    # LEARNING_CONSTANT is defined elsewhere
    def adjust_weight(weight, error, input):
        return weight + error * input * LEARNING_CONSTANT
</code></pre>
<p>In some cases, a <em>simulated annealing</em> approach is used, where the learning constant may be tempered (made smaller, less drastic) as the network evolves, to avoid jittering the network out of the global optima.</p>
<h4>Adaptive learning rates</h4>
<p>Over the course of training, it is often better to gradually decrease the learning rate as you approach an optima so that you don't "overshoot" it.</p>
<h5>Separate adaptive learning rates</h5>
<p>The appropriate learning rate can vary across parameters, so it can help to have different adaptive learning rates for each parameter.</p>
<p>For example, the magnitudes of gradients are often very different across layers (starting small early on, growing larger further on).</p>
<p>The fan-in of a neuron (number of inputs) also has an effect, determining the size of "overshoot" effects (the more inputs there are, the more weights are changed simultaneously, all to adjust the same error, which is what can cause the overshooting).</p>
<p>So what you can do is manually set a global learning rate, then for each weight multiply this global learning rate by a local gain, determined empirically per weight.</p>
<p>One way to determine these learning rates is as follows:</p>
<ul>
<li>start with a local gain <mathjax>$g_{ij} = 1$</mathjax> for each weight <mathjax>$w_{ij}$</mathjax></li>
<li>increase the local gain if the gradient for that weight does not change sign</li>
<li>use small additive increases and multiplicative decreases:</li>
</ul>
<p><mathjax>$$
g_{ij}(t) =
\begin{cases}
g_{ij}(t-1) + 0.05 &amp; \text{if} (\frac{\partial E}{\partial w_{ij}} (t) \frac{\partial E}{\partial w_{ij}}(t-1)) &gt; 0 \\
0.95 g_{ij}(t-1) &amp; \text{otherwise}
\end{cases}
$$</mathjax></p>
<p>This ensures that big gains decay rapidly when oscillations start.</p>
<p>Another tip: limit the gains to line in some reasonable range, e.g. <mathjax>$[0.1, 10]$</mathjax> or <mathjax>$[0.01, 100]$</mathjax></p>
<p>Note that these adaptive learning rates are meant for full batch learning or for very big mini-batches. Otherwise, you may encounter gradient sign changes that are just due to sampling error of a mini-batch.</p>
<p>These adaptive learning rates can also be combined with momentum by using agreement in sign between the current gradient for a weight and the velocity for that weight.</p>
<p>Note that adaptive learning rates deal only with axis-aligned effects.</p>
<h3>Training algorithms</h3>
<p>There are a variety of gradient descent algorithms used for training neural networks. Some of the more popular ones include the following.</p>
<h4>Momentum</h4>
<p><strong>Momentum</strong> is a technique that can be combined with gradient descent to improve its performance.</p>
<p>Conceptually, it applies the idea of velocity and friction to the error surface (imagine a ball rolling around the error surface to find a minimum).</p>
<p>We incorporate a matrix of velocity values <mathjax>$V$</mathjax>, with the same shape as the matrix of weights and biases for the network (for simplicity, we will roll the weights and matrices together into a matrix <mathjax>$W$</mathjax>).</p>
<p>To do so, we break our gradient descent update rule (<mathjax>$W \to W' = W - \eta \nabla J$</mathjax>) into two separate update rules; one for updating the velocity matrix, and another for updating the weights and biases:</p>
<p><mathjax>$$
\begin{aligned}
V \to V' &amp;= \mu V - \eta \nabla J \\
W \to W' &amp;= W + V'
\end{aligned}
$$</mathjax></p>
<p>Another hyperparameter, <mathjax>$\mu \in [0, 1]$</mathjax>, is also introduced - this controls the "friction" of the system (<mathjax>$\mu = 1$</mathjax> is no friction). It is known as the <strong>momentum coefficient</strong>, and it is tuned to prevent "overshooting" the minimum.</p>
<p>You can see that if <mathjax>$\mu$</mathjax> is set to 0, we get the regular gradient descent update rule.</p>
<h4>Nesterov momentum</h4>
<p>A variation on regular momentum is <strong>Nesterov momentum</strong>:</p>
<p><mathjax>$$
\begin{aligned}
V \to V' &amp;= \mu V - \eta \nabla J(\theta + \mu V) \\
W \to W' &amp;= W + V'
\end{aligned}
$$</mathjax></p>
<p>Here we add the velocity to the parameters before computing the gradient.</p>
<p>Using gradient descent with this momentum is also called the <em>Nesterov accelerated gradient</em>.</p>
<h4>Adagrad</h4>
<p><strong>Adagrad</strong> is an enhancement of Nesterov momentum that keeps track of squared gradients over time. This allows it to identify frequently updated parameters and infrequently updated parameters - as a result, learning rates can be adapted <em>per parameter</em> over time (e.g. higher learning rates are assigned to infrequently updated parameters). This makes it quite useful for sparse data, and also means that the learning rate does not need to be manually tuned.</p>
<p>More formally, for each parameter <mathjax>$\theta_i$</mathjax> we have <mathjax>$g_{t,i} = \nabla J(\theta_i)$</mathjax>, so we re-write the update for a parameter <mathjax>$\theta_i$</mathjax> at time <mathjax>$t$</mathjax> to be:</p>
<p><mathjax>$$
\theta_{t+1, i} = \theta_{t, i} - \eta \cdot g_{t, i}
$$</mathjax></p>
<p>The learning rate <mathjax>$\eta$</mathjax> is then modified at each time step <mathjax>$t$</mathjax> by a diagonal matrix <mathjax>$G_t \in \mathbb R^{d \times d}$</mathjax>. Each diagonal element <mathjax>$i,i$</mathjax> in <mathjax>$G_t$</mathjax> is the sum of squared gradients of parameter <mathjax>$\theta_i$</mathjax> up to time <mathjax>$t$</mathjax>. In particular, we divide <mathjax>$\eta$</mathjax> by the square root of this matrix (empirically, the square root improves performance):</p>
<p><mathjax>$$
\theta_{t+1, i} = \theta_{t, i} - \frac{\eta}{\sqrt{G_{t, ii} + \epsilon}} \cdot g_{t, i}
$$</mathjax></p>
<p>An additional smoothing term <mathjax>$\epsilon$</mathjax> is included to prevent division by zero (e.g. <code>1e-8</code>).</p>
<p>As vector operations, this is written:</p>
<p><mathjax>$$
\theta_{t+1} = \theta_{t} - \frac{\eta}{\sqrt{G_{t} + \epsilon}} \odot g_{t}
$$</mathjax></p>
<p>Note that as training progresses, the denominator term <mathjax>$G_t$</mathjax> will grow very large (the sum of squared gradients accumulate), such that the learning rate eventually becomes very small and learning virtually ceases.</p>
<h4>Adadelta</h4>
<p><strong>Adadelta</strong> is an improvement on Adagrad designed to deal with its halting learning rate. Whereas Adagrad takes the sum of <em>all</em> past squared gradients for a parameter, Adadelta takes only the past <mathjax>$w$</mathjax> past squared gradients.</p>
<p>This is implemented as follows. We keep a running average <mathjax>$E[g^2]_t$</mathjax> (<mathjax>$\gamma$</mathjax> is like a momentum term, usually around 0.9):</p>
<p><mathjax>$$
E[g^2]_t = \gamma E[g^2]_{t-1} + (1 - \gamma) g^2_t
$$</mathjax></p>
<p>And then update the Adagrad equation to replace the matrix <mathjax>$G_t$</mathjax> with this running (exponentially decaying) average:</p>
<p><mathjax>$$
\Delta \theta_t = - \frac{\eta}{\sqrt{E[g^2]_t + \epsilon}} g_{t}
$$</mathjax></p>
<p>Note that this running average is the same as the root mean squared (RMS) error criterion of the gradient, so this can be re-written:</p>
<p><mathjax>$$
\Delta \theta_t = - \frac{\eta}{RMS[g]_{t}}
$$</mathjax></p>
<p>There is one more enhancement that is part of Adadelta. The learning rate <mathjax>$\eta$</mathjax>'s units (as in "units of measurement", not as in "hidden units") do not match the parameters' units; this is true for all training methods shown up until now. This is resolved by defining another exponentially decaying average, this one of squared parameter updates:</p>
<p><mathjax>$$
E[\Delta \theta^2]_t = \gamma E[\Delta \theta^2]_{t-1} + (1 - \gamma) \Delta \theta^2_t
$$</mathjax></p>
<p>The RMS error of this term is also taken:</p>
<p><mathjax>$$
RMS[\Delta \theta]_{t} = \sqrt{E[\Delta \theta^2]_t + \epsilon}
$$</mathjax></p>
<p>Thus the Adadelta update is:</p>
<p><mathjax>$$
\Delta \theta_t = - \frac{RMS[\Delta \theta]_{t}}{RMS[g]_{t}} g_{t}
$$</mathjax></p>
<p>Note that Adadelta without the numerator RMS term, that is:</p>
<p><mathjax>$$
\Delta \theta_t = - \frac{\eta}{RMS[g]_{t}}
$$</mathjax></p>
<p>is known as <strong>RMSprop</strong>; for RMSprop typical values are <mathjax>$\gamma=0.9, \eta=0.001$</mathjax>.</p>
<h4>Adam</h4>
<p><strong>Adam</strong>, short for "Adaptive Moment Estimation", is, like Adagrad, Adadelta, and RMSprop, an adaptive learning rate algorithm. Like Adadelta and RMSprop, Adam keeps track of an exponentially decaying average of past squared gradients (here, it is <mathjax>$v_t$</mathjax>), but it also keeps track of an exponentially decaying average of past (non-squared) gradients <mathjax>$m_t$</mathjax>, similar to momentum:</p>
<p><mathjax>$$
\begin{aligned}
m_t &amp;= \beta_1 m_{t-1} + (1 - \beta_1) g_t \\
v_t &amp;= \beta_2 v_{t-1} + (1 - \beta_2) g_t^2
\end{aligned}
$$</mathjax></p>
<p><mathjax>$m_t$</mathjax> and <mathjax>$v_t$</mathjax> are estimates of the first moment (the mean) and second moment (the uncentered variance) of the gradients, respectively.</p>
<p>Note that the <mathjax>$\beta$</mathjax> terms are decay rates (typically <mathjax>$\beta_1=0.9, \beta_2=0.999$</mathjax>) and that <mathjax>$m_t, v_t$</mathjax> are initialized to zero vectors. As such, <mathjax>$m_t, v_t$</mathjax> tend to be a biased towards zero, so bias-corrected versions of each are computed:</p>
<p><mathjax>$$
\begin{aligned}
\hat{m}_t &amp;= \frac{m_t}{1 - \beta^t_1} \\
\hat{v}_t &amp;= \frac{v_t}{1 - \beta^t_2}
\end{aligned}
$$</mathjax></p>
<p>Then the Adam update rule is simply:</p>
<p><mathjax>$$
\theta_{t+1} = \theta_{t} - \frac{\eta}{\sqrt{\hat{v}_t + \epsilon}} \hat{m}_t
$$</mathjax></p>
<h3>Batch Normalization</h3>
<p><strong>Batch normalization</strong> is a normalization method for mini-batch training, which can improve training time (it allows for higher learning rates), act as a regularizer, and reduce the importance of proper parameter initialization. It is applied to <em>intermediate</em> representations in the network.</p>
<p>For a mini-batch <mathjax>$x$</mathjax> (of size <mathjax>$m$</mathjax>), the sample mean and variance for each feature <mathjax>$k$</mathjax> is computed:</p>
<p><mathjax>$$
\begin{aligned}
\bar x_k &amp;= \frac{1}{m} \sum_{i=1}^m x_{i,k} \\
\sigma_k^2 &amp;= \frac{1}{m} \sum_{i=1}^m (x_{i,k} - \bar x_k)^2
\end{aligned}
$$</mathjax></p>
<p>Each feature <mathjax>$k$</mathjax> is then standardized as follows:</p>
<p><mathjax>$$
\hat x_k = \frac{x_k - \bar x_k}{\sqrt{\sigma_k^2 + \epsilon}}
$$</mathjax></p>
<p>where <mathjax>$\epsilon$</mathjax> is a small positive constant to improve numerical stability.</p>
<p>Standardizing intermediate representations in this way can weaken the representational power of the layer, so two additional learnable parameters <mathjax>$\gamma$</mathjax> and <mathjax>$\beta$</mathjax> are introduced to scale and/or shift the data. Altogether, the batch normalization function is as follows:</p>
<p><mathjax>$$
\text{BN}_{x_k} = \gamma_k \hat x_k + \beta_k
$$</mathjax></p>
<p>When <mathjax>$\gamma_k = \sigma_k$</mathjax> and <mathjax>$\beta_k = \bar x_k$</mathjax>, we recover the original representation.</p>
<p>Given a layer with some activation function <mathjax>$\phi$</mathjax>, which would typically be defined as <mathjax>$\phi(Wx+b)$</mathjax>, we can redefine it with batch normalization:</p>
<p><mathjax>$$
\phi(\text{BN}(Wx))
$$</mathjax></p>
<p>The bias is dropped because its effect is cancelled by the standardization.</p>
<p>During test time, we must use <mathjax>$\hat x_k$</mathjax> and <mathjax>$\sigma_k^2$</mathjax> as computed over the training data; the final values are usually achieved by keeping a running average of these statistics over the mini-batches during training.</p>
<p>Refer to <a href="http://arxiv.org/pdf/1510.01378v1.pdf">Batch Normalized Recurrent Neural Networks</a> (Csar Laurent, Gabriel Pereyra, Philmon Brakel, Ying Zhang, Yoshua Bengio) for more details.</p>
<h3>Cost (loss/objective/error) functions</h3>
<p>We have some cost function, which is a function of our parameters, typically notated <mathjax>$J(\theta)$</mathjax>.</p>
<p>For regression, this is often the mean squared error (MSE), also known as the quadratic cost:</p>
<p><mathjax>$$
J(\theta) = \frac{1}{m} \sum^m (y^{(i)} - h_{\theta}(X^{(i)}))^2
$$</mathjax></p>
<p>Note that <mathjax>$h_{\theta}$</mathjax> represents the output of the entire network.</p>
<p>So for a single example, the cost function is:</p>
<p><mathjax>$$
(y^{(i)} - h_{\theta}(X^{(i)}))^2
$$</mathjax></p>
<p>For deriving convenience, we'll include a <mathjax>$\frac{1}{2}$</mathjax> term. Including this term just scales the cost function, which doesn't impact the outcome, and for clarity, we'll substitute <mathjax>$f^N(\text{NET}^N)$</mathjax> for <mathjax>$h_{\theta}(X^{(i)})$</mathjax>, since they are equivalent.</p>
<p><mathjax>$$
\frac{(y^{(i)} - f^N(\text{NET}^N))^2}{2}
$$</mathjax></p>
<p>Deriving with respect to <mathjax>$W^N$</mathjax> and <mathjax>$b^N$</mathjax> gives us the following for individual examples:</p>
<p><mathjax>$$
\begin{aligned}
\frac{\partial J}{\partial W^N} &amp;= (f^N(\text{NET}^N) - y) (f^N)'(\text{NET}^N)X^{(i)} \\
\frac{\partial J}{\partial b^N} &amp;= (f^N(\text{NET}^N) - y) (f^N)'(\text{NET}^N)
\end{aligned}
$$</mathjax></p>
<p>Note that these are dependent on the derivative of the output layer's activation function, <mathjax>$(f^N)'(NET^N)$</mathjax>. This can cause training to become slow in the case of activation functions like the sigmoid function. This is because the derivative near the sigmoid's tails (i.e. where it outputs values close to 0 or 1) is very low (the sigmoid flattens out at its tails). Thus, when the output layer's function has this property, and outputs values near 0 and 1 (in the case of sigmoid), this reduces the entire partial derivative, leading to small updates, which has the effect of slow learning. When slow learning of this sort occurs (that is, the kind caused by the activation functions outputting at their minimum or maximum), it is called <em>saturation</em>, and it is a common problem with neural networks.</p>
<p>For binary classification, a common cost function is the cross-entropy cost, also known as "log loss" or "logistic loss":</p>
<p><mathjax>$$
J(\theta) = -\frac{1}{m} \sum_i^m \sum_j^k [y^{(i)} \ln h_{\theta}(X^{(i)}) + (1 - y^{(i)}) \ln(1 - h_{\theta}(X^{(i)}))]
$$</mathjax></p>
<p>where <mathjax>$m$</mathjax> is the total number of training examples and <mathjax>$k$</mathjax> is the number of output neurons.</p>
<p>The partial derivatives of the cross-entropy cost with respect to <mathjax>$W^N$</mathjax> and <mathjax>$b^N$</mathjax> are (for brevity, we'll notate <mathjax>$f^N(\text{NET}^N)$</mathjax> as simply <mathjax>$f(n)$</mathjax>):</p>
<p><mathjax>$$
\begin{aligned}
\frac{\partial J}{\partial W^N} &amp;= \sum_j^k \frac{(y-f(n))}{f(n)(1-f(n))} f'(n) X \\
\frac{\partial J}{\partial b^N} &amp;= \sum_j^k \frac{(y-f(n))}{f(n)(1-f(n))} f'(n)
\end{aligned}
$$</mathjax></p>
<p>This has the advantage that for some activation functions <mathjax>$f$</mathjax>, such as the sigmoid function, the activation function's derivative <mathjax>$f'$</mathjax> cancels out, thus avoiding the training slowdown that can occur with the MSE.</p>
<p>However, as mentioned before, this saturation occurs with only some activation functions (like the sigmoid function). This isn't a problem, for instance, with linear activation functions, in which case quadratic cost is appropriate (though neural nets with linear activation functions are limited in what they can learn).</p>
<p>Thus we have:</p>
<p><mathjax>$$
\delta^N = \frac{\partial J}{\partial \text{OUT}^N} (f^N)'(\text{NET}^N)
$$</mathjax></p>
<h4>Log-likelihood cost function</h4>
<p>The <strong>log-likelihood cost function</strong> is defined as, for a single training example:</p>
<p><mathjax>$$
-\ln f^N_y(\text{NET}^N_y)
$$</mathjax></p>
<p>That is, given an example that belongs to class <mathjax>$y$</mathjax>, we take the natural log of the value outputted by the output node corresponding to the class <mathjax>$y$</mathjax> (typically this is the <mathjax>$y$</mathjax>th node, since you'd have an output node for each class). If <mathjax>$f^N_y(\text{NET}^N_y)$</mathjax> is close to 1, then the resulting cost is low; the further it is from 1, the larger the value is.</p>
<p>This is assuming that the output node's activation function outputs probability-like values (such as is the case with the softmax function).</p>
<p>This cost function's partial derivatives with respect to <mathjax>$W^N$</mathjax> and <mathjax>$b^N$</mathjax> work out to be:</p>
<p><mathjax>$$
\begin{aligned}
\frac{\partial J}{\partial W^N} &amp;= f^{N-1}(n) (f^N(n) - y) \\
\frac{\partial J}{\partial b^N} &amp;= f^N(n) - y
\end{aligned}
$$</mathjax></p>
<p>For brevity, we've notated <mathjax>$f^N(\text{NET}^N)$</mathjax> as simply <mathjax>$f^N(n)$</mathjax>, and the same for <mathjax>$f^{N-1}(n)$</mathjax>; for the latter <mathjax>$n=\text{NET}^{N-1}$</mathjax>. (TODO clean this notation up)</p>
<p>Note that for softmax activation functions, we avoid the saturation problem with this cost function. Thus softmax output activations and the log-likelihood cost functions are a good pairing for problems requiring probability-like outputs (such as with classification problems).</p>
<h4>Common loss functions</h4>
<table>
<thead>
<tr>
<th>Loss Function</th>
<th>Propagation</th>
<th>Backpropagation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Square</td>
<td><mathjax>$y = \frac{1}{2}(x-d)^2$</mathjax></td>
<td><mathjax>$\frac{\partial E}{\partial x} = (x-d)^T \frac{\partial E}{\partial y}$</mathjax></td>
</tr>
<tr>
<td>Log, <mathjax>$c = \pm 1$</mathjax></td>
<td><mathjax>$y = \log(1 + e^{-cx})$</mathjax></td>
<td><mathjax>$\frac{\partial E}{\partial x} = \frac{-c}{1+e^{cx}} \frac{\partial E}{\partial y}$</mathjax></td>
</tr>
<tr>
<td>Hinge, <mathjax>$c = \pm 1$</mathjax></td>
<td><mathjax>$y = \max(0, m-cx)$</mathjax></td>
<td><mathjax>$\frac{\partial E}{\partial x} = -c \mathbb I \{cx &lt; m \} \frac{\partial E}{\partial y}$</mathjax></td>
</tr>
<tr>
<td>LogSoftMax, <mathjax>$c=1 \dots k$</mathjax></td>
<td><mathjax>$y = \log(\sum_k e^{x_k}) - x_c$</mathjax></td>
<td><mathjax>$[\frac{\partial E}{\partial x}]_s = (\frac{e^{x_s}}{\sum_k} e^{x_k} - \delta_{sc})\frac{\partial E}{\partial y}$</mathjax></td>
</tr>
<tr>
<td>MaxMargin, <mathjax>$c=1 \dots k$</mathjax></td>
<td><mathjax>$y = [\max_{k \neq c} \{x_k + m\} - x_c]_+$</mathjax></td>
<td><mathjax>$[\frac{\partial E}{\partial x}]_s = (\delta_{sk^*} - \delta_{sc}) \mathbb I \{E &gt; 0\} \frac{\partial E}{\partial y}$</mathjax></td>
</tr>
</tbody>
</table>
<h3>Weight initialization</h3>
<p>What are the best values to initialize weights and biases to?</p>
<p>Given normalized data, we could reasonably estimate that roughly half the weights will be negative and roughly half will be positive.</p>
<p>As a result, it may seem intuitive to initialize all weights to zero. But you should not - this causes every neuron to have the same output, which causes them to have the same gradients during backpropagation, which causes them to all have the same parameter updates. Thus none of the neurons will differentiate.</p>
<p>Alternatively, we could set each neuron's initial weights to be a random vector from a standard multidimensional normal distribution (mean of 0, standard deviation of 1), scaled by some value, e.g. <code>0.001</code> so that they are kept very small, but still non-zero. This process is known as <em>symmetry breaking</em>. The random initializations allow the neurons to differentiate themselves during training.</p>
<p>However, this can become problematic.</p>
<p>Consider that the net input to a neuron is:</p>
<p><mathjax>$$
\text{NET} = W \cdot X + b
$$</mathjax></p>
<p>The following extends to the general case, but for simplicity, consider an input <mathjax>$X$</mathjax> that is all ones, with dimension <mathjax>$d$</mathjax>.</p>
<p>Then <mathjax>$\text{NET}$</mathjax> is a sum of <mathjax>$d+1$</mathjax> (plus one for the bias) standard normally distributed independent random variables.</p>
<p>The sum of <mathjax>$n$</mathjax> normally distributed independent random variables is:</p>
<p><mathjax>$$
N(\sum_i^n \mu_i, \sum_i^n \sigma^2_i)
$$</mathjax></p>
<p>That is, it is also a normal distribution.</p>
<p>Thus <mathjax>$\text{NET}$</mathjax> will still have a mean of 0, but it's standard deviation will be <mathjax>$\sqrt{d+1}$</mathjax>.</p>
<p>If for example, <mathjax>$d=100$</mathjax>, this leaves us with a standard deviation of <mathjax>$\sim 10$</mathjax>. This is quite large, and implies that <mathjax>$\text{NET}$</mathjax> may take on large values due to how we initialized our weights. If <mathjax>$\text{NET}$</mathjax> takes on large values, we may run into saturation problems given an activation function such as sigmoid, which then leads to slow training. Thus, poor weight initialization can lead to slow training.</p>
<p>This is most problematic for deep networks, since they may reduce the gradient signal that flows backwards by too much (in a weaker version of the gradient "killing" effect).</p>
<p>As the number of inputs to a neuron grows, so too will its output's variance. This can be controlled for (calibrated) by scaling its weight vector by the square root of its "fan-in" (its number of inputs), so you should divide the standard multidimensional distribution sampled random vector by <mathjax>$\sqrt{n}$</mathjax>, where <mathjax>$n$</mathjax> is the number of the neuron's inputs. For ReLUs, it is recommended you instead divide by <mathjax>$\sqrt{2/n}$</mathjax>. (<a href="https://cs231n.github.io/neural-networks-2/">Karpathy's CS231n notes</a> provides more detail on why this is.)</p>
<p>An alternative to this fan-in scaling for the uncalibrated variances problem is <em>sparse initialization</em>, which is to set all weights to 0, and then break symmetry by randomly connecting every neuron to some fixed number (e.g. 10) of neurons below it by setting those weights to ones randomly sampled from the standard normal distribution like mentioned previously.</p>
<p>Biases are commonly initialized to be zero, though if using ReLUs, then you can set them to a small value like 0.01 so all the ReLUs fire at the start and are included in the gradient backpropagation update.</p>
<p>Elsewhere it is recommended that ReLU weights should be sampled from zero-mean Gaussian distribution with standard deviation of <mathjax>$\sqrt{\frac{2}{d_\text{in}}}$</mathjax>.</p>
<p>Elsewhere it is recommended that you sample your weights uniformly from <mathjax>$[-b, b]$</mathjax>, where:</p>
<p><mathjax>$$
b = \sqrt{\frac{6}{H_k + H_{k+1}}}
$$</mathjax></p>
<p>where <mathjax>$H_k$</mathjax> and <mathjax>$H_{k+1}$</mathjax> are the sizes of the hidden layers before and after the weight matrix.</p>
<h3>Shuffling &amp; curriculum learning</h3>
<p>Generally you should shuffle your data every training epoch so the network does not become biased towards a particular ordering.</p>
<p>However, there are cases in which your network may benefit from a meaningful ordering of input data; this approach is called <strong>curriculum learning</strong>.</p>
<h3>Gradient noise</h3>
<p>Adding noise from a Gaussian distribution to each update, i.e.</p>
<p><mathjax>$$
g_{t, i} = g_{t, i} + N(0, \sigma^2_t)
$$</mathjax></p>
<p>with variance annealed with the following schedule:</p>
<p><mathjax>$$
\sigma^2_t = \frac{\eta}{(1 + t)^\gamma}
$$</mathjax></p>
<p>has <a href="http://arxiv.org/abs/1511.06807">been shown</a> to make "networks more robust to poor initialization and helps training particularly deep and complex networks. They suspect that the added noise gives the model more chances to escape and find new local minima, which are more frequent for deeper models." (<a href="http://sebastianruder.com/optimizing-gradient-descent/index.html">An overview of gradient descent optimization algorithms, Sebastian Ruder</a>)</p>
<h3>Adversarial examples</h3>
<p>Adding noise to input, such as in the accompanying figure, can throw off a classifier. Few strategies are robust against these tricks, but one approach is to generate these adversarial examples and include them as part of the training set.</p>
<figure><img alt="Adversarial example source" src="../assets/adversarial.png" /><figcaption>Adversarial example <a href="http://www.marekrei.com/blog/26-things-i-learned-in-the-deep-learning-summer-school/">source</a></figcaption>
</figure>
<h3>Gradient Checking</h3>
<p>When you write code to compute the gradient, it can be very difficult to debug. Thus it is often useful to <em>check the gradient</em> by numerically approximating the gradient and comparing it to the computed gradient.</p>
<p>Say our implemented gradient function is <mathjax>$g(\theta)$</mathjax>. We want to check that <mathjax>$g(\theta) = \frac{\partial J(\theta)}{\partial \theta}$</mathjax>.</p>
<p>We choose some <mathjax>$\epsilon$</mathjax>, e.g. <mathjax>$\epsilon = 0.0001$</mathjax>. It should be a small value, but not so small that we run into floating point precision errors.</p>
<p>Then we can numerically approximate the gradient at some scalar value <mathjax>$\theta$</mathjax>:</p>
<p><mathjax>$$
\frac{J(\theta + \epsilon) - J(\theta - \epsilon)}{2 \epsilon}
$$</mathjax></p>
<p>When <mathjax>$\theta$</mathjax> is a vector, as is more often the case, we instead compute:</p>
<p><mathjax>$$
\frac{J(\theta^{(i+)} - J(\theta^{(i-)})}{2 \epsilon}
$$</mathjax></p>
<p>Where:</p>
<ul>
<li><mathjax>$\theta^{(i+)} = \theta + (\epsilon \times e_i)$</mathjax></li>
<li><mathjax>$\theta^{(i-)} = \theta - (\epsilon \times e_i)$</mathjax></li>
<li><mathjax>$e_i$</mathjax> is the <mathjax>$i$</mathjax>th is the basis vector (i.e. it is 0 everywhere except at the <mathjax>$i$</mathjax>th element, where it is 1)</li>
</ul>
<h3>Training tips</h3>
<p>Start training with small, unequal weights to avoid <em>saturating</em> the network w/ large weights. If all the weights start equal, the network won't learn anything.</p>
<ul>
<li>Normalize real-valued data (subtract mean, divide by standard deviation (see part on data preprocessing))</li>
<li>Decrease the learning rate during training</li>
<li>Use minibatches for a more stable gradient (e.g. use stochastic gradient descent)</li>
<li>Use momentum to get through plateaus</li>
</ul>
<h3>Transfer Learning</h3>
<p>The practice of transfer learning involves taking a neural net trained for another task and applying it to a different task. For instance, if using an image classification net trained for one classification task, you can use that same network for another, truncating the output layer, that is, take the vectors from the second-to-last layer and use those as feature vectors for other tasks.</p>
<h2>Network architectures</h2>
<p>The <em>architecture</em> of a neural network describes how its layers are structured - e.g. how many layers there are, how many neurons in each, and how they are connected.</p>
<p>Neural networks are distinguished by their architecture.</p>
<p>The general structure of a neural network is <code>input layer -&gt; 0 or more hidden layers -&gt; output layer</code>.</p>
<p>Neural networks always have one input layer, and the size of that input layer is equal to the input dimensions (i.e. one node per feature), though sometimes you may have an additional bias node.</p>
<p>Neural networks always have one output layer, and the size of that output layer depends on what you're doing. For instance, if your neural network will be a regressor (i.e. for a regression problem), then you'd have a single output node (unless you're doing multivariate regression). Same for binary classification. However with softmax (more than just two classes) you have one output node per class label, with each node outputting the probability the input is of the class associated with the node.</p>
<p>If your data is linearly separable, then you don't need any hidden layers (and you probably don't need a neural network either and a linear or generalized linear model may be plenty).</p>
<p>Neural networks with additional hidden layers become difficult to train; networks with multiple hidden layers are the subject of <em>deep learning</em> (detailed below). For many problems, one hidden layer suffices, and you may not see any performance improvement from adding additional hidden layers.</p>
<p>A rule of thumb for deciding the size of the hidden layer is that the size should be between the size between the input size and output size (for example, the mean of their sizes).</p>
<h2>Overfitting</h2>
<p>Because neural networks can have so many parameters, it can be quite easy for them to overfit. Thus it is something to always keep an eye out for. This is especially a problem for large neural networks, which have huge amounts of parameters.</p>
<p>As the network grows in number of layers and size, the network <em>capacity</em> increases, which is to say it is capable of representing more complex functions.</p>
<figure><img alt="More complex network, more complex functions " src="../assets/layer_sizes.svg" /><figcaption>More complex network, more complex functions </figcaption>
</figure>
<p>Simpler networks have fewer local minima, but they are easier to converge to and tend to perform worse (they have higher loss). There is a great deal of variance across these local minima, so the outcome is quite sensitive to the random initialization - some times you land in a good local minima, sometimes not. More complex networks have more local minima, but they tend to perform better, and there is less variance across how these local minima perform.</p>
<p>Higher-capacity networks run a greater risk of overfitting, but this overfitting can be (preferably) mitigated by other methods such as L2 regularization, dropout, and input noise. So don't let overfitting be the sole reason for going with a simpler network if a larger one seems appropriate.</p>
<p>Here are regularization examples for the same data from the previous image, with the neural net for 20 hidden neurons:</p>
<figure><img alt="Regularization strength" src="../assets/reg_strengths.svg" /><figcaption>Regularization strength</figcaption>
</figure>
<p>As you can see, regularization is effective at counteracting overfitting.</p>
<p>Another simple, but possibly expensive way of reducing overfitting is by increasing the amount of training data - it's unlikely to overfit many, many examples. However, this is seldom a practical option.</p>
<p>Generally, the methods for preventing overfitting include:</p>
<ul>
<li>Get more data, if possible</li>
<li>Limit your model's capacity so that it can't fit the idiosyncrasies of the data you have. With neural networks, this can be accomplished by:</li>
<li>limiting the number of hidden layers and/or number of units per layer</li>
<li>start with small weights and stop learning early (so the weights can't get too large)</li>
<li>weight decay: penalize large weights using penalties on their squared values (L2) or absolute values (L1)</li>
<li>adding Gaussian noise (i.e. <mathjax>$x_i |+ N(0, \sigma_i^2$</mathjax>) to inputs</li>
<li>Average many different models</li>
<li>Use different models with different forms, or</li>
<li>Train model on different subsets of the training data ("bagging")</li>
<li>Use a single neural network architecture, but learn different sets of weights, and average the predictions across these different sets of weights</li>
</ul>
<h3>Regularization</h3>
<p>Regularization techniques are used to prevent neural networks from overfitting.</p>
<h4>L2 Regularization</h4>
<p>L2 regularization is the most common form of regularization. We penalize the squared magnitude of all parameters (weights) as part of the objective function, i.e. we add <mathjax>$\sum \lambda w^2$</mathjax> to the objective function (this additional term is called the <strong>regularization term</strong>, and <mathjax>$\lambda$</mathjax> is an additional hyperparameter, the <strong>regularization parameter</strong>). It is common to include <mathjax>$\frac{1}{2}$</mathjax>, i.e. use <mathjax>$\frac{1}{2} \sum \lambda w^2$</mathjax>, so the gradient of this term wrt to <mathjax>$w$</mathjax> is just <mathjax>$\lambda w$</mathjax> instead of <mathjax>$2 \lambda w$</mathjax>$. This avoids the network relying heavily on a few weights and encourages it to use all weights a little.</p>
<p>L2 regularization is sometimes called <strong>weight decay</strong> since the added regularization term penalizes large weights, favoring smaller weights.</p>
<p>So a regularized cost function <mathjax>$J$</mathjax>, from the original unregularized cost function <mathjax>$J_0$</mathjax>, is simply:</p>
<p><mathjax>$$
J = J_0 + \frac{\lambda}{2m} \sum_w w^2
$$</mathjax></p>
<p>This affects the partial derivative of the cost function with respect to weights in a simple way (again, biases are not included, so it does not change that partial derivative):</p>
<p><mathjax>$$
\frac{\partial J}{\partial w} = \frac{\partial J_0}{\partial w} + \frac{\lambda}{m} w
$$</mathjax></p>
<p>So your update rule would be:</p>
<p><mathjax>$$
w \to w' = \frac{\eta \lambda}{m} - \frac{\eta}{m} \sum_i^m \frac{\partial J_i}{\partial w}
$$</mathjax></p>
<p>Note that biases are typically not included by convention; regularizing them usually does not have an impact on the network's generalizability.</p>
<h4>L1 Regularization</h4>
<p>Similar to L2 regularization, except that the regularization term added to the objective function is <mathjax>$\sum \lambda |w|$</mathjax>; that is, the sum of the absolute values of the weights with a regularization parameter <mathjax>$\lambda$</mathjax>.</p>
<p>The main difference between L1 and L2 regularization is that L1 regularization shrinks weights by a constant amount, whereas L2 regularization shrinks weights by an amount proportional to the weights themselves. This is made clearer by considering the derived update rules from gradient descent.</p>
<p>L1 regularization has the effect of causing weight vectors to become sparse, such that neurons only use a few of their inputs and ignore the rest as "noise". Generally L2 regularization is preferred to L1.</p>
<p>For L1, this partial derivative of the cost function wrt the weights is:</p>
<p><mathjax>$$
\frac{\partial J}{\partial W^N} = \frac{\partial J_0}{\partial W^N} + \frac{\lambda}{m} \text{sign}(W^N)
$$</mathjax></p>
<p>This ends up leading to the following update rule:</p>
<p><mathjax>$$
w \to w' = w - \frac{\eta \lambda}{m}\text{sign}(w) - \frac{\eta}{m} \sum_i^m \frac{\partial J_i}{\partial w}
$$</mathjax></p>
<p>Note that we say that <mathjax>$\text{sign}(0) = 0$</mathjax>.</p>
<p>Compare this with the update rule for L2 regularization:</p>
<p><mathjax>$$
w \to w' = w - \frac{\eta \lambda}{m}w - \frac{\eta}{m} \sum_i^m \frac{\partial J_i}{\partial w}
$$</mathjax></p>
<p>In L2 regularization, we subtract a term weighted by <mathjax>$w$</mathjax>, whereas in L1 regularization, the subtracted term is affected only by the sign of <mathjax>$w$</mathjax>.</p>
<h4>Elastic net regularization</h4>
<p>This is just the combination of L1 and L2 regularization, such that the term introduced to the objective function is <mathjax>$\sum \lambda_1 |w| + \lambda_2 w^2$</mathjax>.</p>
<h4>Max norm constraints</h4>
<p>This involves setting an absolute upper bound on the magnitude of the weight vectors; that is, after updating the parameters/weights, clamp every weight vector so that it satisfies <mathjax>$||w||_2 &lt; c$</mathjax>, where <mathjax>$c$</mathjax> is some constant (the maximum magnitude).</p>
<h4>Dropout</h4>
<p>Dropout is a regularization method which works well with the others mentioned so far (L1, L2, maxnorm). It does not involve modifying cost functions. Rather, the network itself is modified.</p>
<p>During training, we specify a probability <mathjax>$p$</mathjax>. At the start of each training epoch, we only keep a neuron active with that probability <mathjax>$p$</mathjax>, otherwise we set its output to zero. If the neuron's output is set to 0, that has the effect of temporarily "removing" that neuron for that training iteration. At the end of the epoch, all neurons are restored.</p>
<p>This dropout is applied only at training time and applied per-layer (that is, it is applied after each layer, see the code example below). This prevents the network from relying too much on certain neurons.</p>
<p>One way to think about this is that, for each training step, a sub-network is sampled from the full network, and only those parameters are updated. Then on the next step, a different sub-sample is taken and updated, and so on.</p>
<p>To put it another way, dropping out neurons in this way has the effect of training multiple neural networks simultaneously. If we have multiple networks overfit to different training data, they are unlikely to all overfit in the same way. So their average should provide better results.</p>
<p>This has the additional advantage that neurons must learn to operate in the absence of other neurons, which can have the effect of the network learning more robust features. That is, the neurons of the network should be more resilient to the absence of some information.</p>
<figure><img alt="A network after dropout is applied to each layer in a training iteration source" src="../assets/dropout.jpeg" /><figcaption>A network after dropout is applied to each layer in a training iteration <a href="https://cs231n.github.io/neural-networks-2/">source</a></figcaption>
</figure>
<p>At test time, all neurons are active (i.e. we don't use dropout at test time). There will be twice as many hidden neurons active as there were in training, so all weights are halved to compensate.</p>
<p>We must scale the activation functions by <mathjax>$p$</mathjax> to maintain the same expected output for each neuron. Say <mathjax>$x$</mathjax> is the output of a neuron without dropout. With dropout, the neuron's output has a chance <mathjax>$p$</mathjax> of being set to 0, so its expected output becomes <mathjax>$px$</mathjax> (more verbosely, it has <mathjax>$1-p$</mathjax> chance of becoming 0, so its output is <mathjax>$px + (1-p)0$</mathjax>, which simplifies to <mathjax>$px$</mathjax>). Thus we must scale the outputs (i.e. the activation functions) by <mathjax>$p$</mathjax> to keep the expected output consistent.</p>
<p>This scaling can be applied at training time, which is more efficient - this technique is called <em>inverted dropout</em>.</p>
<p>For comparison, here is an implementation of regular dropout and an implementation of inverted dropout (source from: <a href="https://cs231n.github.io/neural-networks-2/">https://cs231n.github.io/neural-networks-2/</a>)</p>
<pre><code># Dropout
p = 0.5 # probability of keeping a unit active. higher = less dropout

def train_step(X):
  """ X contains the data """

  # forward pass for example 3-layer neural network
  H1 = np.maximum(0, np.dot(W1, X) + b1)
  U1 = np.random.rand(*H1.shape) &lt; p # first dropout mask
  H1 *= U1 # drop!
  H2 = np.maximum(0, np.dot(W2, H1) + b2)
  U2 = np.random.rand(*H2.shape) &lt; p # second dropout mask
  H2 *= U2 # drop!
  out = np.dot(W3, H2) + b3

  # backward pass: compute gradients... (not shown)
  # perform parameter update... (not shown)

def predict(X):
  # ensembled forward pass
  H1 = np.maximum(0, np.dot(W1, X) + b1) * p # NOTE: scale the activations
  H2 = np.maximum(0, np.dot(W2, H1) + b2) * p # NOTE: scale the activations
  out = np.dot(W3, H2) + b3

# Inverted dropout
p = 0.5 # probability of keeping a unit active. higher = less dropout

def train_step(X):
  # forward pass for example 3-layer neural network
  H1 = np.maximum(0, np.dot(W1, X) + b1)
  U1 = (np.random.rand(*H1.shape) &lt; p) / p # first dropout mask. Notice /p!
  H1 *= U1 # drop!
  H2 = np.maximum(0, np.dot(W2, H1) + b2)
  U2 = (np.random.rand(*H2.shape) &lt; p) / p # second dropout mask. Notice /p!
  H2 *= U2 # drop!
  out = np.dot(W3, H2) + b3

  # backward pass: compute gradients... (not shown)
  # perform parameter update... (not shown)

def predict(X):
  # ensembled forward pass
  H1 = np.maximum(0, np.dot(W1, X) + b1) # no scaling necessary
  H2 = np.maximum(0, np.dot(W2, H1) + b2)
  out = np.dot(W3, H2) + b3
</code></pre>
<h4>Regularization recommendations</h4>
<blockquote>
<p>It is most common to use a single, global L2 regularization strength that is cross-validated. It is also common to combine this with dropout applied after all layers. The value of <mathjax>$p=0.5$</mathjax> is a reasonable default, but this can be tuned on validation data. <a href="https://cs231n.github.io/neural-networks-2/">https://cs231n.github.io/neural-networks-2/</a></p>
</blockquote>
<h3>Artificially expanding the training set</h3>
<p>In addition to regularization, training on more data can help prevent overfitting. This, unfortunately, is typically not a practical option. However, the training set can be artificially expanded by taking existing training data and modifying it in a way we'd expect to see in the real world.</p>
<p>For instance, if we were training a network to recognize handwritten digits, we may take our examples and rotate them slightly, since this could plausibly happen naturally.</p>
<p>A related technique is training on adversarial examples (detailed elsewhere), in which training examples are modified to be deliberately hard for the network to classify, so that it can be trained on more ambiguous/difficult examples.</p>
<p>The most common approach to dealing with overfitting is to apply some kind of regularization.</p>
<h2>Hyperparameters</h2>
<p>There are many hyperparameters to set with neural networks, such as:</p>
<ul>
<li>architecture decisions<ul>
<li>number of layers</li>
<li>number of units per layer</li>
<li>type of unit</li>
<li>etc</li>
</ul>
</li>
<li>weight penalty</li>
<li>learning rate</li>
<li>momentum</li>
<li>whether or not to use dropout</li>
<li>etc</li>
</ul>
<h3>Choosing hyperparameters</h3>
<p>TODO See: <a href="https://cs231n.github.io/neural-networks-3/#anneal">https://cs231n.github.io/neural-networks-3/#anneal</a></p>
<p>Not only are there many hyperparameters for neural networks; it can also be very difficult to choose good ones.</p>
<p>You could do a naive grid search and just try all possible combinations of hyperparameters, which is infeasible because it blows up in size.</p>
<p>You could randomly sample combinations as well, but this still has the problem of repeatedly trying hyperparameter values which may have no effect.</p>
<p>Instead, we can apply machine learning to this problem and try and learn what hyperparameters may perform well based on the attempts thus far. In particular, we can try and predict regions in the hyperparameter space that might do well. We'd want to also be able to be explicit about the uncertainty in our prediction.</p>
<p>We can use Gaussian process models to do so. The basic assumption of these models is that similar inputs give similar outputs.</p>
<p>However, what does "similar" mean? Is 200 hidden units "similar" to 300 hidden units or not? Fortunately, such models can also learn this scale of similarity for each hyperparameter.</p>
<p>These models predict a Gaussian distribution of values for each hyperparameter (hence the name).</p>
<p>A method for applying this:</p>
<ul>
<li>keep track of the best hyperparameter combination so far</li>
<li>pick a new combination of hyperparameters such that the expected improvement of the best combination is big</li>
</ul>
<p>So we might try a new combination, and it might not do that well, but we won't have replaced our current best.</p>
<p>This method for selecting hyperparameters is called <em>Bayesian (hyperparameter) optimization</em>, and is a better approach than by picking hyperparameters by hand (less prone to human error).</p>
<h3>Tweaking hyperparameters</h3>
<p>A big challenge in designing a neural network is calibrating its hyperparameters. From the start, it may be difficult to intuit what hyperparameters need tuning. There are so many to choose from: network architecture, number of epochs, cost function, weight initialization, learning rate, etc.</p>
<p>There are a few heuristics which may help.</p>
<p>When the learning rate <mathjax>$\eta$</mathjax> is set too high, you typically see constant oscillation in the error rate as the network trains. This is because with too large a learning rate, you may miss the minimum in the error surface by "jumping" too far. Thus once you see this occurring, it's a hint to try a lower learning rate.</p>
<p>Learning rates which are too low tend to have a slow decrease in error over training. You can try higher learning rates if this seems to be the case.</p>
<p>The learning rate does not need to be fixed. When starting out training, you may want a high learning rate to quickly get close to a minimum. But once you get closer, you may want to decrease the learning rate to carefully identify the best minimum.</p>
<p>The specification of how the learning rate decreases is called the <strong>learning rate schedule</strong>.</p>
<p>Some places recommend using a learning rate in the form:</p>
<p><mathjax>$$
\eta_t = \eta_0 (1 + \eta_0 \lambda t)^{-1}
$$</mathjax></p>
<p>Where <mathjax>$\eta_0$</mathjax> is the initial learning rate, <mathjax>$\eta_t$</mathjax> is the learning rate for the <mathjax>$t$</mathjax>th example, and <mathjax>$\lambda$</mathjax> is another hyperparameter.</p>
<p>For the number of epochs, we can use a strategy called "early stopping", where we top once some performance metric (e.g. classification accuracy) appears to stop improving. More precisely, "stop improving" can mean when the performance metric doesn't improve for some <mathjax>$n$</mathjax> epochs.</p>
<p>However, neural networks sometimes plateau for a little bit and then keep on improving. In which case, adopting an early stopping strategy can be harmful. You can be somewhat conservative and set <mathjax>$n$</mathjax> to a higher value to play it safe.</p>
<h2>Deep neural networks</h2>
<p>A <em>deep neural network</em> is simply a neural network with more than one hidden layer. <em>Deep learning</em> is the field related to deep neural networks. These deep networks can perform much better than shallow networks (networks with just one hidden layer) because they can embody a complex hierarchy of concepts.</p>
<p>Many problems can be broken down into subproblems, each of which can be addressed by a separate neural network.</p>
<p>Say for example we want to know whether or not a face is in an image. We could break that down (<em>decompose</em> it) into subproblems like:</p>
<ul>
<li>is there an eye?</li>
<li>is there an ear?</li>
<li>is there a nose?</li>
<li>etc.</li>
</ul>
<p>We could train a neural network on each of these subproblems. We could even break these subproblems further (e.g. "Is there an eyelash?", "Is there an iris?", etc) and train neural networks for those, and so on.</p>
<p>Then if we want to identify a face, we can aggregate these networks into a larger network.</p>
<p>This kind of multi-layered neural net is a <em>deep neural network</em>.</p>
<p>Multilayer nns must have nonlinear activation functions, otherwise they are equivalent to a single layer network aggregating its weights.</p>
<p>That is, a 2 layer network has weight vectors <mathjax>$W_1$</mathjax> and <mathjax>$W_2$</mathjax> and input X. The network computes <mathjax>$(XW_1)W_2$</mathjax>, which is equivalent to <mathjax>$X(W_1W_2)$</mathjax>, so the network is equivalent to a single layer network with weight vectors <mathjax>$W_1W_2$</mathjax></p>
<p>Training deep neural networks (that is, neural networks with more than one hidden layer) is not as straightforward as it is with a single hidden layer - a simple stochastic gradient descent + backpropagation approach is not as effective or quick.</p>
<p>This is because of <strong>unstable gradients</strong>. This has two ways of showing up:</p>
<ul>
<li><strong>Vanishing gradients</strong>, in which the gradient gets smaller moving backwards through the hidden layers, such that earlier layers learn very slowly (and may not learn at all).</li>
<li><strong>Exploding gradients</strong>, in which the gradient gets much larger moving backwards through the hidden layers, such that earlier layers cannot find good parameters.</li>
</ul>
<p>These unstable gradients occur because gradients in earlier layers are the products of the later layers (refer to backpropagation for details, but remember that the <mathjax>$\delta^i$</mathjax> for layer <mathjax>$i$</mathjax> is computed from <mathjax>$\delta^{i+1}$</mathjax>). Thus if these later terms are mostly <mathjax>$&lt; 1$</mathjax>, we will have a vanishing gradient. If these later terms are <mathjax>$&gt; 1$</mathjax>, they can get very large and lead to an exploding gradient.</p>
<h3>Unstable gradients</h3>
<p>Certain neural networks, such as RNNs, can have <strong>unstable gradients</strong>, in which gradients may grow exponentially (an <strong>exploding gradient</strong>) or shrink exponentially until it reaches zero (a <strong>vanishing gradient</strong>).</p>
<p>With exploding gradients, the minimum is not found because, with such a large gradient, the steps don't effectively search the space.</p>
<p>With vanishing gradients, the minimum is not found because a gradient of zero means the space isn't searched at all.</p>
<p>Unstable gradients can occur as a result of drastic changes in the cost surface, as illustrated in the accompanying figure (from <a href="http://www.jmlr.org/proceedings/papers/v28/pascanu13.pdf">Pascanu et al</a> via <a href="http://peterroelants.github.io/posts/rnn_implementation_part01/">http://peterroelants.github.io/posts/rnn_implementation_part01/</a>).</p>
<figure><img alt="" src="../assets/exploding_gradient.png" /><figcaption></figcaption>
</figure>
<p>In the figure, the large jump in cost leads to a large gradient which causes the optimizer to make an exaggerated step.</p>
<p>There are methods for dealing with unstable gradients, including:</p>
<ul>
<li>Gradient clipping (e.g. limiting <mathjax>$g$</mathjax> to <mathjax>$g = \frac{t}{||g||_2}$</mathjax> if <mathjax>$||g||_2 &gt; t$</mathjax>, where <mathjax>$t$</mathjax> is some clipping threshold)</li>
<li>Hessian-Free Optimization</li>
<li>Momentum</li>
<li>Resilient backpropagation (Rprop)</li>
</ul>
<h4>Resilient backpropgation (Rprop)</h4>
<p>Normally, weights are updated by the size of the gradient (typically scaled by some learning rate). However, as demonstrated above, this can lead to an unstable gradient.</p>
<p>Resilient backpropagation ignores the size of the gradient and only considers its sign and then uses two hyperparameters, <mathjax>$\eta^-, \eta^+$</mathjax> (<mathjax>$\eta^+ &gt; 1$</mathjax>) to determine the size of the update. <mathjax>$\eta^-$</mathjax>.</p>
<p>If the sign of the gradient changes in an iteration, the weight update <mathjax>$\Delta$</mathjax> is multiplied by <mathjax>$\eta^-$</mathjax>, i.e. <mathjax>$\Delta = \Delta \eta^-$</mathjax>. If the gradient's sign doesn't change, the weight update <mathjax>$\Delta$</mathjax> is multiplied by <mathjax>$\eta^+$</mathjax>, i.e. <mathjax>$\Delta = \Delta \eta^+$</mathjax>.</p>
<p>If the gradient's sign changes, this usually indicates that we have passed through a local minima.</p>
<p>Then the weight is updated by this computed value in the opposite direction of its gradient:</p>
<p><mathjax>$$
W \to W' = W - \text{sign}(\frac{\partial J}{\partial W}) \Delta
$$</mathjax></p>
<p>Typically, <mathjax>$\eta^+ = 1.2, \eta^- = 0.5$</mathjax>.</p>
<p>This is essentially separate adaptive learning rates but ignoring the size of the gradient and only look at the sign. That is, we increase weights multiplicatively by <mathjax>$\eta^+$</mathjax> if the last two gradient signs agree, otherwise, we decrease the step size multiplicatively by <mathjax>$\eta^-$</mathjax>. As with separate adaptive learning rates, we generally want to limit the range of step sizes so that it can't be too small or too large.</p>
<p>Rprop is meant for full batch learning or for very large mini-batches. To use this technique with mini-batches, see Rmsprop.</p>
<h3>Rmsprop</h3>
<p><strong>Rmsprop</strong> is the mini-batch version of Rprop. It computes a moving average, <mathjax>$\text{MA}$</mathjax>, of the squared gradient for each parameter:</p>
<p><mathjax>$$
\text{MA} = \lambda \text{MA} + (1 - \lambda)(\frac{\partial J}{\partial W})^2
$$</mathjax></p>
<p>Then normalizes the gradient by dividing by the square root of this moving average:</p>
<p><mathjax>$$
\frac{\partial J}{\partial W} \frac{1}{\sqrt{\text{MA}}}
$$</mathjax></p>
<p>Rmsprop can be used with momentum as well (i.e. update the velocity with this modified gradient).</p>
<blockquote>
<p>The basic idea behind rmsprop is to adjust the learning rate per-parameter according to the (smoothed) sum of the previous gradients. Intuitively this means that frequently occurring features get a smaller learning rate (because the sum of their gradients is larger), and rare features get a larger learning rate. <a href="http://www.wildml.com/2015/10/recurrent-neural-network-tutorial-part-4-implementing-a-grulstm-rnn-with-python-and-theano/">http://www.wildml.com/2015/10/recurrent-neural-network-tutorial-part-4-implementing-a-grulstm-rnn-with-python-and-theano/</a></p>
</blockquote>
<h2>Convolutional Neural Networks (CNNs)</h2>
<p>In a regular neural network, the relationship between a pixel and one that is next to it is the same as its relationship with a pixel far away - the structural information of the image is totally lost. Convolutional nets are capable of encoding this structural information about the image; as a result, they are especially effective with image-based tasks.</p>
<p>Convolutional nets are based on three ideas:</p>
<ul>
<li>local receptive fields</li>
<li>shared weights</li>
<li>pooling</li>
</ul>
<h3>Local receptive fields</h3>
<p>A regular neural network is <em>fully-connected</em> in that every node from a layer <mathjax>$i$</mathjax> is connected to each node in the layer <mathjax>$i+1$</mathjax>.</p>
<p>This is not the case with convolutional nets.</p>
<p>Typically we think of a layer as a line of neurons. With convolutional nets, it is more useful to think of the neurons arranged in a grid.</p>
<p>(Note: the following images are from <a href="http://neuralnetworksanddeeplearning.com/chap6.html">http://neuralnetworksanddeeplearning.com/chap6.html</a> TODO replace the graphics)</p>
<figure><img alt="A layer as a grid" src="../assets/conv_net_01.png" /><figcaption>A layer as a grid</figcaption>
</figure>
<p>We do <em>not</em> fully connect this input layer to the hidden layer (which we'll call a <strong>convolutional layer</strong>). Rather, we connect regions of neurons to neurons in the hidden layer. These regions are <strong>local receptive fields</strong>, local to the neuron at their center (they may more simply be called <em>windows</em>).</p>
<figure><img alt="Local receptive fields map to a neuron in the hidden layer" src="../assets/conv_net_02.png" /><figcaption>Local receptive fields map to a neuron in the hidden layer</figcaption>
</figure>
<p>We can move across local receptive fields one neuron at a time, or in greater movements. These movements are called the <strong>stride length</strong>.</p>
<figure><img alt="Moving across fields at a stride length of 1" src="../assets/conv_net_03.png" /><figcaption>Moving across fields at a stride length of 1</figcaption>
</figure>
<p>These windows end up learning to detect salient features, but are less sensitive to where exactly they occur. For instance, for recognizing a human face, it may be important that we see an eye in one region, but it doesn't have to be in a particular exact position. A <strong>filter</strong> (also called a <strong>kernel</strong>) function is applied to each window to transform it into another vector (which is then passed to a pooling layer, see below).</p>
<p>One architectural decision with CNNs is the use of <strong>wide convolution</strong> or <strong>narrow convolution</strong>. When you reach the edges of your input (say, the edges of an image), do you stop there or do you pad the input with zeros (or some other value) so we can fit another window? Padding the input is wide convolution, not padding is narrow convolution. Note that, as depicted above, narrow convolution will yield a smaller feature map of size: input shape - filter shape + 1.</p>
<p>Note that this hyperparameter is sometimes called "border mode". A border mode of "valid" is equivalent to a narrow convolution.</p>
<p>There are a few different ways of handling padding for a wide convolution. Border modes of "half" (also called "same") and "full" correspond to different padding strategies.</p>
<p>Say we have a filter of size <mathjax>$r \times c$</mathjax> (where <mathjax>$r$</mathjax> is rows and <mathjax>$c$</mathjax> is columns). For a border mode of "half"/"same", we pad the input with a symmetric border of <mathjax>$r//2$</mathjax> rows and <mathjax>$c//2$</mathjax> columns (where <mathjax>$//$</mathjax> indicates integer division). When <mathjax>$r$</mathjax> and <mathjax>$c$</mathjax> are both odd, the feature map has the same shape as the input.</p>
<p>There is also a "full" border mode which pads the input with a symmetric border of <mathjax>$r-1$</mathjax> rows and <mathjax>$c-1$</mathjax> columns. This is equivalent to applying the filter anywhere it overlaps with a pixel and yields a feature map of size: input shape + filter shape - 1.</p>
<p>For example, say we have the following image:</p>
<div class="highlight"><pre>xxx
xxx
xxx
</pre></div>


<p>Say we have a 3x3 filter.</p>
<p>For a border mode of "half"/"same", we the padded image would look like (padding is indicated with <code>o</code>):</p>
<div class="highlight"><pre>ooooo
oxxxo
oxxxo
oxxxo
ooooo
</pre></div>


<p>For a border mode of "full", the padded image would instead be:</p>
<div class="highlight"><pre>ooooooo
ooooooo
ooxxxoo
ooxxxoo
ooxxxoo
ooooooo
ooooooo
</pre></div>


<h3>Shared weights</h3>
<p>Another change here is that the hidden layer has one set of weights and a bias that is shared across the entire layer (these weights and biases are accordingly referred to as <em>shared weights</em> and the <em>shared bias</em>, and together, they define a <strong>filter</strong> or a <strong>kernel</strong>).</p>
<p>As a result, if we have receptive fields of <mathjax>$m \times m$</mathjax> size, the output of the <mathjax>$i,j$</mathjax>th neuron in the hidden layer looks like:</p>
<p><mathjax>$$
f(b + \sum^{m-1}_{k=0} \sum^{m-1}_{l=0} W_{k,l} \text{OUT}^0_{i+k,j+l})
$$</mathjax></p>
<p>Where <mathjax>$W \in \mathbb R^{m \times m}$</mathjax> is the array of shared weights and <mathjax>$\text{OUT}^0_{x,y}$</mathjax> is the output of the input neuron at position <mathjax>$x,y$</mathjax>.</p>
<p>Another way of writing the above is:</p>
<p><mathjax>$$
f(b + W * \text{OUT}^0)
$$</mathjax></p>
<p>Where <mathjax>$*$</mathjax> is the <em>convolution operator</em>, which is like a blurring/mixing of functions. In this context, it is basically a weighted sum.</p>
<p>The consequence of this sharing of weights and biases is that this layer detects the same feature across different receptive fields. For example, this layer could detect vertical edges anywhere in the image. If an edge shows up in the upper-right part of the image, the corresponding input neuron for that receptive field will fire. If an edge shows up in the lower-left part of the image, the corresponding input neuron for that receptive field will also fire, due to the fact that they all share weights and a bias.</p>
<p>As a result of this property, this mapping between layers is often called a <strong>feature map</strong>. Technically, the kernel/filter <em>output</em> a feature map, which is to say they are not the same thing, but in practice the terms "kernel" and "filter" are often used interchangeably with "feature map".</p>
<p>For example, say we have a 3x3 filter:</p>
<p><mathjax>$$
\begin{bmatrix}
0, 0, 0 \\
0, 0, 0 \\
0, 0, 0
\end{bmatrix}
$$</mathjax></p>
<p>Each position in the filter is a weight to be learned; here we have initialized them to 0 (not necessarily the best choice, but this is just an example).</p>
<p>Each position in the filter lines up with a pixel as the filter slides across the image (as depicted above)</p>
<p>Let's say that the weights learned by the filter end up being the following:</p>
<p><mathjax>$$
\begin{bmatrix}
-1, -1, -1 \\
-1, 10, -1 \\
-1, -1, -1
\end{bmatrix}
$$</mathjax></p>
<p>Then say we place the filter over the following patch of pixels:</p>
<p><mathjax>$$
\begin{bmatrix}
0, 0, 0 \\
0, 255, 0 \\
0, 0, 0
\end{bmatrix}
$$</mathjax></p>
<p>We want to combine (i.e. mix) the filter and the pixel values to produce a single pixel value (which will be a single pixel in the resulting feature map). We do so by convolving them as the sum of the element-wise product:</p>
<p><mathjax>$$
(-1 \times 0) + (-1 \times 0) + (-1 \times 0) +
(-1 \times 0) + (10 \times 255) + (-1 \times 0) +
(-1 \times 0) + (-1 \times 0) + (-1 \times 0)
$$</mathjax></p>
<p>Pixel-by-pixel the feature map is produced in this way.</p>
<p>We may include multiple feature maps/filters, i.e. have the input connect to many hidden layers of this kind (this is typically how it's done in practice). Each layer would learn to detect a different feature.</p>
<p>Another benefit to sharing weights and biases across the layer is that it introduces some resilience to overfitting - the sharing of weights means that the layer cannot favor peculiarities in particular parts of the training data; it must take the whole example into account. As a result, regularization methods are seldom necessary for these layers.</p>
<h3>Pooling layers</h3>
<p>In addition to convolutional layers there are also <strong>pooling layers</strong>, which often accompany convolutional layers (often one per convolutional layer) and follow after them. Pooling layers produced a condensed version of the feature map they are given (for this reason, this process is also known as <em>subsampling</em>, so pooling layers are sometimes called <em>subsampling layers</em>). For example, a <mathjax>$2 \times 2$</mathjax> neuron region of the feature map may be represented with only one neuron in the pooling layer.</p>
<figure><img alt="Mapping from feature map to a pooling layer" src="../assets/conv_net_04.png" /><figcaption>Mapping from feature map to a pooling layer</figcaption>
</figure>
<p>There are a few different strategies for how this compression works. A common one is <strong>max-pooling</strong>, in which the pooling neuron just outputs the maximum value of its inputs. In some sense, max-pooling asks its region: was your feature present? And activates if it was. It isn't concerned with where in that region the feature was, since in practice, its precise location doesn't matter so much as its relative positioning to other features (especially with images).</p>
<p>Another pooling technique is <strong>L2 pooling</strong>. Say a pooling neuron has an <mathjax>$m \times m$</mathjax> input region of neurons coming from the layer <mathjax>$i$</mathjax>. Then it's output is:</p>
<p><mathjax>$$
\sqrt{\sum^{m-1}_{j=0} \sum^{m-1}_{k=0} (\text{OUT}^i_{j,k})^2}
$$</mathjax></p>
<p>Another pooling technique is <strong>average-pooling</strong> in which the average value of the input is output.</p>
<p>There is also the <strong><mathjax>$k$</mathjax>-max pooling</strong> method, which takes the top <mathjax>$k$</mathjax> values in each dimension, instead of just the top value as is with max-pooling. The result is a matrix rather than a vector.</p>
<h3>Network architecture</h3>
<p>Generally, we have many feature maps (convolutional layers) and pooling layer pairs grouped together; conceptually it is often easier to think of these groups themselves as layers (called "convolutional-pooling layers").</p>
<figure><img alt="An example convolutional network" src="../assets/conv_net_05.png" /><figcaption>An example convolutional network</figcaption>
</figure>
<p>The output layer is fully-connected (i.e. every neuron from the convolutional-pooling layer are connected to every neuron in the output layer).</p>
<p>Often it helps to include another (or more) fully-connected layer just prior to the output layer. This can be thought of as aggregating and considering all the features coming from the convolutional-pooling layer.</p>
<p>It is also possible to insert additional convolutional-pooling layers (this practice is called <strong>hierarchical pooling</strong>). Conceptually, these take the features output by the previous convolutional-pooling layer and extract higher-level features. The way these convolutional-pooling layers connect to each other is a little different. Each of this new layer's input neurons (that is, the neurons in its first set of convolutional layers) takes as its input <em>all</em> of the outputs (within its local receptive field) from the preceding convolutional-pooling layer.</p>
<p>For example, if the preceding convolutional-pooling layer has 20 layers in it, and we have receptive fields of size <mathjax>$5 \times 5$</mathjax>, then each of the input neurons for the new convolutional-pooling layer would have <mathjax>$20 \times 5 \times 5$</mathjax> inputs.</p>
<h3>Training CNNs</h3>
<p>Backpropagation is slightly different for a convolutional net because the typical backpropagation assumes fully-connected layers.</p>
<p>TODO add this</p>
<h3>Convolution kernels</h3>
<p>CNNs learn a <em>convolution kernel</em> and (for images) apply it to every pixel across the image:</p>
<figure><img alt="Convolution kernel example source" src="../assets/kernel_convolution.jpg" /><figcaption>Convolution kernel example <a href="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/ConvolutionOperations/ConvolutionOperations.html">source</a></figcaption>
</figure>
<h2>Recurrent Neural Networks (RNNs)</h2>
<p>A <em>recurrent neural network</em> is a <em>feedback</em> neural network, that is, it is a neural net where the outputs of neurons are fed back into their inputs. They have properties which give them advantages over feed-forward NNs for certain problems. In particular, RNNs are well-suited for handling <em>sequences</em> as input.</p>
<p>With machine learning, data is typically represented in vector form. This works for certain kinds of data, such as numerical data, but not necessarily for other kinds of data, like text. We usually end up coercing text into some vector representation (e.g. TF-IDF) and end up losing much of its structure (such as the order of words). This is ok for some tasks (such as topic detection), but for many others we are throwing out important information. We could use bigrams or trigrams or so on to preserve some structure but this becomes unmanageably large (we end up with very high-dimension vectors).</p>
<p>Recurrent neural networks are able to take <em>sequences</em> as input, i.e. iterate over a sequence, instead of fixed-size vectors, and as such can preserve the sequential structure of things like text and have a stronger concept of "context".</p>
<p>Basically, an RNN takes in each item in the sequence and updates a hidden representation (its state) based on that item and the hidden representation from the previous time step. If there is no previous hidden representation (i.e. we are looking at the first item in the sequence), we can initialize it as either all zeros or treat the initial hidden representation as another parameter to be learned.</p>
<p>Another way of putting this is that the core difference of an RNN from a regular feedforward network is that the output of a neuron is a function of its inputs <em>and</em> of its past state, e.g.</p>
<p><mathjax>$$
\text{OUT}_t = f(\text{OUT}_{t-1} W_r + X_t W_x)
$$</mathjax></p>
<p>Where <mathjax>$W_r$</mathjax> are the <strong>recursive weights</strong>.</p>
<h3>Network architecture</h3>
<p>In the most basic RNN, the hidden layer have two inputs: the input from the previous layer, and the layer's own output from the previous time step (so it loops back onto itself):</p>
<figure><img alt="Simple RNN network, with hidden nodes looping source" src="../assets/rnn_1.png" /><figcaption>Simple RNN network, with hidden nodes looping <a href="http://www.hexahedria.com/2015/08/03/composing-music-with-recurrent-neural-networks/">source</a></figcaption>
</figure>
<p>This simple network can be visualized over time as well:</p>
<figure><img alt="Simple RNN network, with hidden nodes looping over time source" src="../assets/rnn_2.png" /><figcaption>Simple RNN network, with hidden nodes looping over time <a href="http://www.hexahedria.com/2015/08/03/composing-music-with-recurrent-neural-networks/">source</a></figcaption>
</figure>
<p>Say we have a hidden layer <mathjax>$L_1$</mathjax> of size 3 and another hidden layer <mathjax>$L_2$</mathjax> of size 2. In a regular NN, the input to <mathjax>$L_2$</mathjax> is of size 3 (because that's the output size of <mathjax>$L_1$</mathjax>). In an RNN, <mathjax>$L_2$</mathjax> would have 3+2 inputs, 3 from <mathjax>$L_1$</mathjax>, and 2 from its own previous output.</p>
<p>This simple feedback mechanism offers a kind of short-term memory - the network "remembers" the output from the previous time step.</p>
<p>It also allows for variable-sized inputs and outputs - the inputs can be fed in one at a time and combined by this feedback mechanism.</p>
<h3>RNN inputs</h3>
<p>The input item can be represented with <em>one-hot encoding</em>, i.e. each term is to a vector of all zeroes and one 1. For example, if we had the vocabulary <mathjax>$\\{\text{the}, \text{mad}, \text{cat} \\}$</mathjax>, the terms might be respectively represented as <mathjax>$[1,0,0], [0,1,0], [0,0,1]$</mathjax>.</p>
<p>Another way to represent these terms is with an <em>embedding matrix</em>, in which each term is mapped to some index of the matrix which points to some <mathjax>$n$</mathjax>-dimensional vector representation. So the RNN learns vector representations for each term.</p>
<p>Convolutional neural networks, and feed-forward neural networks in general, treat an input the same no matter when they are given it. For RNNs, the hidden representation is like (short-term) "memory" for the network, so context is taken into account for inputs; that is, an input will be treated differently depending on what the previous input(s) was/were.</p>
<h3>Training RNNs</h3>
<p>(Note that RNNs train very slowly on CPUs; they train significantly faster on GPUs.)</p>
<p>RNNs are trained using a variant of backpropagation called <strong>backpropagation through time</strong>, which just involves unfolding the RNN a certain number of time steps, which results in what is essentially a regular feedforward network, and then applying backpropagation:</p>
<p><mathjax>$$
\frac{\partial E}{\partial \text{OUT}_{t-1}} = \frac{\partial E}{\partial \text{OUT}_t} \frac{\partial \text{OUT}_t}{\partial \text{OUT}_{t-1}} = \frac{\partial E}{\partial \text{OUT}_t}W_r
$$</mathjax></p>
<p>which starts with:</p>
<p><mathjax>$$
\frac{\partial E}{\partial y} = \frac{\partial E}{\partial \text{OUT}_n}
$$</mathjax></p>
<p>Where <mathjax>$\text{OUT}_n$</mathjax> is the output of the last layer.</p>
<p>The gradients of the cost function wrt to the weights is computed by summing the weight gradients in each layer:</p>
<p><mathjax>$$
\begin{aligned}
\frac{\partial E}{\partial W_x} &amp;= \sum^n_{k=0} \frac{\partial E}{\partial \text{OUT}_t} X_t \\
\frac{\partial E}{\partial W_r} &amp;= \sum^n_{k=1} \frac{\partial E}{\partial \text{OUT}_t} \text{OUT}_{t-1}
\end{aligned}
$$</mathjax></p>
<p>This summing of the weight gradients at each time step is the main difference from regular feedforward networks, aside from that BPTT is basically just backpropagation on an RNN unrolled up to some time step <mathjax>$t$</mathjax>.</p>
<p>However, if working with long sequences, this is effectively like training a deep network with many hidden layers (i.e. this is equivalent to an unrolled RNN), which can be difficult (due to vanishing or exploding gradients). In practice, it's common to truncate the backpropagation by running it for only to a few time steps back.</p>
<p>The vanishing gradient problem in RNNs means long-term dependencies won't be learned - the effect of earlier steps "vanish" over time steps (this is the same problem of vanishing gradients in deep feedforward networks, given that an RNN is basically a deep neural net).</p>
<p>Exploding gradients are more easily dealt with - it's obvious when they occur (you'll see <code>NaN</code>s, for instance), and you can clip them at some maximum value, which can be quite effective (refer to <a href="http://www.jmlr.org/proceedings/papers/v28/pascanu13.pdf">this paper</a>)</p>
<p>Some strategies for dealing with vanishing gradients:</p>
<ul>
<li>vanishing gradients are sensitive to weight initialization, so proper weight initialization can help avoid them</li>
<li>ReLUs can work better as the nonlinear activation functions since they are not bounded by 1 as the sigmoid and <mathjax>$\tanh$</mathjax> nonlinearities are</li>
</ul>
<p>Generally, however, Long Short-Term Memory (LSTM) and Gated Recurrent Unit (GRU) architectures are used instead of vanilla RNNs, which were designed for mitigating vanishing gradients (for the purpose of better learning long-range dependencies).</p>
<h3>LSTMs</h3>
<p>This short-term memory of (vanilla) RNNs may be <em>too</em> short. RNNs may incorporate <em>long short-term memory</em> (LSTM) units instead, which just computes hidden states in a different way.</p>
<p>With an LSTM unit, we have memory stored and passed through a more involved series of steps. This memory is modified in each step, with something being added and something being removed at each step. The result is a neural network that can handle longer-term context.</p>
<p>These LSTM units have a three gates (in contrast to the single activation function vanilla RNNs have):</p>
<ul>
<li><em>write</em> (<em>input</em>) - controls the amount of current input to be remembered</li>
<li><em>read</em> (<em>output</em>) - controls the amount of memory given as output to the next stage</li>
<li><em>erase</em> (<em>forget</em>) - controls what part of the memory is erased or kept in the current time step</li>
</ul>
<figure><img alt="A LSTM unit source" src="../assets/lstm_unit.png" /><figcaption>A LSTM unit <a href="http://devblogs.nvidia.com/parallelforall/understanding-natural-language-deep-neural-networks-using-torch/">source</a></figcaption>
</figure>
<p>TODO include Chris Olah's LSTM diagrams: <a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/">http://colah.github.io/posts/2015-08-Understanding-LSTMs/</a></p>
<p>These gates are sigmoid functions combined with a pointwise multiplication operation. They are called gates because they tune how much of their input is passed on (i.e. sigmoids give a value in <mathjax>$[0,1]$</mathjax>, which can be thought as the percent of input to pass on). The parameters for these gates are learned.</p>
<p>The input gate determines how much of the input is let through, the forget gate determines how much of the previous state is let through. We compute a new "memory" (i.e. the LSTM unit's internal state) from the outputs of these gates. The output gate determines how much of this new memory to output as the hidden state.</p>
<p>In more detail:</p>
<p>The forget gate controls what is removed ("forgotten") from the cell state. The input to the forget gate is the concatenation of the cell's output from the previous step, <mathjax>$\text{OUT}_{t-1}$</mathjax> and the current input to the cell, <mathjax>$X_t$</mathjax>. The gate computes a value in <mathjax>$[0,1]$</mathjax> (with the sigmoid function) for <em>each</em> value in the previous cell state <mathjax>$C_{t-1}$</mathjax>; the resulting value determines how much of that value to keep (1 means keep it all, 0 means forget all of it). So we are left with a vector of values in <mathjax>$[0,1]$</mathjax>, which we then pointwise multiply with the existing cell state to get the updated cell state.</p>
<p>The output of a forget gate <mathjax>$f$</mathjax> at step <mathjax>$t$</mathjax> is:</p>
<p><mathjax>$$
f_t = \text{sigmoid}(W_f \dot [\text{OUT}_{t-1}, X_t] + b_f)
$$</mathjax></p>
<p>Then our intermediate value of <mathjax>$C_t$</mathjax> is <mathjax>$C_t' = f_t C_{t-1}$</mathjax>.</p>
<p>Where <mathjax>$W_f, b_f$</mathjax> are the forget gate's weight vector and bias, respectively.</p>
<p>The input gate controls what information gets stored in the cell state. This gate also takes as input the concatenation of <mathjax>$\text{OUT}_{t-1}$</mathjax> and <mathjax>$X_t$</mathjax>. We will denote its output at step <mathjax>$t$</mathjax> as <mathjax>$i_t$</mathjax>. Like the forget gate, this is a vector of values in <mathjax>$[0, 1]$</mathjax> which determine how much information gets through - 0 means none, 1 means all of it.</p>
<p>A <mathjax>$\tanh$</mathjax> function takes the same input and outputs a vector of candidate values, <mathjax>$\tilde C_t$</mathjax>.</p>
<p>We pointwise multiple this candidate value vector with the input gate's output vector to get the vector that is passed to the cell state. This resulting vector is pointwise added to the updated cell state.</p>
<p><mathjax>$$
\begin{aligned}
i_t &amp;= \text{sigmoid}(W_i \dot [\text{OUT}_{t-1}, X_t] + b_i) \\
\tilde C_t &amp;= \tanh(W_C \dot [\text{OUT}_{t-1}, X_t] + b_C)
\end{aligned}
$$</mathjax></p>
<p>Thus our final updated value of <mathjax>$C_t$</mathjax> is <mathjax>$C_t = C_t' + i_t \tilde C_t$</mathjax>.</p>
<p>We don't output this cell state <mathjax>$C_t$</mathjax> directly. Rather, we have yet another gate, the <em>output gate</em> (sometimes called a <em>read gate</em>) that outputs another vector with values in <mathjax>$[0, 1]$</mathjax>, <mathjax>$o_t$</mathjax>, which determines how much of the cell state is outputted. This gate again takes in as input the concatenation of <mathjax>$\text{OUT}_{t-1}$</mathjax> and <mathjax>$X_t$</mathjax>.</p>
<p>So the output of the output gate is just:</p>
<p><mathjax>$$
o_t = \text{sigmoid}(W_o [\text{OUT}_{t-1}, X_t] + b_o)
$$</mathjax></p>
<p>To get the final output of the cell, we pass the cell state <mathjax>$C_t$</mathjax> through <mathjax>$\tanh$</mathjax> and then pointwise multiply that with the output of the output gate:</p>
<p><mathjax>$$
\text{OUT}_t = o_t \tanh(C_t)
$$</mathjax></p>
<p>An RNN is can be thought of as an LSTM in which all input and output gates are 1 and all forget gates are 0, with an additional activation function (e.g. <mathjax>$\tanh$</mathjax>) afterwards (LSTMs do not have this additional activation function).</p>
<p>There are many variations of LSTMs (see <a href="http://arxiv.org/pdf/1503.04069.pdf">this paper</a> for empirical comparisons between some of them), the most common of which is the Gated Recurrent Unit (GRU).</p>
<h4>GRUs</h4>
<p>A <strong>gated recurrent unit</strong> (GRU) is a simpler LSTM unit; it includes only two gates (also both sigmoid functions) - the reset gate <mathjax>$r$</mathjax> and the update gate <mathjax>$z$</mathjax>. The reset gate determines how to mix the current input and the previous state and the update gate determines how much of the previous state to retain. A vanilla RNN is a GRU architecture in which all reset gates are 1 and all update gates are 0 (with an additional activation function; like LSTMs don't have this additional nonlinearity). GRUs don't have internal states like LSTM units do; there is no output gate so there is no need for an internal state. The cell state and its output are also merged as its hidden state, <mathjax>$h_t$</mathjax>:</p>
<p><mathjax>$$
\begin{aligned}
h_{t-1} &amp;= \text{OUT}_{t-1} \\
z_t &amp;= \text{sigmoid}(W_z \dot [h_{t-1}, X_t]) \\
r_t &amp;= \text{sigmoid}(W_r \dot [h_{t-1}, X_t]) \\
\tilde h_t &amp;= \tanh(W \dot [r_t h_{t-1}, X_t]) \\
h_t &amp;= (1 - z_t) h_{t-1} + z_t \tilde h_t \\
\text{OUT}_t &amp;= h_t \\
\end{aligned}
$$</mathjax></p>
<h4>Peephole connections</h4>
<p>This LSTM variant just passes on the previous cell state, <mathjax>$C_{t-1}$</mathjax>, to the forget and input gates, and the new cell state, <mathjax>$C_t$</mathjax>, to the output gate, that is, all that is changed is that:</p>
<p><mathjax>$$
\begin{aligned}
f_t &amp;= \text{sigmoid}(W_f \dot [C_{t-1}, \text{OUT}_{t-1}, X_t] + b_f) \\
i_t &amp;= \text{sigmoid}(W_i \dot [C_{t-1}, \text{OUT}_{t-1}, X_t] + b_i) \\
o_t &amp;= \text{sigmoid}(W_o \dot [C_{t-1}, \text{OUT}_{t-1}, X_t] + b_o)
\end{aligned}
$$</mathjax></p>
<h4>Update gates</h4>
<p>In this LSTM variant, the forget and input gates are combined into a single <em>update gate</em>. The value <mathjax>$f_t$</mathjax> is computed the same, but <mathjax>$i_t$</mathjax> is instead just:</p>
<p><mathjax>$$
i_t = 1 - f_t
$$</mathjax></p>
<p>Essentially, we just update enough information to replace what was forgotten.</p>
<h3>BI-RNNs</h3>
<p><strong>Bidirectional RNNs</strong> (BI-RNNs) are a variation on RNNs in which the RNN can not only look into the past, but it can also look into the "future". The BI-RNN has two states, <mathjax>$s_i^f$</mathjax> (the forward state) and <mathjax>$s_i^b$</mathjax> (the backward state). The forward state <mathjax>$s_i^f$</mathjax> is based on <mathjax>$x_1, x_2, \dots, x_i$</mathjax>, whereas the backward state <mathjax>$s_i^b$</mathjax> is based on <mathjax>$x_n, x_{n-1}, \dots, x_i$</mathjax>. These states are managed by two different RNNs, one which is given the sequence <mathjax>$x_{1:n}$</mathjax> and the other is fed <mathjax>$x_{n:1}$</mathjax> (that is, the input in reverse).</p>
<p>The output at position <mathjax>$i$</mathjax> is the concatenation of these RNNs' output vectors, i.e. <mathjax>$y_i = [y_i^f; y_i^b]$</mathjax>.</p>
<h3>Attention mechanisms</h3>
<p>In people, "attention" is a mechanism by which we focus on one particular element of our environment, such that our perception of the focused element is in high-fidelity/resolution, whereas surrounding elements are at a lower resolution.</p>
<p>Attention mechanisms in recurrent neural networks emulate this behavior. This amounts to a weighted sum across input states (typically weights are normalized to sum to 1); higher weights indicate more "focus" or attention.</p>
<p>For instance, consider neural machine translation models. Their basic form consists of two RNNs, one which takes an input sentence (the encoder) and one which produces the translated output sentence (the decoder). The encoder takes the input sentence, produces a sentence embedding (i.e. a single vector meant to encapsulate the sentence's meaning), then the decoder takes that embedding and outputs the translated sentence.</p>
<p>Representing a sentence as a single embedding is challenging, especially since earlier parts of the sentence may be forgotten. There are some architectures such as the bidirectional variant that help with this, but attention mechanisms can help so that the decoder has access to the full spread of inputs and can "focus" more on translating individual parts when appropriate.</p>
<p>This means that instead of taking a single sentence embedding, each output word is produced through this weighted combination of all input states.</p>
<p>Note that these attention weights are stored for each step since each step the model distributes its attention differently. This can add up quickly.</p>
<p>Attention mechanisms can be thought of as an addressing system for selecting locations in memory (e.g. an array) in a weighted fashion.</p>
<h2>Unsupervised neural networks</h2>
<blockquote>
<p>The most basic one is probably the autoencoder, which is a feed-forward neural net which tries to predict its own input. While this isnt exactly the worlds hardest prediction task, one makes it hard by somehow constraining the network. Often, this is done by introducing a bottleneck, where one or more of the hidden layers has much lower dimensionality than the inputs. Alternatively, one can constrain the hidden layer activations to be sparse (i.e. each unit activates only rarely), or feed the network corrupted versions of its inputs and make it reconstruct the clean ones (this is known as a denoising autoencoder). [<a href="https://www.metacademy.org/roadmaps/rgrosse/deep_learning">https://www.metacademy.org/roadmaps/rgrosse/deep_learning</a>]</p>
</blockquote>
<h3>Autoencoders</h3>
<p><strong>Autoencoders</strong> are a feedforward neural network used for unsupervised learning. Autoencoders extract meaningful features by trying to output a reproduction of its input. That is, the output layer is the same size as its input layer, and it tries to reconstruct its input at the output layer.</p>
<p>Generally the output of an autoencoder is notated <mathjax>$\hat x$</mathjax>.</p>
<p>The first half (i.e. from the input layer up to the hidden layer) of the autoencoder architecture is called the <em>encoder</em>, and the latter half (i.e. from the hidden layer to the output layer) is called the <em>decoder</em>.</p>
<p>Often the weights of the decoder, <mathjax>$W*$</mathjax>, are just the transpose of the weights of the encoder <mathjax>$W$</mathjax>, i.e. <mathjax>$W* = W^T$</mathjax>. We refer to such weights as <em>tied</em> weights.</p>
<p>Essentially what happens is the hidden layer learns a compressed representation of the input (given that it is a smaller size than the input/output layers, this is called an <em>undercomplete</em> hidden layer, the learned representation is called an <em>undercomplete</em> representation), since it needs to be reconstructed by the decoder back to its original form. That is, the network needs to find some way of representing the input with less information. In some sense, we do this already with language, where we may represent a photo with a word (or a thousand words with a photo).</p>
<p>Undercomplete hidden layers do a good job compressing data similar to its training set, but bad for other inputs.</p>
<p>On the other hand, the hidden layer may be larger than the input/output layers, in which case it is called an <em>overcomplete</em> hidden layer and the learned representation of the input is an <em>overcomplete</em> representation. There's no compression as a result, and there's not guarantee that anything meaningful will be learned (since it can essentially just copy the input).</p>
<p>However, overcomplete representation as a concept is appealing because if we are using this autoencoder to learn features for us, we may want to learn many features. So how can we learn useful overcomplete representations?</p>
<h4>Sparse autoencoders</h4>
<p>Using a hidden layer size smaller than your input is tricky - encoding a lot of information into fewer bits is quite challenging.</p>
<p>Rather counterintuitively, a larger hidden layer helps, where some hidden units are randomly turned off during a training iteration - that way, the output isn't a mere copy of the input, and learning is easier since there is more "room" to represent the input. Such an autoencoder is called a <strong>sparse autoencoder</strong>.</p>
<p>In effect, what an autoencoder is learning is some higher-level representation of its input. In the case of an image, it may go from pixels to edges.</p>
<p>We can stack these sparse autoencoders on top of each other, so that higher and higher-level representations are learned. The sparse autoencoder that goes from pixels to edges can go into another one that learns how to go from edges to shapes, for example.</p>
<h4>Denoising autoencoders</h4>
<p>A <em>denoising</em> autoencoder is a way of learning useful overcomplete representations. The general idea is that we want the encoder to be robust to noise (that is, to be able to reconstruct the original input even in the presence of noise). So instead of inputting <mathjax>$x$</mathjax>, we input <mathjax>$\tilde x$</mathjax>, which is just <mathjax>$x$</mathjax> with noise added (sometimes called a <em>corrupted</em> input), and the network tries to reconstruct the noiseless <mathjax>$x$</mathjax> as its output.</p>
<p>There are many ways this noise can be added, but two popular approaches:</p>
<ul>
<li>for each component in an input, set it to 0 with probability <mathjax>$v$</mathjax></li>
<li>adding Gaussian noise (mean 0, and some variance; this variance is a hyperparameter)</li>
</ul>
<h4>Loss functions for autoencoders</h4>
<p>Say our neural network is <mathjax>$f(x) = \hat x$</mathjax>.</p>
<p>For binary inputs, we can use cross-entropy (more precisely, the sum of Bernoulli cross-entropies):</p>
<p><mathjax>$$
l(f(x)) = - \sum_k (x_k \log(\hat x_k)) + (1 - x_k)(\log(1-\hat x_k))
$$</mathjax></p>
<p>For real-valued inputs, we can use the sum of squared differences (i.e. the squared euclidean distance):</p>
<p><mathjax>$$
l(f(x)) = \frac{1}{2} \sum_k (\hat x_k - x_k)^2
$$</mathjax></p>
<p>And we use a linear activation function at the output.</p>
<h4>Loss function gradient in autoencoders</h4>
<p>Note that if you are using tied weights, the gradient <mathjax>$\nabla_W l(f(x^{(t)}))$</mathjax> is the sum of two gradients; that is, it is sum of the gradients for <mathjax>$W*$</mathjax> and <mathjax>$W^T$</mathjax>.</p>
<h4>Contractive autoencoders</h4>
<p>A <em>contractive</em> autoencoder is another way of learning useful overcomplete representations. We do so by adding an explicit term in the loss that penalizes uninteresting solutions (i.e. that penalizes just copying the input).</p>
<p>Thus we have a new loss function, extended from an existing loss function:</p>
<p><mathjax>$$
l(f(x^{(t)})) + \lambda ||\nabla_{x^{(t)}} h(x^{(t)})||_F^2
$$</mathjax></p>
<p>Where <mathjax>$\lambda$</mathjax> is a hyperparameter and <mathjax>$\nabla_{x^{(t)}} h(x^{(t)})$</mathjax> is the Jacobian of the encoder, represented as <mathjax>$h(x^{(t)})$</mathjax>, and <mathjax>$||A||_F$</mathjax> is the Frobenius norm:</p>
<p><mathjax>$$
||A||_F = \sqrt{\sum_{i=1}^m \sum_{j=1}^n |a_{ij}|^2}
$$</mathjax></p>
<p>Where <mathjax>$A$</mathjax> is a <mathjax>$m \times n$</mathjax> matrix. To put it another way, the Frobenius norm is the square root of the sum of the absolute squares of a matrix's elements; in this case, the matrix is the Jacobian of the encoder.</p>
<p>Intuitively, the term we're adding to the loss (the squared Frobenius norm of the Jacobian) increases the loss if we have non-zero partial derivatives with the encoder <mathjax>$h(x^{(t)})$</mathjax> with respect to the input; this essentially means we want to encourage the encoder to throw away information (i.e. we don't want the encoder's output to change with changes to the input; i.e. we want the encoder to be invariant to the input).</p>
<p>We balance this out with the original loss function which, as usual, encourages the encoder to keep good information (information that is useful for reconstructing the original input).</p>
<p>By combining these two conflicting priorities, the result is that the encoder keeps only the good information (the latter term encourages it to throw all information away, the former term encourages it to keep only the good stuff). The <mathjax>$\lambda$</mathjax> hyperparameter lets us tweak which of these terms to prioritize.</p>
<h4>Contractive vs denoising autoencoders</h4>
<p>Both perform well and each has their own advantages.</p>
<p>Denoising autoencoders are simpler to implement in that they are a simple extension of regular autoencoders and do not require computing the Jacobian of the hidden layer.</p>
<p>Contractive autoencoders have a deterministic gradient (since no sampling is involved; i.e. no random noise), which means second-order optimizers can be used (conjugate gradient, LBFGs, etc), and can be more stable than denoising autoencoders.</p>
<h4>Deep autoencoders</h4>
<p>Autoencoders can have more than one hidden layer but they can be quite difficult to train (e.g. with small initial weights, the gradient dies).</p>
<p>They can be trained with unsupervised layer-by-layer pre-training (stacking RBMs), or care can be taken in weight initialization.</p>
<h4>Shallow autoencoders for pre-training</h4>
<p>A shallow autoencoder is just an autoencoder with one hidden layer.</p>
<p>In particular, we can create a deep autoencoder by stacking (shallow) denoising autoencoders.</p>
<p>This typically works better than pre-training with RBMs.</p>
<p>Alternatively, (shallow) contractive autoencoders can be stacked, and they also work very well for pre-training.</p>
<h3>Sparse Coding</h3>
<p>The sparse coding model is another unsupervised neural network.</p>
<p>The general problem is that for each input <mathjax>$x^{(t)}$</mathjax>, we want to find a latent representation <mathjax>$h^{(t)}$</mathjax> such that:</p>
<ul>
<li><mathjax>$h^{(t)}$</mathjax> is sparse (has many zeros)</li>
<li>we can reconstruct the original input <mathjax>$x^{(t)}$</mathjax> as well as possible</li>
</ul>
<p>Formally:</p>
<p><mathjax>$$
\min_D \frac{1}{T} \sum_{t=1}^T \min_{h^{(t)}} \frac{1}{2} || x^{(t)} - D h^{(t)} ||_2^2 + \lambda || h^{(t)} ||_1
$$</mathjax></p>
<p>Note that <mathjax>$D h^{(t)}$</mathjax> is the reconstruction <mathjax>$\hat x^{(t)}$</mathjax>, so the term <mathjax>$|| x^{(t)} - D h^{(t)} ||_2^2$</mathjax> is the reconstruction error. <mathjax>$D$</mathjax> is the matrix of weights; in the context of sparse coding it is called a <em>dictionary</em> matrix, and it is equivalent to an autoencoder's output weight matrix.</p>
<p>The term <mathjax>$|| h^{(t)} ||_1$</mathjax> is a sparsity penalty, to encourage <mathjax>$h^{(t)}$</mathjax> to be sparse, by penalizing its L1 norm.</p>
<p>We constraint the columns of <mathjax>$D$</mathjax> to be of norm 1 because otherwise <mathjax>$D$</mathjax> could just grow large, allowing <mathjax>$h^{(t)}$</mathjax> to become small (i.e. sparse). Sometimes the columns of <mathjax>$D$</mathjax> are constrained to be no greater than norm 1 instead of being exactly 1.</p>
<h3>Restricted Boltzmann machines</h3>
<p>Restricted Boltzmann machines (RBMs) are a type of neural network used for unsupervised learning; it tries to extract meaningful features.</p>
<p>Such methods are useful for when we have a small supervised training set, but perhaps abundant unlabeled data. We can train an RBM (or another unsupervised learning method) on the unlabeled data to learn useful features to use with the supervised training set - this approach is called <em>semi-supervised</em> learning.</p>
<h3>Deep Belief Nets</h3>
<p><strong>Deep belief networks</strong> are a <em>generative</em> neural network. Given some feature values, a deep belief net can be run "backwards" and generate plausible inputs. For example, if you train a DBN on handwritten digits, it can be used to generate new images of handwritten digits.</p>
<p>Deep belief nets are also capable of unsupervised and semi-supervised learning. In an unsupervised setting, DBNs can still learn useful features.</p>
<h2>Other neural networks</h2>
<h3>Modular Neural Networks</h3>
<p>So say we have trained a neural net which has learned our function <mathjax>$W$</mathjax>, and given a word input, it outputs us the word's high-dimensional vector representation.</p>
<p>We can re-use this network in a modular fashion so that we construct a larger neural net which can take a fixed-size set of words as input. For example, the following network takes in five words, from which we get their representations, which are then passed into another network <mathjax>$R$</mathjax> to yield some output <mathjax>$s$</mathjax>.</p>
<figure><img alt="A modular neural network (Bottou (2011))" src="../assets/Bottou-WordSetup.png" /><figcaption>A modular neural network (<a href="http://arxiv.org/pdf/1102.1808v3.pdf">Bottou (2011)</a>)</figcaption>
</figure>
<h3>Recursive Neural Networks</h3>
<p>Using modular neural networks like above is limiting in the fact that we can only accept a fixed number of inputs.</p>
<p>We can get around this by adding an association module <mathjax>$A$</mathjax>, which takes two representations and merges them.</p>
<figure><img alt="Using association modules (Bottou (2011))" src="../assets/Bottou-Afold.png" /><figcaption>Using association modules (<a href="http://arxiv.org/pdf/1102.1808v3.pdf">Bottou (2011)</a>)</figcaption>
</figure>
<p>As you can see, it can take either a reputation from a word (via a <mathjax>$W$</mathjax> module) or from a phrase (via another <mathjax>$A$</mathjax> module).</p>
<p>We probably don't want to merge words linearly though. Instead we might want to group words in some way:</p>
<figure><img alt="A recursive neural network (Bottou (2011))" src="../assets/Bottou-Atree.png" /><figcaption>A recursive neural network (<a href="http://arxiv.org/pdf/1102.1808v3.pdf">Bottou (2011)</a>)</figcaption>
</figure>
<p>This kind of model is a "recursive neural network" (sometimes "tree-structured neural network") because it has modules feeding into modules of the same type.</p>
<h3>Nonlinear neural nets</h3>
<p>In typical NNs, the architecture of the network is specified before hand and is static - neurons don't change connections. In a nonlinear neural net, however, the connections between neurons becomes dynamic, so that new connections may form and old connections may break. This is more like how the human brain operates. But so far at least, these are very complex and difficult to train.</p>
<h3>Neural Turing Machines</h3>
<p>A Neural Turing Machine is a neural network enhanced with external addressable memory (and a means of interfacing with it). Like a Turing machine, it can simulate any arbitrary procedure - in fact, given an input sequence and a target output sequence, it can learn a procedure to map between the two on its own, trainable via gradient descent (as the entire thing is differentiable).</p>
<p>The basic architecture of NTMs is that there is a controller (which is a neural network, typically an RNN, e.g. LSTM, or a standard feedforward network), read/write heads (the write "head" actually consists of two heads, an erase and an add head, but referred to as a single head), and a memory matrix <mathjax>$M_t \in \mathcal R^{N \times M}$</mathjax>.</p>
<p>Each row (of which there are <mathjax>$N$</mathjax>, each of size <mathjax>$M$</mathjax>) in the memory matrix is referred to as a memory "location".</p>
<p>Unlike a normal Turing machine, the read and write operations are "blurry" in that they interact in some way with all elements in memory (normal Turing machines address one element at a time). There is an attentional "focus" mechanism that constrains the memory interaction to a smaller portion - each head outputs a weighting vector which determines how much it interacts (i.e. reads or writes) with each location.</p>
<p>At time <mathjax>$t$</mathjax>, the read head emits a (normalized) weighting vector over the <mathjax>$N$</mathjax> locations, <mathjax>$w_t$</mathjax>.</p>
<p>From this we get the <mathjax>$M$</mathjax> length read vector <mathjax>$r_t$</mathjax>:</p>
<p><mathjax>$$
r_t = \sum_i w_t(i) M_t(i)
$$</mathjax></p>
<p>At time <mathjax>$t$</mathjax>, the write head emits a weighting vector <mathjax>$w_t$</mathjax> (note that the write and read heads <em>each</em> emit their own <mathjax>$w_t$</mathjax> that is used in the context of that head) and an erase vector <mathjax>$e_t$</mathjax> that have <mathjax>$M$</mathjax> elements which line in the range (0,1)$.</p>
<p>Using these vectors, the memory vectors <mathjax>$M_{t-1}(i)$</mathjax> (i.e. locations) from the previous time-step are updated:</p>
<p><mathjax>$$
\tilde M_t(i) = M_{t-1}[\mathbb 1-w_t(i)e_t]
$$</mathjax></p>
<p>Where <mathjax>$\mathbb 1$</mathjax> is a row vector of all ones and the multiplication against the memory location is point-wise.</p>
<p>Thus a memory location is erased (all elements set to zero) if <mathjax>$w_t$</mathjax> and <mathjax>$e_t$</mathjax> are all ones, and if either is all zeros, then the memory is unchanged.</p>
<p>The write head also produces an <mathjax>$M$</mathjax> length add vector <mathjax>$a_t$</mathjax>, which is added to the memory after the erase step:</p>
<p><mathjax>$$
M_t(i) = \tilde M_t(i) + w_t(i) a_t
$$</mathjax></p>
<p>So, how are these weight vectors <mathjax>$w_t$</mathjax> produced for each head?</p>
<p>For each head, two addressing mechanisms are combined to produce its weighting vectors:</p>
<ul>
<li><em>content-based addressing</em>: focus attention on locations similar to the controller's outputted values</li>
<li><em>location-based addressing</em>: conventional lookup by location</li>
</ul>
<h4>Content-based addressing</h4>
<p>Each head produces a length <mathjax>$M$</mathjax> key vector <mathjax>$k_t$</mathjax>.</p>
<p><mathjax>$k_t$</mathjax> functions as a lookup key; we want to find an entry in <mathjax>$M_t$</mathjax> most similar to <mathjax>$k_t$</mathjax>. A similarity function <mathjax>$K$</mathjax> (e.g. cosine similarity) is applied to <mathjax>$k_t$</mathjax> against all entries in <mathjax>$M_t$</mathjax>. The similarity value is multiplied by a "key strength" <mathjax>$\beta_t &gt; 0$</mathjax>, which can attenuate the focus of attention. Then the resulting vector of similarities is normalized by applying softmax. The resulting weighting vector is <mathjax>$w_t^c$</mathjax>:</p>
<p><mathjax>$$
w_t^c(i) = \frac{\exp(\beta_t K(k_t, M_t(i)))}{\sum_j \exp (\beta_t K(k_t, M_t(j)))}
$$</mathjax></p>
<h4>Location-based addressing</h4>
<p>The location-based addressing mechanism is used to move across memory locations iteratively (i.e. given a current location, move to this next location; this is called a <em>rotational shift</em>) and for random-access jumps.</p>
<p>Each head outputs a scalar <em>interpolation gate</em> <mathjax>$g_t$</mathjax> in the range <mathjax>$(0,1)$</mathjax>. This is used to blend the old weighting outputted by the head, <mathjax>$w_{t-1}$</mathjax>, with the new weighting from the content-based addressing system, <mathjax>$w_t^c$</mathjax>. The result is the <em>gated weighting</em> <mathjax>$w_t^g$</mathjax>:</p>
<p><mathjax>$$
w_t^g = g_t w_t^c + (1-g_t)w_{t-1}
$$</mathjax></p>
<p>If the gate is zero, the content weighting is ignored and only the previous weighting is used.</p>
<p>(TODO not totally clear on this part) Next, the head also emits a <em>shift weighting</em> <mathjax>$s_t$</mathjax> which specifies a normalized distribution over the allowed integer shifts. For example, if shifts between -1 and 1 are allowed, <mathjax>$s_t$</mathjax> has three elements describing how much the shifts of -1, 0, and 1 are performed. One way of doing this is by adding a softmax layer of the appropriate size to the controller.</p>
<p>Then we apply the rotation specified by <mathjax>$s_t$</mathjax> to <mathjax>$w_t^g$</mathjax>:</p>
<p><mathjax>$$
\tilde w_t(i) = \sum_{j=0}^{N-1} w_t^g(j) s_t(i-j)
$$</mathjax></p>
<p>Over time, the shift weighting, if it isn't "sharp", can cause weightings to disperse over time. For example, with permitted shifts of -1, 0, 1 and <mathjax>$s_t = [0.1, 0.8, 0.1]$</mathjax>, the single point gets slightly blurred across the three points  To counter this, each head also emits a scalar <mathjax>$\gamma_t \geq 1$</mathjax> that is used to (re)sharpen the final weighting:</p>
<p><mathjax>$$
w_t(i) = \frac{\tilde w_t(i)^{\gamma_t}}{\sum_j \tilde w_t(j)^{\gamma_t}}
$$</mathjax></p>
<p>Refer to the paper for example uses.</p>
<h2>Neuroevolution</h2>
<p><em>Neuroevolution</em> is the process of applying evolutionary algorithms to neural networks to learn their parameters (weights) and/or architecture (topology).</p>
<p>Neuroevolution is flexible in its application; it may be used for supervised, unsupervised, and reinforcement learning tasks. An example application is state or action value evaluation, e.g. for game playing.</p>
<p>With neuroevolution, an important choice is the genetic representation (genotype) of the neural network. For instance, if the architecture is fixed by the user, the weights can just be genetically represented as a vector of real numbers. Then the standard genetic algorithm (i.e. fitness, mutation, crossover, etc) can be applied.</p>
<p>This simple representation of weights as a vector is called <em>conventional neuroevolution</em> (CNE).</p>
<p>However, because the performance of a neural net is so dependent on topology, evolving the topology in addition to the weights can lead to better performance. One such method is <em>NeuroEvolution of Augmenting Topologies</em> (NEAT), of which there are many variations (e.g. RBF-NEAT, Cascade-NEAT).</p>
<p><em>Direct encoding</em> the parameters are mapped one-to-one onto the vector; that is each weight is mapped to one number in the vector. However, there may be advantage to using <em>indirect encodings</em>, in which information in one part of the vector may be linked to another part. This compacts the genetic representation in that not every value must be represented (some are shared, mapping to multiple connections).</p>
<p>A <em>Compositional Pattern Producing Network</em> (CPPN) is a neural network which functions as a pattern-generator. CPPNs typically include different activation functions (such as sine, for repeating patterns, or Gaussian, to create symmetric patterns). Although they were originally designed to produce two-dimensional patterns (e.g. images), CPPNs may be used to evolved indirectly encoded neural networks - they "exploit geometric domain properties to compactly describe the connectivity pattern of a large-scale ANN" (<a href="http://arxiv.org/pdf/1410.7326v3.pdf">Riesi &amp; Togelius</a>). The CPPN itself may be evolved using NEAT - this approach is called <em>HyperNEAT</em>.</p>
<p>A form of indirect encodings are <em>developmental approaches</em> in which the network develops new connections as the game is being played.</p>
<p>In non-deterministic games, the fitness function may be noisy (since the same action can lead to different scores). One way around this is to average the performance over many independent plays.</p>
<p>For complex problems, it sometimes is too difficult to evolve the network directly to that problem. Instead, <em>staging</em> (also called <em>incremental evolution</em>) may be preferred, where the network is evolved on simpler problems that gradually increase towards the original complex task. Similarly, transfer learning may be useful here as well.</p>
<p>A challenge in evolving competitive AI is that there may not be a good enough opponent to play against and learn from. A method called <em>competitive coevolution</em> can be used, in which the fitness of one AI player depends on how it performs against another AI player drawn from the same or from another population.</p>
<p>A similar method called <em>cooperative coevolution</em>, where fitness is instead based on its performance in collaboration with other players, may make more sense in other contexts. It may be adapted more generally by applying it at the individual neuron level - that is, each neuron's fitness depends on how well it works with the other neurons in the network. The CoSyNE neuroevolution algorithm is based on this.</p>
<p>In many cases, there is no single performance metric that can be used; rather, performance is evaluated based on many different dimensions. The simplest way around this is to combine these various metrics in some way - e.g. as a linear combination - but another way is <em>cascading elitism</em>, where "each generation contains separate selection events for each fitness function, ensuring equal selection pressure" (<a href="http://arxiv.org/pdf/1410.7326v3.pdf">Riesi &amp; Togelius</a>).</p>
<p>There is another class of algorithms called <em>multiobjective evoluationary algorithm</em> (MOEA) where multiple fitness functions are specified. These algorithms try to satisfy all their given objectives (fitness functions) and can also manage conflicts between objectives by identifying (mapping) them and deciding on tradeoffs. When a solution is found where no objective can be further improved without worsening another, the solution is said to be on the <em>Pareto Front</em>. One such MOEA is NSGA-II (Non-dominated Sorting Genetic Algorithm).</p>
<p>There exist <em>interactive evolution</em> approaches in which a human can set or modify objectives during evolution, or even act as the fitness function themselves. Other ways humans can intervene include <em>shaping</em>, where the human can shape the environment to influence training, and <em>demonstration</em>, in which the human takes direct control and the network learns from that example.</p>
<h2>Generative Adversarial Networks</h2>
<p>Generative models are typically trained with maximum-likelihood estimation which can become intractable (due to the normalization/partition term).</p>
<p><em>Generative adversarial networks</em> (GAN) are a method for training generative models with neural networks, trained with stochastic gradient descent instead of MLE.</p>
<p>Sampling from the model is achieved by inputting noise; the outputs of the networks are the samples.</p>
<p>A conditional generative adversarial network (cGAN) is an extension which allows the model to condition on external information.</p>
<p>Note that denoising autoencoders have been used to achieve something similar. Denoising autoencoders learn to reconstruct empirical data <mathjax>$X$</mathjax> from noised inputs <mathjax>$\tilde X$</mathjax> and can be sampled from by using a Markov chain, alternating between sampling reconstructed values <mathjax>$P(X | \tilde X)$</mathjax> and noise <mathjax>$C(\tilde X | X)$</mathjax>, which eventually reaches a stationary distribution which matches the empirical density model established by the training data. (this method under the category of <em>generative stochastic networks</em>). GANs in contrast, have a much simpler sampling project (they don't require a Markov chain), they require only noise input.</p>
<p>A GAN has two components:</p>
<ul>
<li>the <em>generator</em> <mathjax>$G$</mathjax>, which attempts to generate fraudulent, but convincing, samples</li>
<li>the <em>discriminator</em> <mathjax>$D$</mathjax>, which tries to distinguish fraudulent samples from genuine ones</li>
</ul>
<p>These two are pitted against each other in an adversarial game. As such, the objective function here is a minimax value function:</p>
<p><mathjax>$$
\min_G \max_D (E_{x \sim p_{\text{data}}(x)} [\log D(x)] + E_{z \sim p_z(z)} [\log(1-D(G(z)))])
$$</mathjax></p>
<p>Breaking this down:</p>
<ol>
<li>Train the discriminator to maximize the probability of the training data</li>
<li>Train the discriminator to minimize the probability of the data sampled from the generator. At the same time, train the generator on the opposite objective (maximize the probability that the discriminator assigns to its own samples).</li>
</ol>
<p>They are trained in alternation using stochastic gradient descent.</p>
<p>This paper incorporates <em>conditioning</em> into this general GAN framework. Some condition <mathjax>$y$</mathjax> is established for generation; this restricts the generator in its output and the discriminator in its expected input.</p>
<ul>
<li><mathjax>$Z$</mathjax> is the <em>noise space</em> used to seed the generative model. <mathjax>$Z = \mathbb R^{d_z}$</mathjax> where <mathjax>$d_z$</mathjax> is a hyperparameter. Values <mathjax>$z \ in Z$</mathjax> are sampled from a noise distribution <mathjax>$p_z(z)$</mathjax> (it can be, for example, a simple Gaussian noise model).</li>
<li><mathjax>$Y$</mathjax> is an <em>embedding space</em> used to <em>condition</em> the generative model on some external information, drawn from the training data. <mathjax>$Y = \mathbb R^{d_Y}$</mathjax> where <mathjax>$d_Y$</mathjax> is a hyperparameter. Using condition information provided in the training data, we can define a density model <mathjax>$p_y(y)$</mathjax>.</li>
<li><mathjax>$X$</mathjax> is the <em>data space</em> which represents an image output from the generator or input to the discriminator. Each input is associated with some conditional data <mathjax>$y$</mathjax>, so we have a density model <mathjax>$p_{\text{data}}(x, y)$</mathjax>.</li>
</ul>
<p>We have two functions:</p>
<ul>
<li><mathjax>$G: (Z \times Y) \to X$</mathjax> is the generative model/generator which takes noise data <mathjax>$z \ in Z$</mathjax> along with an embedding <mathjax>$y \in Y$</mathjax> and produces an output <mathjax>$x \in X$</mathjax>.</li>
<li><mathjax>$D: (X \times Y) \to [0, 1]$</mathjax> is the discriminative model/discriminator which takes an input <mathjax>$x$</mathjax> and condition <mathjax>$y$</mathjax> and predicts the probability under condition <mathjax>$y$</mathjax> that <mathjax>$x$</mathjax> came from the empirical data distribution rather than from the generative model.</li>
</ul>
<p>The generator <mathjax>$G$</mathjax> implicitly defines a conditional density model <mathjax>$p_g(x | y)$</mathjax>. We combine this density model with the existing conditional density <mathjax>$p_y(y)$</mathjax> to yield the joint model <mathjax>$p_g(x, y)$</mathjax>. The task is to parameterize <mathjax>$G$</mathjax> so that it replicates the empirical density model <mathjax>$p_{\text{data}}(x,y)$</mathjax>.</p>
<p>The conditional GAN objective function becomes:</p>
<p><mathjax>$$
\min_G \max_D (E_{x,y \sim p_{\text{data}}(x,y)} [\log D(x,y)] + E_{y \sim p_y, z \sim p_z(z)} [\log(1-D(G(z,y), y))])
$$</mathjax></p>
<p>The conditional data <mathjax>$y$</mathjax> is sampled from either the training data or an independent distribution.</p>
<p>In terms of cost functions: we have a batch of training data <mathjax>$\{(x_i, y_i)\}_{i=1}^n$</mathjax> and <mathjax>$z_i$</mathjax> drawn from the noise prior.</p>
<p>The cost equation for the discriminator <mathjax>$D$</mathjax> is a simple logistic cost expression (to give a positive label to input truly from the data distribution and a negative label to counterfeit examples):</p>
<p><mathjax>$$
J_D = -\frac{1}{2n} (\sum_{i=1}^n \log D(x_i, y_i) + \sum_{i=1}^n \log (1-D(G(z_i, y_i), y_i)))
$$</mathjax></p>
<p>The cost equation for <mathjax>$G$</mathjax> is (to maximize the probability the discriminator assigns to samples from <mathjax>$G$</mathjax>, i.e. to trick the discriminator):</p>
<p><mathjax>$$
J_G = -\frac{1}{n} \sum_{i=1}^n \log D(G(z_i, y_i))
$$</mathjax></p>
<p>Note that a "maximally confused" discriminator would output 0.5 for both true and counterfeit examples.</p>
<p>Note that we have to be careful how we draw the conditional data <mathjax>$y$</mathjax>. We can't just use conditional samples from the data itself because the generator may just learn to reproduce true input based on the conditional input.</p>
<p>Instead, we build a kernel density estimate <mathjax>$p_y(y)$</mathjax> (called a <em>Parzen window estimate</em>) using the conditional values in the training data. We use a Gaussian kernel and cross-validate the kernel width <mathjax>$\sigma$</mathjax> using a held-out validation set. Then we draw samples from this density model to use as conditional inputs.</p>
<h3>Training generative adversarial networks</h3>
<p>We have:</p>
<ul>
<li><mathjax>$x$</mathjax> = the data</li>
<li><mathjax>$p_z(z)$</mathjax> a prior for drawing noise samples</li>
<li><mathjax>$p_g$</mathjax> which is the generator's distribution that we learn</li>
<li><mathjax>$G(z;\theta_g)$</mathjax>, the generator function (i.e. the generator neural network), which takes as input a noise sample <mathjax>$z$</mathjax>, parametrized by <mathjax>$\theta_g$</mathjax>, mapping to the space of <mathjax>$x$</mathjax> (that is, it outputs a fraudulent sample from <mathjax>$x$</mathjax>)</li>
<li><mathjax>$D(x;\theta_d)$</mathjax>, the discriminator function (i.e. the discriminator neural network), which take as input the output from <mathjax>$G$</mathjax>, and outputs a scalar which is the estimated probability that the input came from <mathjax>$x$</mathjax> rather than from <mathjax>$p_g$</mathjax>.</li>
</ul>
<p>Together, <mathjax>$D$</mathjax> and <mathjax>$G$</mathjax> play a two-player minimax game with the value function <mathjax>$V(G,D)$</mathjax>:</p>
<p><mathjax>$$
\min_G \max_D (E_{x \sim p_{\text{data}}(x)} [\log D(x)] + E_{z \sim p_z(z)} [\log(1-D(G(z)))])
$$</mathjax></p>
<p>We simultaneously train <mathjax>$D$</mathjax> to maximize the probability of assigning the correct labels and train <mathjax>$G$</mathjax> to minimize <mathjax>$\log(1-D(G(z)))$</mathjax>. In particular, we want to train <mathjax>$D$</mathjax> more quickly to be a more discerning discriminator, which causes <mathjax>$G$</mathjax> to be a better counterfeiter.</p>
<p>However, we don't want to train <mathjax>$D$</mathjax> to completion first because it would result in overfitting (and is computationally prohibitive). Rather, we train <mathjax>$D$</mathjax> for <mathjax>$k$</mathjax> steps (<mathjax>$k$</mathjax> is a hyperparameter), then train <mathjax>$G$</mathjax> for one step, and repeat.</p>
<p>Another problem is that early on <mathjax>$G$</mathjax> is bad at creating counterfeits, and <mathjax>$D$</mathjax> can recognize them as such easily - this causes <mathjax>$\log(1-D(G(z)))$</mathjax> to saturate. So instead of training <mathjax>$G$</mathjax> to minimize <mathjax>$\log(1-D(G(z)))$</mathjax>, we can train it to maximize <mathjax>$\log(D(G(z))$</mathjax>.</p>
<p>The basic algorithm is:</p>
<div class="highlight"><pre><span class="n">m</span> <span class="o">=</span> <span class="n">minibatch_size</span>
<span class="n">pz</span> <span class="o">=</span> <span class="n">noise_prior</span>
<span class="n">px</span> <span class="o">=</span> <span class="n">data</span> <span class="n">distribution</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">epochs</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="c"># sample m noise samples from the noise prior</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">sample_minibatch</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">pz</span><span class="p">)</span>

        <span class="c"># sample m examples from the data</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">sample_minibatch</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">px</span><span class="p">)</span>

        <span class="c"># update the discriminator by ascending its stochastic gradient</span>
        <span class="n">update_discriminator</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="c"># sample m noise samples from the noise prior</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">sample_minibatch</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">pz</span><span class="p">)</span>

    <span class="c"># update the generator by descending its stochastic gradient</span>
    <span class="n">update_generator</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
</pre></div>


<p>Where <code>update_discriminator</code> has the gradient:</p>
<p><mathjax>$$
\nabla_{\theta_d} \frac{1}{m} \sum_{i=1}^m [\log D(x^{(i)}) + \log (1-D(G(z^{(i)})))]
$$</mathjax></p>
<p>and <code>update_generator</code> has the gradient:</p>
<p><mathjax>$$
\nabla_{\theta_g} \frac{1}{m} \sum_{i=1}^m \log(1-D(G(z^{(i)})))
$$</mathjax></p>
<p><a href="http://arxiv.org/pdf/1406.2661v1.pdf">The paper</a> used momentum for the gradient updates.</p>
<h2>References</h2>
<ul>
<li><em>Neural Computing: Theory and Practice</em> (1989). Philip D. Wasserman.</li>
<li><a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-034-artificial-intelligence-fall-2010/">MIT 6.034 (Fall 2010): Artificial Intelligence</a>. Patrick H. Winston. MIT.</li>
<li><a href="https://cs231n.github.io/neural-networks-1/">CS231n Convolutional Neural Networks for Visual Recognition, Module 1: Neural Networks Part 2: Setting up the Data and the Loss</a>. Andrej Karpathy.</li>
<li><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/">Understanding LSTM Networks</a>. Chris Olah. August 27, 2015.</li>
<li><a href="http://ulcar.uml.edu/~iag/CS/Intro-to-ANN.html">Crash Introduction to Artificial Neural Networks</a>. Ivan Galkin.</li>
<li><a href="http://www-labs.iro.umontreal.ca/~bengioy/dlbook/">Deep Learning</a>. Yoshua Bengio, Ian Goodfellow, Aaron Courville.</li>
<li><a href="http://natureofcode.com/book/chapter-10-neural-networks">The Nature of Code</a>. Daniel Shiffman.</li>
<li><a href="http://neuralnetworksanddeeplearning.com">Neural Networks and Deep Learning</a>, Michael A Nielsen. Determination Press, 2015.</li>
<li><a href="http://www.doc.ic.ac.uk/~nd/surprise_96/journal/vol4/cs11/report.html">Neural Networks</a>. Christos Stergiou &amp; Dimitrios Siganos.</li>
<li><a href="http://mattmazur.com/2015/03/17/a-step-by-step-backpropagation-example/">A Step by Step Backpropagation Example</a>. Matt Mazur. March 17, 2015.</li>
<li><a href="http://outlace.com/Beginner-Tutorial-Backpropagation/">Gradient Descent with Backpropagation</a>. July 31, 2015. Brandon B.</li>
<li><a href="http://arxiv.org/abs/1510.00726">A Primer on Neural Network Models for Natural Language Processing</a>. Yoav Goldberg. October 5, 2015.</li>
<li><a href="https://www.coursera.org/course/neuralnets">Neural Networks for Machine Learning</a>. Geoff Hinton. 2012. University of Toronto (Coursera).</li>
<li><a href="https://cs231n.github.io/neural-networks-1/">CS231n Convolutional Neural Networks for Visual Recognition, Module 1: Neural Networks Part 1: Setting up the Architecture</a>. Andrej Karpathy.</li>
<li><a href="https://cs231n.github.io/optimization-2/">CS231n Convolutional Neural Networks for Visual Recognition, Module 1: Backpropagation, Intuitions</a>. Andrej Karpathy.</li>
<li><a href="http://arxiv.org/abs/1410.5401">Neural Turing Machines</a>. Alex Graves, Greg Wayne, Ivo Danihelka. 2014.</li>
<li><a href="http://www.hexahedria.com/2015/08/03/composing-music-with-recurrent-neural-networks/">Composing Music with Recurrent Neural Networks</a>. Daniel Johnson. August 3, 2015.</li>
<li><a href="https://www.youtube.com/playlist?list=PL6Xpj9I5qXYEcOhn7TqghAJ6NAPrNmUBH">Neural Networks</a>. Hugo Larochelle. 2013. Universit de Sherbrooke.</li>
<li><a href="https://www.youtube.com/watch?v=VINCQghQRuM">General Sequence Learning using Recurrent Neural Networks</a>. Alec Radford.</li>
<li><a href="http://www.wildml.com/2015/10/recurrent-neural-networks-tutorial-part-3-backpropagation-through-time-and-vanishing-gradients/">Recurrent Neural Networks Tutorial, Part 3  Backpropagation Through Time and Vanishing Gradients</a>. Denny Britz. October 8, 2015.</li>
<li><a href="http://www.wildml.com/2015/10/recurrent-neural-network-tutorial-part-4-implementing-a-grulstm-rnn-with-python-and-theano/">Recurrent Neural Network Tutorial, Part 4  Implementing a GRU/LSTM RNN with Python and Theano</a>. Denny Britz. October 27, 2015.</li>
<li><a href="http://peterroelants.github.io/posts/rnn_implementation_part01/">How to implement a recurrent neural network Part 1</a>. Peter Roelants.</li>
<li><a href="http://ufldl.stanford.edu/tutorial/supervised/DebuggingGradientChecking/">Debugging: Gradient Checking</a>. Stanford UFLDL.</li>
<li><a href="http://pages.cs.wisc.edu/~bolo/shipyard/neural/local.html">A Basic Introduction to Neural Networks</a>. ai-junkie.</li>
<li><a href="http://www.ai-junkie.com/ann/evolved/nnt1.html">Neural Networks in Plain English</a>.</li>
<li><a href="http://devblogs.nvidia.com/parallelforall/understanding-natural-language-deep-neural-networks-using-torch/">Understanding Natural Language with Deep Neural Networks Using Torch</a>. Soumith Chintala.</li>
<li><a href="http://www.marekrei.com/blog/26-things-i-learned-in-the-deep-learning-summer-school/">26 Things I Learned in the Deep Learning Summer School</a>. Marek Rei.</li>
<li><a href="https://colah.github.io/posts/2014-07-Conv-Nets-Modular/">Conv Nets: A Modular Perspective</a>. Chris Olah.</li>
<li><a href="https://colah.github.io/posts/2014-07-Understanding-Convolutions/">Understanding Convolutions</a>. Chris Olah.</li>
<li><a href="https://colah.github.io/posts/2014-07-NLP-RNNs-Representations/">Deep Learning, NLP, and Representations</a>. Chris Olah.</li>
<li><a href="https://stats.stackexchange.com/questions/181/how-to-choose-the-number-of-hidden-layers-and-nodes-in-a-feedforward-neural-netw">How to choose the number of hidden layers and nodes in feedforward neural network</a>. gung, doug.</li>
<li><a href="http://www.faqs.org/faqs/ai-faq/neural-nets/part1/preamble.html">comp.ai.neural-nets FAQ</a>. Warren S. Sarle.</li>
<li><em>Fundamentals of Deep Learning</em>. Nikhil Buduma. 2015.</li>
<li><a href="https://cs231n.github.io/neural-networks-2/">CS231n Convolutional Neural Networks for Visual Recognition, Module 1: Setting up the data and the model</a>. Andrej Karpathy.</li>
<li><a href="https://cs231n.github.io/neural-networks-1/">CS231n Convolutional Neural Networks for Visual Recognition, Module 1: Modeling one neuron</a>. Andrej Karpathy.</li>
<li><a href="http://www.wildml.com/deep-learning-glossary/">Deep Learning Glossary</a>. WildML (Denny Britz).</li>
<li><a href="http://arxiv.org/pdf/1510.01378v1.pdf">Batch Normalized Recurrent Neural Networks</a>. Csar Laurent, Gabriel Pereyra, Philmon Brakel, Ying Zhang, Yoshua Bengio.</li>
<li><a href="http://sebastianruder.com/optimizing-gradient-descent/">An overview of gradient descent optimization algorithms</a>. Sebastian Rudr.</li>
<li><a href="http://arxiv.org/pdf/1410.7326v3.pdf">Neuroevolution in Games: State of the Art and Open Challenges</a>. Sebastian Risi, Julian Togelius. November 3, 2015.</li>
<li><a href="https://pdfs.semanticscholar.org/45b7/d3881dd92c8c73b99fa3497e5d28a2106c24.pdf">Neuroevolution: from architectures to learning</a>. Dario Floreano, Peter Drr, Claudio Mattiussi.</li>
<li><a href="http://www.foldl.me/uploads/2015/conditional-gans-face-generation/paper.pdf">Conditional generative adversarial nets for convolutional face generation</a>. Jon Gauthier.</li>
<li><a href="http://arxiv.org/pdf/1406.2661v1.pdf">Generative Adversarial Nets</a>. Ian J. Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair, Aaron Courville, Youshua Bengio.</li>
<li><a href="http://lamda.nju.edu.cn/weixs/project/CNNTricks/CNNTricks.html">Must Know Tips/Tricks in Deep Neural Networks</a>. Xiu-Shen Wei.</li>
<li><a href="http://timdettmers.com/2015/03/26/convolution-deep-learning/">Understanding Convolution in Deep Learning</a>. Tim Dettmers.</li>
<li><a href="http://deeplearning.net/software/theano/library/tensor/nnet/conv.html">theano conv documentation</a></li>
<li><a href="http://www.wildml.com/2016/01/attention-and-memory-in-deep-learning-and-nlp/">Attention and Memory in Deep Learning and NLP</a>. Denny Britz.</li>
<li>Chris Olah &amp; Shan Carter, "<a href="http://distill.pub/2016/augmented-rnns/">Attention and Augmented Recurrent Neural Networks</a>", Distill, 2016.</li>
</ul>
    
    <script src="http://cdn.bootcss.com/jquery/1.11.1/jquery.js"></script>
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>
    <script src="http://ai-code.tech/ai_notes_html/js/custom.js"></script>
    <script>
        $(document).ready(function() {
            $('pre').each(function(i, e) {hljs.highlightBlock(e)});
            MathJax.Hub.Config({
                tex2jax: {
                    inlineMath: [["$","$"]],
                    displayMath: [['$$','$$']],
                    processEscapes: true
                },
                "HTML-CSS": {
                    linebreaks: { automatic: true }
                }
            });
            MathJax.Hub.Startup.onload();
        });
    </script>


</body>
</html>
