
<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1">

    <title>Natural Language Processing</title>

    <link rel="stylesheet" type="text/css" href="../style.css">
    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/color-brewer.min.css">
    <link rel="stylesheet" href="http://ai-code.tech/ai_notes_html/css/custom.css">
</head>

<body>

    <p><mathjax>$$
\def\argmax{\operatorname*{argmax}}
\def\argmin{\operatorname*{argmin}}
$$</mathjax></p>
<h1>NLP</h1>
<h2>Problems</h2>
<p>Some (higher-level) problems that fall under NLP include:</p>
<ul>
<li>machine translation</li>
<li>(structured) information extraction</li>
<li>summarization</li>
<li>natural language interfaces</li>
<li>speech recognition</li>
</ul>
<p>At a lower-level, these include the following problems:</p>
<ul>
<li>part-of-speech tagging</li>
<li>parsing</li>
<li>word-sense disambiguation</li>
<li>named entity recognition</li>
<li>etc</li>
</ul>
<h2>Challenges</h2>
<p><strong>Ambiguity</strong> is one of the greatest challenges to NLP:</p>
<p>For example:</p>
<blockquote>
<p>Fed raises interest rates, where "raises" is the verb, and "Fed" is the noun phrase<br />
Fed raises interest rates, where "interest" is the verb, and "Fed raises" is the noun phrase</p>
</blockquote>
<p>This ambiguity occurs at many levels:</p>
<ul>
<li>the <em>acoustic</em> level: e.g. mixing up similar-sounding words</li>
<li>the <em>syntactic</em> level: e.g. multiple plausible grammatical parsings of a sentence</li>
<li>the <em>semantic</em> level: e.g. some words can mean multiple things ("bank" as in a river or a financial institution); this is called <em>word sense ambiguity</em></li>
<li>the <em>discourse</em> (multi-clause) level: e.g. unclear what a pronoun is referring to</li>
</ul>
<p>Other challenges include:</p>
<ul>
<li><em>non-standard english</em>: for instance, text shorthand, phrases such as "SOOO PROUD" as opposed to "so proud", or hashtags, etc</li>
<li><em>segmentation issues</em>: [the] [New] [York-New] [Haven] [Railroad] vs. [the] [New York]-[New Haven] [Railroad]</li>
<li><em>idioms</em> (e.g. "get cold feet", doesn't literally mean what it says)</li>
<li><em>neologisms</em> (e.g. "unfriend", "retweet", "bromance")</li>
<li><em>world knowledge</em> (e.g. "Mary and Sue are sisters" vs "Mary and Sue are mothers.")</li>
<li><em>tricky entity names</em>: "Where is <em>A Bug's Life</em> playing", or "a mutation on the <em>for</em> gene"</li>
</ul>
<p>The typical approach is to codify knowledge about language &amp; knowledge about the world and find some way to combine them to build probabilistic models.</p>
<h2>Terminology</h2>
<ul>
<li><strong>synset</strong>: a synset is a set of synonyms that represent a single sense of a word.</li>
<li><strong>wordform</strong>: the full inflected surface form: e.g. "cat" and "cats" are different wordforms.</li>
<li><strong>lemma</strong>: the same stem, part of speech, rough word sense; e.g. "cat" and "cats" are the same lemma.<ul>
<li>One lemma can have many meanings. For example:</li>
</ul>
</li>
</ul>
<blockquote>
<p>a <em>bank</em> can hold investments...<br />
agriculture on the east <em>bank</em>...</p>
</blockquote>
<ul>
<li><strong>sense</strong>: a discrete representation of an aspect of a word's meaning. The usages of <em>bank</em> in the previous example have a different sense.</li>
<li><strong>homonyms</strong>: words that share form but have unrelated, distinct meanings (such as "bank").<ul>
<li><em>Homographs</em>: bank/bank, bat/bat</li>
<li><em>Homophones</em>: write/right, piece/peace</li>
</ul>
</li>
<li><strong>polysemy</strong>:<ul>
<li>A <em>polysemous</em> word has <em>related</em> meanings, for example:<ul>
<li>"the <em>bank</em> was built in 1875 ("bank" = a building belonging to a financial institution)"</li>
<li>"I withdrew money from the <em>bank</em> ("bank" = a financial institution)"</li>
</ul>
</li>
<li><em>Systematic polysemy</em>, or <em>metonymy</em>, is when the meanings have a <em>systematic</em> relationship.</li>
<li>For example, "school", "university", "hospital" - all can mean the institution or the building, so the systematic relationship here is <code>building &lt;=&gt; organization</code>.</li>
<li>Another example is <code>author &lt;=&gt; works of author</code>, e.g. "Jane Austen wrote Emma" and "I love Jane Austen".</li>
</ul>
</li>
<li><strong>synonyms</strong>: different words that have the same <em>propositional</em> meaning in some or all contexts. However, there may be no examples of <em>perfect synonymy</em> since even if propositional meaning is identical, they may vary in notions of politeness or other usages and so on.<ul>
<li>For example, "water" and "H2O" - each are more appropriate in different contexts.</li>
<li>As another example, "big" and "large" - sometimes they can be swapped, sometimes they cannot:</li>
</ul>
</li>
</ul>
<blockquote>
<p>That's a big plane. How large is that plane? (Acceptable)<br />
Miss Nelson became kind of a big sister to Benjamin. Miss Nelson became kind of a large sister to Benjamin (Not as acceptable)</p>
</blockquote>
<p>The latter works less because "big" has multiple senses, one of which does not correspond to "large".</p>
<ul>
<li><strong>antonyms</strong>: -senses which are opposite with respect to one feature of meaning, but otherwise are similar, such as dark/light, short/fast, etc.</li>
<li><strong>hyponym</strong>: one sense is a hyponym of another if the first sense is more specific (i.e. denotes a subclass of the other).<ul>
<li><em>car</em> is a hyponym of <em>vehicle</em></li>
<li><em>mango</em> is a hyponym of <em>fruit</em></li>
</ul>
</li>
<li><strong>hypernym/superordinate</strong>:<ul>
<li><em>vehical</em> is a hypernym of <em>car</em></li>
<li><em>fruit</em> is a hypernym of <em>mango</em></li>
</ul>
</li>
<li><strong>token</strong>: an instance of that type in running text; <mathjax>$N$</mathjax> = number of tokens, i.e. counting every word in the sentence, regardless of uniqueness.</li>
<li><strong>type</strong>: an element of the vocabulary; <mathjax>$V$</mathjax> = vocabulary = set of types (<mathjax>$|V|$</mathjax> = the size of the vocabulary), i.e. counting every unique word in the sentence.</li>
</ul>
<h2>Data preparation</h2>
<h3>Sentence segmentation</h3>
<p>"!", "?" are pretty reliable indicators that we've reached the end of a sentence. Periods can mean the end of the sentence <em>or</em> an abbreviation (e.g. Inc. or Dr.) or numbers (e.g. 4.3).</p>
<h3>Tokenization</h3>
<p><strong>Tokenization</strong> is the process of breaking up text into discrete units for analysis - this is typically into words or phrases.</p>
<p>The best approach for tokenization varies widely depending on the particular problem and language. German, for example, has many long compound words which you may want to split up. Chinese has no spaces (no easy way for <em>word segmentation</em>), Japanese has no spaces and multiple alphabets.</p>
<h3>Normalization</h3>
<p>Once you have your tokens you need to determine how to normalize them. For example, "USA" and "U.S.A." could be collapsed into a single token. But about "Windows", "window", and "windows"?</p>
<p>Some common approaches include:</p>
<ul>
<li><em>case folding</em> - reducing all letters to lower case (but sometimes case may be informative)</li>
<li><em>lemmatization</em> - reduce inflections or variant forms to base form.</li>
<li><em>stemming</em> = reducing terms of their stems; a crude chopping of affixes; a simplified version of lemmatization. The Porter stemmer is the most common English stemmer.</li>
</ul>
<h3>Term Frequency-Inverse Document Frequency (tf-idf) Weighting</h3>
<p>Using straight word counts may not be the best approach in many cases.</p>
<p>Rare terms are typically more informative than frequent terms, so we want to bias our numerical representations of tokens to give rarer words higher weights. We do this via <strong>inverse document frequency weighting</strong> (idf):</p>
<p><mathjax>$$ idf_t = \log(\frac{N}{df_t}) $$</mathjax></p>
<p>For a term <mathjax>$t$</mathjax> which appears in <mathjax>$df$</mathjax> documents (<mathjax>$df_t$</mathjax> = document frequency for <mathjax>$t$</mathjax>).</p>
<p><mathjax>$\log$</mathjax> is used here to "dampen" the effect of idf.</p>
<p>This can be combined with <mathjax>$t$</mathjax>'s term frequency <mathjax>$tf_d$</mathjax> for a particular document <mathjax>$d$</mathjax> to produce tf-idf weighting, which is the best known weighting scheme for text information retrieval:</p>
<p><mathjax>$$ w_{t,d} = (1 + \log tf_{t,d}) \times \log(\frac{n}{df_t}) $$</mathjax></p>
<h3>The Vector Space Model (VSM)</h3>
<p>This representation of text data - that is, some kind of numerical feature for each word, such as the tf-idf weight and frequency, defines a <mathjax>$|V|$</mathjax>-dimensional vector space (where <mathjax>$V$</mathjax> is the vocabulary size).</p>
<ul>
<li><em>terms</em> are the axes of space</li>
<li><em>documents</em> are points (vectors) in this space</li>
<li>this space is <em>very high-dimensional</em> when dealing with large vocabularies</li>
<li>these vectors are very <em>sparse</em> - most entries are zero</li>
</ul>
<h3>Normalizing vectors</h3>
<p>This is a different kind of normalization than the previously mentioned one, which was about normalizing the language. Here, we are normalizing vectors in a more mathematical sense.</p>
<p>Vectors can be length-normalized by dividing each of its components by its length. We can use the L2 norm, which makes it a <em>unit vector</em> ("unit" means it is of length 1):</p>
<p><mathjax>$$ ||\vec{x}||_2 = \sqrt{\sum_i x_i^2} $$</mathjax></p>
<p>This means that if we have, for example, a document and copy of that document with every word doubled, length normalization causes each to have identical vectors (without normalization, the copy would have been twice as long).</p>
<h2>Measuring similarity between text</h2>
<h3>Minimum edit distance</h3>
<p>The <strong>minimum edit distance</strong> between two strings is the minimum number of editing operations (insertion/deletion/substitution) needed to transform one into the other. Each editing operation has a cost of 1, although in <em>Levenshtein minimum edit distance</em> substitutions cost 2 because they are composed of a deletion and an insertion.</p>
<h3>Jaccard coefficient</h3>
<p>The <strong>Jaccard coefficient</strong> is a commonly-used measure of overlap for two sets <mathjax>$A$</mathjax> and <mathjax>$B$</mathjax>.</p>
<p><mathjax>$$ jaccard(A,B) = \frac{|A \cap B|}{|A \cup B|} $$</mathjax></p>
<p>A set has a Jaccard coefficient of 1 against itself: <mathjax>$jaccard(A,A) = 1$</mathjax>.</p>
<p>If <mathjax>$A$</mathjax> and <mathjax>$B$</mathjax> have no overlapping elements, <mathjax>$jaccard(A,B) = 0$</mathjax>.</p>
<p>The Jaccard coefficient does <em>not</em> consider term frequency, just set membership.</p>
<h3>Euclidean Distance</h3>
<p>Using the vector space model above, the similarity between two documents can be measured by the euclidean distance between their two vectors.</p>
<p>However, euclidean distance can be problematic since longer vectors have greater distance.</p>
<p>For instance, there could be one document vector, <mathjax>$a$</mathjax>, and another document vector <mathjax>$b$</mathjax> which is just a scalar multiple of the first document. Intuitively they may be more similar since they lie along the same line. But by euclidean distance, <mathjax>$c$</mathjax> is closer to <mathjax>$a$</mathjax>.</p>
<figure><img alt="Euclidean distances" src="../assets/euclidean_distance.svg" /><figcaption>Euclidean distances</figcaption>
</figure>
<h3>Cosine similarity</h3>
<p>In cases like the euclidean distance example above, using <em>angles</em> between vectors can be a better metric for similarity.</p>
<p>For length-normalized vectors, cosine similarity is just their dot product:</p>
<p><mathjax>$$ cos(\vec{q}, \vec{d}) = \vec{q} \cdot \vec{d} = \sum_{i=1}^{|V|} q_i d_i $$</mathjax></p>
<p>Where <mathjax>$q$</mathjax> and <mathjax>$d$</mathjax> are length-normalized vectors and <mathjax>$q_i$</mathjax> is the tf-idf weight of term <mathjax>$i$</mathjax> in document <mathjax>$q$</mathjax> and <mathjax>$d_i$</mathjax> is the tf-idf weight of term <mathjax>$i$</mathjax> in document <mathjax>$d$</mathjax>.</p>
<h2>(Probabilistic) Language Models</h2>
<p>The approach of probabilistic language models involves generating some probabilistic understanding of language - what is likely or unlikely. For example, given sentence A and sentence B, we want to be able to say whether or not sentence A is more probable sentence than sentence B.</p>
<p>We have some finite vocabulary <mathjax>$V$</mathjax>. There is an infinite set of strings ("sentences") that can be produced from <mathjax>$V$</mathjax>, notated <mathjax>$V^{\dagger}$</mathjax> (these strings have zero or more words from <mathjax>$V$</mathjax>, ending with the <code>STOP</code> symbol). These sentences may make sense, or they may not (e.g. they might be grammatically incorrect).</p>
<p>Say we have a training sample of <mathjax>$N$</mathjax> example sentences in English. We want to learn a probability distribution <mathjax>$p$</mathjax> over the possible set of sentences <mathjax>$V^{\dagger}$</mathjax>; that is, <mathjax>$p$</mathjax> is a function that satisfies:</p>
<p><mathjax>$$
\sum_{x \in V^{\dagger}} p(x) = 1, p(x) \geq 0 \text{for all} x \in V^{\dagger}
$$</mathjax></p>
<p>The goal is for likely English sentences (i.e. "correct" sentences) to be more probable than nonsensical sentences.</p>
<p>These probabilistic models have applications in many areas:</p>
<ul>
<li>Machine translation:<br />
<mathjax>$P(\text{high winds tonight}) &gt; P(\text{large winds tonight})$</mathjax>.</li>
<li>Spelling correction:<br />
<mathjax>$P(\text{about fifteen minutes from}) &gt; P(\text{about fifteen minuets from})$</mathjax>.</li>
<li>Speech recognition:<br />
<mathjax>$P(\text{I saw a van}) &gt; P(\text{eyes awe of an})$</mathjax>.</li>
</ul>
<p>So generally you are asking: what is the probability of this given sequence of words?</p>
<h3>A naive method</h3>
<p>For any sentence <mathjax>$x_1, \dots, x_n$</mathjax>, we notate the count of that sentence in the training corpus as <mathjax>$c(x_1, \dots, x_n)$</mathjax>.</p>
<p>Then we might simply say that:</p>
<p><mathjax>$$
p(x_1, \dots, x_n) = \frac{c(x_1, \dots, x_n)}{N}
$$</mathjax></p>
<p>However, this method assigns 0 probability to sentences that are not in the training corpus, thus leaving many plausible sentences unaccounted for.</p>
<h3>A less naive method</h3>
<p>You could use the <em>chain rule</em> here:</p>
<p><mathjax>$$
\begin{aligned}
P(\text{the water is so transparent}) = \\
P(\text{the}) \times P(\text{water}|\text{the}) \times P(\text{is}|\text{the water}) \\
\times P(\text{so}|\text{the water is}) \times P(\text{transparent}|\text{the water is so})
\end{aligned}
$$</mathjax></p>
<p>Formally, the above would be expressed:</p>
<p><mathjax>$$ P(w_1 w_2 \dots w_n) = \prod_i P(w_i|w_1 w_2 \dots w_{i-1}) $$</mathjax></p>
<p>Note that probabilities are usually done in <em>log space</em> to avoid <em>underflow</em>, which occurs if you're multiplying many small probabilities together, and because then you can just add the probabilities, which is faster than multiplying:</p>
<p><mathjax>$$ p_1 \times p_2 \times p_3 = \log p_1 + \log p_2 + \log p_3 $$</mathjax></p>
<p>To make estimating these probabilities manageable, we use the <em>Markov assumption</em> and assume that a given word's conditional probability only depends on the immediately preceding <mathjax>$k$</mathjax> words, <em>not</em> the entire preceding sequence (that is, that any random variable depends only on the previous random variable, and is conditionally independent of all the random variables before that):</p>
<p><mathjax>$$
P(X_1=x_1) \prod_{i=2}^n P(X_i=x_i|X_1=x_1,\dots,X_{i-1}=x_{i-1}) = P(X_1=x_1) \prod_{i=2}^n P(X_i=x_i|X_{i-1}=x_{i-1})
$$</mathjax></p>
<p>That is, for any <mathjax>$i \in {2 \dots n}$</mathjax>, for any <mathjax>$x_1, \dots, x_i$</mathjax>:</p>
<p><mathjax>$$
P(X_i=x_i|X_1=x_1,\dots,X_{i-1}=x_{i-1}) = P(X_i=x_i|X_{i-1}=x_{i-1})
$$</mathjax></p>
<p>In particular, this is the <em>first-order Markov assumption</em>; if it seems appropriate, we could instead use the <em>second-order Markov assumption</em>, where we instead assume that any random variable depends only on the previous <em>two</em> random variables:</p>
<p><mathjax>$$
P(X_1=x_1,X_2=x_2,\dots,X_n=x_n) = P(X_1=x_1)P(X_2=x_2|X_1=x_1)\prod_{i=3}^n P(X_i=x_i|X_{i-2}=x_{i-2},X_{i-1}=x_{i-1})
$$</mathjax></p>
<p>Though this is usually condensed to:</p>
<p><mathjax>$$
\prod_{i=1}^n P(X_i=x_i|X_{i-2}=x_{i-2},X_{i-1}=x_{i-1})
$$</mathjax></p>
<p>This can be extended to the third-order Markov assumption and so on.</p>
<p>In the context of language models, we define <mathjax>$x_{-1}, x_0$</mathjax> as the special "start" symbol, <mathjax>$*$</mathjax>, indicating the start of a sentence.</p>
<p>We also remove the assumption that <mathjax>$n$</mathjax> is fixed and instead consider it as a random variable. We can just define <mathjax>$X_n=\text{STOP}$</mathjax>, where <mathjax>$\text{STOP}$</mathjax> is a special symbol, <mathjax>$\text{STOP} \notin V$</mathjax>.</p>
<h3>n-gram Models</h3>
<p>The <em>unigram</em> model treats each word as if they have an independent probability:</p>
<p><mathjax>$$ P(w_1 w_2 \dots w_n) \approx \prod_i P(w_i) $$</mathjax></p>
<p>The <em>bigram</em> model conditions on the previous word:</p>
<p><mathjax>$$ P(w_1 w_2 \dots w_{i-1}) \approx \prod_i P(w_i | w_{i-1}) $$</mathjax></p>
<p>We estimate bigram probabilities using the <em>maximum likelihood estimate</em> (MLE):</p>
<p><mathjax>$$ P_{MLE}(w_i | w_{i-1}) = \frac{count(w_{i-1}, w_i)}{count(w_{i-1})} $$</mathjax></p>
<p>Which is just the count of word <mathjax>$i$</mathjax> occuring after word <mathjax>$i-1$</mathjax> over all of the occurences of word <mathjax>$i-1$</mathjax>.</p>
<p>This can be extended to trigrams, 4-grams, 5-grams, etc.</p>
<p>Though language has <strong>long-distance dependencies</strong>, i.e. the probability of a word can depend on another word much earlier in the sentence, n-grams work well in practice.</p>
<h4>Trigram Models</h4>
<p>With a trigram model, we have a parameter <mathjax>$q(w|u,v)$</mathjax> for each trigram (sequence of three words) <mathjax>$u,v,w$</mathjax> such that <mathjax>$w \in V \cup \{\text{STOP}\}$</mathjax> and <mathjax>$u,v \in V \cup \{*\}$</mathjax>.</p>
<p>For any sentence <mathjax>$x_1, \dots, x_n$</mathjax>, where <mathjax>$x_i \in V$</mathjax> for <mathjax>$i=1 \dots (n-1)$</mathjax> and <mathjax>$x_n = \text{STOP}$</mathjax>, the probability of the sentence under the trigram language model is:</p>
<p><mathjax>$$
p(x_1, \dots, x_n) = \prod{i=1}^n q(x_i|x_{i-2},x_{i-1})
$$</mathjax></p>
<p>With <mathjax>$x_{-1}, x_0$</mathjax> as the special "start" symbol, <mathjax>$*$</mathjax>.</p>
<p>(This is just a second-order Markov process)</p>
<p>So then, how do we estimate the <mathjax>$q(w_i|w_{i-2},w_{i-1})$</mathjax> parameters?</p>
<p>We could use the maximum likelihood estimate:</p>
<p><mathjax>$$
q_{\text{ML}}(w_i|w_{i-2},w_{i-1}) = \frac{\text{Count}(w_{i-2},w_{i-1},w_i)}{\text{Count}(w_{i-2},w_{i-1})}
$$</mathjax></p>
<p>However, this still has the problem of assigning 0 probability to trigrams that were not encountered in the training corpus.</p>
<p>There are also still many, many parameters to learn: if we have a vocabulary size <mathjax>$N=|V|$</mathjax>, then we have <mathjax>$N^3$</mathjax> parameters in the model.</p>
<h4>Dealing with zeros</h4>
<p>Zeroes occur if some n-gram occurs in the testing data which didn't occur in the training set.</p>
<p>Say we had the following training set:</p>
<blockquote>
<p>... denied the reports<br />
... denied the claims<br />
... denied the request</p>
</blockquote>
<p>And the following test set:</p>
<blockquote>
<p>... denied the offer</p>
</blockquote>
<p>Here <mathjax>$P(\text{offer} | \text{denied the}) = 0$</mathjax> since the model has not encountered that term.</p>
<p>We can get around this using <strong>Laplace smoothing</strong>, also known as <strong>add-one smoothing</strong>): simply pretend that we saw each word once more than we actually did (i.e. add one to all counts).</p>
<p>With add-one smoothing, our MLE becomes:</p>
<p><mathjax>$$ P_{Add-1}(w_i | w_{i-1}) = \frac{count(w_{i-1}, w_i) + 1}{count(w_{i-1}) + V} $$</mathjax></p>
<p>Note that this smoothing can be very blunt and may drastically change your counts.</p>
<h4>Interpolation</h4>
<p>Above we defined the trigram maximum-likelihood estimate. We can do the same for bigram and unigram estimates:</p>
<p><mathjax>$$
\begin{aligned}
q_{\text{ML}}(w_i|w_{i-1}) &amp;= \frac{\text{Count}(w_{i-1}, w_i)}{\text{Count}(w_{i-1})} \\
q_{\text{ML}}(w_i) &amp;= \frac{\text{Count}(w_i)}{\text{Count}()}
\end{aligned}
$$</mathjax></p>
<p>These various estimates demonstrate the bias-variance trade-off - the trigram maximum-likelihood converges to a better estimate but requires a lot more data to do so; the unigram maximum-likelihood estimate converges to a worse estimate but does so with a lot less data.</p>
<p>With linear interpolation, we try to combine the strengths and weaknesses of each of these estimates:</p>
<p><mathjax>$$
q(w_i|w_{i-2}, w_{i-1}) = \lambda_1 q_{\text{ML}}(w_i|w_{i-2},w_{i-1}) + \lambda_2 q_{\text{ML}}(w_i|w_{i-1}) + \lambda_3 q_{\text{ML}}(w_i)
$$</mathjax></p>
<p>Where <mathjax>$\lambda_1 + \lambda_2 + \lambda_3 = 1, \lambda_i \geq 0 \forall i$</mathjax>.</p>
<p>That is, we compute a weighted average of the estimates.</p>
<p>For a vocabulary <mathjax>$V' = V \cup \{\text{STOP}\}$</mathjax>, <mathjax>$\sum_{w \in V'} q(w|u,v)$</mathjax> defines a distribution, since it sums to 1.</p>
<p>How do we estimate the <mathjax>$\lambda$</mathjax> values?</p>
<p>We can take out some our training data as validation data (say ~5%). We train the maximum-likelihood estimates on the training data, then we define <mathjax>$c'(w_1, w_2, w_3)$</mathjax> as the count of a trigram in the validation set.</p>
<p>Then we define:</p>
<p><mathjax>$$
L(\lambda_1, \lambda_2, \lambda_3) = \sum_{w_1, w_2, w_3} c'(w_1, w_2, w_3) \log q(w_3|w_1,w_2)
$$</mathjax></p>
<p>And choose <mathjax>$\lambda_1, \lambda_2, \lambda_3$</mathjax> to maximize <mathjax>$L$</mathjax> (this ends up being the same as choosing <mathjax>$\lambda_1, \lambda_2, \lambda_3$</mathjax> to minimize the perplexity).</p>
<p>In practice, however, the <mathjax>$\lambda$</mathjax> values are allowed to vary.</p>
<p>We define a function <mathjax>$\Pi$</mathjax> that partitions histories, e.g.</p>
<p><mathjax>$$
\Pi(w_{i-2},w_{i-1}) =
\begin{cases}
1 &amp; \text{if Count$(w_{i-1},w_{i-2}) = 0$} \\
2 &amp; \text{if $1 \leq$ Count$(w_{i-1},w_{i-2}) \leq 2$} \\
3 &amp; \text{if $3 \leq$ Count$(w_{i-1},w_{i-2}) \leq 5$} \\
4 &amp; \text{otherwise}
\end{cases}
$$</mathjax></p>
<p>These partitions are usually chosen by hand.</p>
<p>Then we vary the <mathjax>$\lambda$</mathjax> values based on the partition:</p>
<p><mathjax>$$
q(w_i|w_{i-2}, w_{i-1}) = \lambda_1^{\Pi(w_{i-2},w_{i-1})} q_{\text{ML}}(w_i|w_{i-2},w_{i-1}) + \lambda_2^{\Pi(w_{i-2},w_{i-1})} q_{\text{ML}}(w_i|w_{i-1}) + \lambda_3^{\Pi(w_{i-2},w_{i-1})} q_{\text{ML}}(w_i)
$$</mathjax></p>
<p>Where <mathjax>$lambda_1^{\Pi(w_{i-2},w_{i-1})} + lambda_2^{\Pi(w_{i-2},w_{i-1})} + lambda^3{\Pi(w_{i-2},w_{i-1})} = 1$</mathjax> and each are <mathjax>$\geq 0$</mathjax>.</p>
<h4>Discounting methods</h4>
<p>Generally, these maximum likelihood estimates can be high, so we can define "discounted" counts, e.g. <mathjax>$\text{Count}*(x) = \text{Count}(x) - 0.5$</mathjax> (the value to discount by can be determined on a validation set, like the <mathjax>$\lambda$</mathjax> values from before). As a result of these discounted counts, we will have some probability mass left over, which is defined as:</p>
<p><mathjax>$$
\alpha(w_{i-1}) = 1 - \sum_w \frac{\text{Count}*(w_{i-1}, w)}{\text{Count}(w_{i-1})}
$$</mathjax></p>
<p>We can assign this leftover probability mass to words we have not yet seen.</p>
<p>We can use a <strong>Katz Back-Off model</strong>. First we will consider the bigram model.</p>
<p>We define two sets:</p>
<p><mathjax>$$
\begin{aligned}
A(w_{i-1}) &amp;= \{w : \text{Count}(w_{i-1},w) &gt; 0\} \\
B(w_{i-1}) &amp;= \{w : \text{Count}(w_{i-1},w) = 0\}
\end{aligned}
$$</mathjax></p>
<p>Then the bigram model:</p>
<p><mathjax>$$
q_{\text{BO}}(w_i|w_{i-1}) =
\begin{cases}
\frac{\text{Count}*(w_{i-1},w_i)}{\text{Count}(w_{i-1})} &amp; \text{if $w_i \in A(w_{i-1})$} \\
\alpha(w_{i-1}) \frac{q_{\text{ML}}(w_i)}{\sum_{w \in B(w_{i-1})} q_{\text{ML}}(w)} &amp; \text{if $w_i \in B(w_{i-1})$}
\end{cases}
$$</mathjax></p>
<p>Where</p>
<p><mathjax>$$
\alpha(w_{i-1}) = 1 - \sum_{w \in A(w_{i-1})} \frac{\text{Count}*(w_{i-1}, w)}{\text{Count}(w_{i-1})}
$$</mathjax></p>
<p>Basically, this assigns the leftover probability mass to bigrams that were not previously encountered.</p>
<p>The Katz Back-Off model can be extended to trigrams as well:</p>
<p><mathjax>$$
\begin{aligned}
A(w_{i-2},w_{i-1}) &amp;= \{w : \text{Count}(w_{i-2},w_{i-1},w) &gt; 0\} \\
B(w_{i-2},w_{i-1}) &amp;= \{w : \text{Count}(w_{i-2},w_{i-1},w) = 0\} \\
q_{\text{BO}}(w_i|w_{i-2},w_{i-1}) &amp;=
\begin{cases}
\frac{\text{Count}*(w_{i-2},w_{i-1},w_i)}{\text{Count}(w_{i-2},w_{i-1})} &amp; \text{if $w_i \in A(w_{i-2},w_{i-1})$} \\
\alpha(w_{i-2},w_{i-1}) \frac{q_{\text{BO}}(w_i|w_{i-1})}{\sum_{w \in B(w_{i-2},w_{i-1})} q_{\text{BO}}(w|w_{i-1})} &amp; \text{if $w_i \in B(w_{i-2},w_{i-1})$}
\end{cases} \\
\alpha(w_{i-2},w_{i-1}) &amp;= 1 - \sum_{w \in A(w_{i-2},w_{i-1})} \frac{\text{Count}*(w_{i-2},w_{i-1}, w)}{\text{Count}(w_{i-2},w_{i-1})}
\end{aligned}
$$</mathjax></p>
<h3>Log-Linear Models</h3>
<p>When it comes to language models, the trigram model may be insufficient. There may be more information than just the previous two words that we want to take into account - for instance, the author of a paper, whether or not a particular word occurs in an earlier context, the part of speech of the preceding word, etc.</p>
<p>We may want to do something similar when it comes to tagging, e.g. condition on that a previous word is a particular word, or that it has a particular ending ("ing", "e", etc), and so on.</p>
<p>We can use <strong>log-linear models</strong> to capture this extra information (encoded as numerical features, e.g. 1 if the preceding word is "foo", and 0 otherwise.).</p>
<p>With log-linear models, we frame the problem as such: We have some input domain <mathjax>$X$</mathjax> and a finite label set <mathjax>$Y$</mathjax>. We want to produce a conditional probability <mathjax>$p(y|x)$</mathjax> for any <mathjax>$x,y$</mathjax> where <mathjax>$x \in X, y \in Y$</mathjax>.</p>
<p>For example, in language modeling, <mathjax>$x$</mathjax> would be a "history" of words, i.e. <mathjax>$w_1, w_2, \dots, w_{i-1}$</mathjax> and <mathjax>$y$</mathjax> is an "outcome" <mathjax>$w_i$</mathjax> (i.e. the predicted following word).</p>
<p>We represent our features as vectors (applying indicator functions and so on where necessary). We'll denote a feature vector for an input/output pair <mathjax>$(x,y)$</mathjax> as <mathjax>$f(x,y)$</mathjax>.</p>
<p>We also have a parameter vector equal in length to our feature vectors (e.g. if we have <mathjax>$m$</mathjax> features, then the parameter vector <mathjax>$v \in \mathbb R^m$</mathjax>).</p>
<p>We can compute a "score" for a pair <mathjax>$(x,y)$</mathjax> as just the dot product of these two: <mathjax>$v \cdot f(x,y)$</mathjax> which we can turn into the desired conditional probability <mathjax>$p(x|y)$</mathjax>:</p>
<p><mathjax>$$
p(y|x;v) = \frac{e^{v \cdot f(x,y)}}{\sum_{y' \in Y} e^{v \cdot f(x,y')}}
$$</mathjax></p>
<p>Read as "the probability of <mathjax>$y$</mathjax> given <mathjax>$x$</mathjax> under the parameters <mathjax>$v$</mathjax>".</p>
<p>This can be re-written as:</p>
<p><mathjax>$$
\log p(y|x;v) = v \cdot f(x,y) - \log \sum_{y' \in Y} e^{v \cdot f(x,y')}
$$</mathjax></p>
<p>This is why such models are called "log-linear": the <mathjax>$v \cdot f(x,y)$</mathjax> term is the linear term and we calculate a log probability (and then there is the normalization term <mathjax>$\log \sum_{y' \in Y} e^{v \cdot f(x,y')}$</mathjax>).</p>
<p>So how do we estimate the parameters <mathjax>$v$</mathjax>?</p>
<p>We assume we have training examples <mathjax>$(x^{(i)}, y^{(i)})$</mathjax> for <mathjax>$i=1, \dots, n$</mathjax> and that each <mathjax>$(x^{(i)}, y^{(i)}) \in X \times Y$</mathjax>. We can use maximum-likelihood estimates to estimate <mathjax>$v$</mathjax>, i.e.</p>
<p><mathjax>$$
\begin{aligned}
v_{\text{ML}} &amp;= \argmax_{v \in \mathbb R^m} L(v) \\
L(v) &amp;= \sum_{i=1}^n \log p(y^{(i)}|x^{(i)}; v) = \sum_{i=1}^n v \cdot f(x^{(i)}, y^{(i)}) - \sum_{i=1}^n \log \sum_{y' \in Y} e^{v \cdot f(x^{(i)}, y')}
\end{aligned}
$$</mathjax></p>
<p>i.e. <mathjax>$L(v)$</mathjax> is the log-likelihood of the data under the parameters <mathjax>$v$</mathjax>, and it is concave so we can optimize it fairly easily with gradient ascent.</p>
<p>We can add regularization to improve generalization.</p>
<h3>History-based models</h3>
<p>The models that have been presented so far are called <strong>history-based models</strong>, in the following sense:</p>
<ul>
<li>We break structures down into a <em>derivation</em> (a sequence of decisions)</li>
<li>Each decision has an associated conditional probability</li>
<li>The probability of a structure is just the product of the decision probabilities that created it</li>
<li>The parameter values are estimated using some variant of maximum-likelihood estimation</li>
<li>When choose <mathjax>$y$</mathjax>s such that they maximize either a joint probability <mathjax>$p(x,y;\theta)$</mathjax> (e.g. in the case of HMMs or PCFGs) or a conditional probability <mathjax>$p(y|x;\theta)$</mathjax> (in the case of log-linear models).</li>
</ul>
<h3>Global Linear Models</h3>
<p>GLMs extend log-linear models though they are different than history-based models (there are no "derivations" or probabilities for "decisions").</p>
<p>In GLMs, we have feature vectors for <em>entire structures</em>, i.e. "global features". This allows us to incorporate features that are difficult to include in history-based models.</p>
<p>GLMs have three components:</p>
<ul>
<li><mathjax>$f(x,y) \in \mathbb R^d$</mathjax> which maps a structure <mathjax>$(x,y)$</mathjax> (e.g. a sentence and a parse tree) to a feature vector<mathjax>$ to a feature vector$</mathjax> to a feature vector$ to a feature vector</li>
<li><mathjax>$\text{GEN}$</mathjax> which is a function that maps an input <mathjax>$x$</mathjax> to a set of <em>candidates</em> <mathjax>$\text{GEN}(x)$</mathjax>. For example, it could return the set of all possible English translations for a French sentence <mathjax>$x$</mathjax>.</li>
<li><mathjax>$v \in \mathbb R^d$</mathjax> is a parameter vector; it is learned from training data</li>
</ul>
<p>So the final output is a function <mathjax>$F: X \to Y$</mathjax>, which ends up being:</p>
<p><mathjax>$$
F(x) = \argmax_{y \in \text{GEN}(x)} f(x,y) \cdot v
$$</mathjax></p>
<h3>Evaluating language models: perplexity</h3>
<p><strong>Perplexity</strong> is a measure of the quality of a language model.</p>
<p>Assume we have a set of <mathjax>$m$</mathjax> test sentences, <mathjax>$s_1, s_2, \dots, s_m$</mathjax>.</p>
<p>We can compute the probability of these sentences under our learned model <mathjax>$p$</mathjax>:</p>
<p><mathjax>$$
\prod_{i=1}^m p(s_i)
$$</mathjax></p>
<p>Though typically we look at log probability instead:</p>
<p><mathjax>$$
\sum^m_{i=1} \log p(s_i)
$$</mathjax></p>
<p>The perplexity is computed:</p>
<p><mathjax>$$
\begin{aligned}
\text{perplexity} &amp;= 2^{-l} \\
l &amp;= \frac{1}{M} \sum_{i=1}^m \log p(s_i)
\end{aligned}
$$</mathjax></p>
<p>Where <mathjax>$M$</mathjax> is the total number of words in the test data. Note that <mathjax>$\log$</mathjax> is <mathjax>$\log_2$</mathjax>.</p>
<p>Lower perplexity is better (because a high log probability is better, which causes perplexity to be low).</p>
<h2>Parsing</h2>
<p>The parsing problem takes some input sentence and outputs a <strong>parse tree</strong> which describes the syntactic structure of the sentence.</p>
<p>The leaf nodes of the tree are the words themselves, which are each tagged with a part-of-speech. Then these are grouped into phrases, such as noun phrases (NP) and verb phrases (VP), up to sentences (S) (these are sometimes called <strong>constituents</strong>).</p>
<p>These parse trees can describe grammatical relationships such as subject-verb, verb-object, and so on.</p>
<p>![Example of a parse tree, from <a href="https://en.wikipedia.org/wiki/Parse_tree#/media/File:Parse2.jpg">Tjo3ya</a>]</p>
<p>We can treat it as a supervised learning problem by using sentences annotated with parse trees (such data is usually called a "treebank").</p>
<h3>Context-free grammars (CFGs)</h3>
<p>A formalism for the parsing problem.</p>
<p>A context-free grammar is a four-tuple <mathjax>$G=(N, \Sigma, R, S)$</mathjax> where:</p>
<ul>
<li><mathjax>$N$</mathjax> is a set of non-terminal symbols</li>
<li><mathjax>$\Sigma$</mathjax> is a set of terminal symbols</li>
<li><mathjax>$R$</mathjax> is a set of rules of the form <mathjax>$X \to Y_1 Y_2 \dots Y_n$</mathjax> for <mathjax>$n \geq 0, X \in N, Y_i \in (N \cup \Sigma)$</mathjax></li>
<li><mathjax>$S \in N$</mathjax> is a distinguished start symbol</li>
</ul>
<p>An example CFG:</p>
<ul>
<li><mathjax>$N = \{\text{S}, \text{NP}, \text{VP}, \text{PP}, \text{DT}, \text{Vi}, \text{Vt}, \text{NN}, \text{IN}\}$</mathjax></li>
<li><mathjax>$S = \text{S}$</mathjax></li>
<li><mathjax>$\Sigma = \{\text{sleeps}, \text{saw}, \text{woman}, \text{telescope}, \text{the}, \text{with}, \text{in}\}$</mathjax></li>
<li><mathjax>$R$</mathjax> is the following set of rules:<ul>
<li><mathjax>$\text{S} \to \text{NP VP}$</mathjax></li>
<li><mathjax>$\text{VP} \to \text{Vi}$</mathjax></li>
<li><mathjax>$\text{VP} \to \text{Vt NP}$</mathjax></li>
<li><mathjax>$\text{VP} \to \text{VP PP}$</mathjax></li>
<li><mathjax>$\text{NP} \to \text{DT NN}$</mathjax></li>
<li><mathjax>$\text{NP} \to \text{NP PP}$</mathjax></li>
<li><mathjax>$\text{PP} \to \text{IN NP}$</mathjax></li>
<li><mathjax>$\text{Vi} \to \text{sleeps}$</mathjax></li>
<li><mathjax>$\text{Vt} \to \text{saw}$</mathjax></li>
<li><mathjax>$\text{NN} \to \text{man}$</mathjax></li>
<li><mathjax>$\text{NN} \to \text{woman}$</mathjax></li>
<li><mathjax>$\text{NN} \to \text{telescope}$</mathjax></li>
<li><mathjax>$\text{DT} \to \text{the}$</mathjax></li>
<li><mathjax>$\text{IN} \to \text{with}$</mathjax></li>
<li><mathjax>$\text{IN} \to \text{in}$</mathjax></li>
</ul>
</li>
</ul>
<p>Note:<br />
- S = sentence<br />
- VP = verb phrase<br />
- NP = noun phrase<br />
- PP = prepositional phrase<br />
- DT = determiner<br />
- Vi = intransitive verb<br />
- Vt = transitive verb<br />
- NN = noun<br />
- IN = preposition</p>
<p>We can <em>derive</em> sentences from this grammar.</p>
<p>A <strong>left-most derivation</strong>  is a sequence of strings <mathjax>$s_1, \dots, s_n$</mathjax> where:</p>
<ul>
<li><mathjax>$s_1 = S$</mathjax>, the start symbol</li>
<li><mathjax>$s_n \in \Sigma^*$</mathjax>; that is, <mathjax>$s_n$</mathjax> consists only of terminal symbols</li>
<li>each <mathjax>$s_i$</mathjax> for <mathjax>$i=2, \dots, n$</mathjax> is derived from <mathjax>$s_{i-1}$</mathjax> by picking the left-most non-terminal <mathjax>$X$</mathjax> in <mathjax>$s_{i-1}$</mathjax> and replacing it with some <mathjax>$\beta$</mathjax> where <mathjax>$X \to \beta$</mathjax> is a rule in <mathjax>$R$</mathjax>.</li>
</ul>
<p>Using the example grammar, we could do:</p>
<ol>
<li>"S"</li>
<li>expand "S" to "NP VP"</li>
<li>expand "NP" (since it is the left-most symbol) to "D N", yielding "D N VP"</li>
<li>expand "D" (again, it is left-most) to "the", yielding "the N VP"</li>
<li>expand "N" (since the left-most symbol "the" is a terminal symbol) to "man", yielding "the man VP"</li>
<li>expand "VP" to "Vi" (since it is the last non-terminal symbol), yielding "the man Vi"</li>
<li>expand "Vi" to "sleeps", yielding "the man sleeps"</li>
<li>the sentence consists only of terminal symbols, so we are done.</li>
</ol>
<p>Thus a CFG defines a set of possible derivations, which can be infinite.</p>
<p>We say that a string <mathjax>$s \in \Sigma^*$</mathjax> is in the <em>language</em> defined by the CFG if we can derive it from the CFG.</p>
<p>A string in a CFG may have multiple derivations - this property is called "ambiguity".</p>
<p>For instance, "fruit flies like a banana" is ambiguous in that "fruit flies" may be a noun phrase or it may be a noun and a verb.</p>
<h3>Probabilistic Context-Free Grammars (PCFGs)</h3>
<p>PCFGs are CFGs in which each rule is assigned a probability, which helps with the ambiguity problem. We can compute the probability of a particular derivation as the product of the probability of its rules.</p>
<p>We notate the probability of a rule as <mathjax>$q(\alpha \to \beta)$</mathjax>. Note that we have individual probability distributions for the left-side of each rule, e.g. <mathjax>$\sum q(\text{VP} \to \beta) = 1, \sum q(\text{NP} \to \beta = 1$</mathjax>, and so on. Another way of saying this is these distributions are conditioned on the left-side of the rule.</p>
<p>These probabilities can be learned from data as well, simply by counting all the rules in a treebank and using maximum likelihood estimates:</p>
<p><mathjax>$$
q_\text{ML}(\alpha \to \beta) = \frac{\text{Count}(\alpha \to \beta)}{\text{Count}(\alpha)}
$$</mathjax></p>
<p>Given a PCFG, a sentence <mathjax>$s$</mathjax>, and a set of trees which yield <mathjax>$s$</mathjax> as <mathjax>$\Tau(s)$</mathjax>, we want to compute <mathjax>$\argmax_{t \in \Tau(s)} p(t)$</mathjax>. That is, given a sentence, what is the most likely parse tree to have produced this sentence?</p>
<p>A challenge here is that <mathjax>$|\Tau(s)|$</mathjax> may be very large, so brute-force search is not an option. We can use the <strong>CKY algorithm</strong> instead.</p>
<p>First we will assume the CFG is in Chomsky normal form. A CFG is in <em>Chomsky normal form</em> if the rules in <mathjax>$R$</mathjax> take one of two forms:</p>
<ul>
<li><mathjax>$X \to Y_1 Y_2$</mathjax> for <mathjax>$X, Y_1, Y_2 \in N$</mathjax></li>
<li><mathjax>$X \to Y$</mathjax> for <mathjax>$X \in N, Y \in \Sigma$</mathjax></li>
</ul>
<p>In practice, any PCFG can be converted to an equivalent PCFG in Chomsky normal form by combining multiple symbols into single symbols (e.g. you can convert <mathjax>$\text{VP} \to \text{Vt NP PP}$</mathjax> by defining a new symbol <mathjax>$\text{Vt-NP} \to \text{Vt NP}$</mathjax> and then redefining <mathjax>$\text{VP} \to \text{Vt-NP PP}$</mathjax>).</p>
<p>First, let's consider the problem <mathjax>$\max_{t \in \Tau(s)} p(t)$</mathjax>.</p>
<p>Notation:</p>
<ul>
<li><mathjax>$n$</mathjax> = number of words in the sentence</li>
<li><mathjax>$w_i$</mathjax> = the <mathjax>$i$</mathjax>th word in the sentence</li>
</ul>
<p>We define a dynamic programming table <mathjax>$\pi[i,j,X]$</mathjax> which is the maximum probability of a constituent with non-terminal <mathjax>$X$</mathjax> spanning the words <mathjax>$i, \dots, j$</mathjax> inclusive. We set <mathjax>$i, j \in 1, \dots, n$</mathjax> and <mathjax>$i \leq j$</mathjax>.</p>
<p>We want to calculate <mathjax>$\max_{t \in \Tau(s) p(t)} = \pi[1,n,S]$</mathjax>, i.e. the max probability for a parse tree spanning the first through the last word of the sentence with the <mathjax>$S$</mathjax> symbol.</p>
<p>We will use a recursive definition of <mathjax>$\pi$</mathjax>.</p>
<p>The base case is: for all <mathjax>$i = 1, \dots, n$</mathjax> for <mathjax>$X \in N$</mathjax>, <mathjax>$\pi[i,i,X] = q(X \to w_i)$</mathjax>. If <mathjax>$X \to w_i$</mathjax> is not in the grammar, then <mathjax>$q(X \to w_i) = 0$</mathjax>.</p>
<p>The recursive definition is: for all <mathjax>$i = 1, \dots, (n-1)$</mathjax> and <mathjax>$j = (i+1), \dots, n$</mathjax> and <mathjax>$X \in N$</mathjax>:</p>
<p><mathjax>$$
\pi(i,j,X) = \max_{X \to YZ \in R, s \in \{i,\dots,(j-1)\}} q(X \to YZ)\pi(i,s,Y)\pi(s+1,j,Z)
$$</mathjax></p>
<p><mathjax>$s$</mathjax> is called the "split point" because it determines where the word sequence from <mathjax>$i$</mathjax> to <mathjax>$j$</mathjax> (inclusive) is split.</p>
<p>The full CKY algorithm:</p>
<p>Initialization: For all <mathjax>$i \in \{i, \dots, n\}$</mathjax>, for all <mathjax>$X \in N$</mathjax>:</p>
<p><mathjax>$$
\pi(i,i,X) =
\begin{cases}
q(X \to x_i) &amp; \text{if} X \to x_i \in R\\
0 &amp; \text{otherwise}
\end{cases}
$$</mathjax></p>
<p>Then:</p>
<ul>
<li>For <mathjax>$l = 1, \dots, (n-1)$</mathjax><ul>
<li>For <mathjax>$i = 1, \dots, (n-l)$</mathjax><ul>
<li>Set <mathjax>$j = i+1$</mathjax></li>
<li>For all <mathjax>$X \in N$</mathjax>, calculate:</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><mathjax>$$
\begin{aligned}
\pi(i,j,X) &amp;= \max_{X \to YZ \in R, s \in \{i,\dots,(j-1)\}} q(X \to YZ)\pi(i,s,Y)\pi(s+1,j,Z) \\
bp(i,j,X) &amp;= \argmax_{X \to YZ \in R, s \in \{i,\dots,(j-1)\}} q(X \to YZ)\pi(i,s,Y)\pi(s+1,j,Z) \\
\end{aligned}
$$</mathjax></p>
<p>This has the runtime <mathjax>$O(n^3 |N|^3)$</mathjax> because the <mathjax>$l$</mathjax> and <mathjax>$i$</mathjax> loops <mathjax>$n$</mathjax> times each, giving us <mathjax>$n^2$</mathjax>, then at the inner-most loop (for all <mathjax>$X \in N$</mathjax>) loops <mathjax>$|N|$</mathjax> times, then <mathjax>$X \to YZ \in R$</mathjax> has <mathjax>$|N|^2$</mathjax> values to search through because these are <mathjax>$|N|$</mathjax> choices for <mathjax>$Y$</mathjax> and <mathjax>$|N|$</mathjax> choices for <mathjax>$Z$</mathjax>. Then there are also <mathjax>$n$</mathjax> choices to search through for <mathjax>$s$</mathjax>.</p>
<h4>Weaknesses of PCFGs</h4>
<p>PCFGs (as described above) don't perform very well; they have two main shortcomings:</p>
<ul>
<li>Lack of sensitivity to lexical information<ul>
<li>that is, attachment is completely independent of the words themselves</li>
</ul>
</li>
<li>Lack of sensitivity to structural frequencies<ul>
<li>for example, with the phrase "president of a company in Africa", "in Africa" can be attached to either "president" or "company". If we were to parse this phrase, we might come up with two trees described by exactly the same rule sets, the only difference is where the PP "in Africa" is attached to. Since they are exactly the same rule sets, they have the same probability, so the PCFG can't distinguish the two. However, statistically, the "close attachment" structure (i.e. generally the PP would attach to the closer object, in this case, "company") is more frequent, so it should be preferred.</li>
</ul>
</li>
</ul>
<h4>Lexicalized PCFGs</h4>
<p>Lexicalized PCFGs deal with the above weaknesses.</p>
<p>For a non-terminal rule, we specify one its children as the "head" of the rule, which is essentially the most "important" part of the rule (e.g. for the rule <mathjax>$\text{VP} \to \text{Vt} \text{NP}$</mathjax>, the verb <mathjax>$\text{Vt}$</mathjax> is the most important semantic part and thus the head).</p>
<p>We define another set of rules which identifies the heads of our grammar's rules, e.g. "If the rule contains NN, NNS, or NNP, choose the rightmost NN, NNS, or NNP as the head".</p>
<p>Now when we construct the tree, we annotate each node with its headword (that is, the word that is in the place of the head of a rule).</p>
<p>For instance, say we have the following tree:</p>
<div class="highlight"><pre>VP
├── Vt
│   └── questioned
└── NP
    ├── DT
    │   └── the
    └── NN
        └── witness
</pre></div>


<p>We annotate each node with its headword:</p>
<div class="highlight"><pre>VP(questioned)
├── Vt(questioned)
│   └── questioned
└── NP(witness)
    ├── DT(the)
    │   └── the
    └── NN(witness)
        └── witness
</pre></div>


<p>We can revise our Chomsky Normal Form for lexicalized PCFGs by defining the rules in <mathjax>$R$</mathjax> to have one of the following three forms:</p>
<ul>
<li><mathjax>$X(h) \to_1 Y_1(h) Y_2(w)$</mathjax> for <mathjax>$X, Y_1, Y_2 \in N$</mathjax> and <mathjax>$h,w \in \Sigma$</mathjax></li>
<li><mathjax>$X(h) \to_2 Y_1(w) Y_2(h)$</mathjax> for <mathjax>$X, Y_1, Y_2 \in N$</mathjax> and <mathjax>$h,w \in \Sigma$</mathjax></li>
<li><mathjax>$X(h) \to h$</mathjax> for <mathjax>$X \in N, h \in \Sigma$</mathjax></li>
</ul>
<p>Note the subscripts on <mathjax>$\to_1, \to_2$</mathjax> which indicate which of the children is the head.</p>
<h5>Parsing lexicalized PCFGs</h5>
<p>That is, we consider rules with words, e.g. <mathjax>$\text{NN}(dog)$</mathjax> is a different rule than <mathjax>$\text{NN}(cat)$</mathjax>. By doing so, we increase the number of possible rules to <mathjax>$O(|\Sigma|^2 |N|^3)$</mathjax>, which is a lot.</p>
<p>However, given a sentence <mathjax>$w_1, w_2, \dots, w_n$</mathjax>, at most <mathjax>$O(n^2 |N|^3)$</mathjax> rules are applicable because we can disregard any rule that does not contain one of <mathjax>$w_1, w_2, \dots, w_n$</mathjax>; this makes parsing lexicalized PCFGs a bit easier (it can be done in <mathjax>$O(N^5 |N|^3)$</mathjax> time rather than <mathjax>$O(n^3|\Sigma|^2 |N|^3)$</mathjax> time, which is the runtime if we consider all possible rules).</p>
<h5>Parameter estimatino in lexicalized PCFGs</h5>
<p>In a lexicalized PCFGs, our parameters take the form:</p>
<p><mathjax>$$
q(\text{S}(\text{saw}) \to_2 \text{NP}(\text{man}) \text{VP}(\text{saw}))
$$</mathjax></p>
<p>We decompose this parameter into a product of two parameters:</p>
<p><mathjax>$$
q(\text{S} \to_2 \text{NP VP}|\text{S},\text{saw})q(\text{man}|\text{S} \to_2 \text{NP VP}, \text{saw})
$$</mathjax></p>
<p>The first term describes: given <mathjax>$\text{S}(\text{saw})$</mathjax>, what is the probability that it expands <mathjax>$\to_2 \text{NP VP}$</mathjax>?</p>
<p>The second term describes: given the rule <mathjax>$\text{S} \to_2 \text{NP VP}$</mathjax> and the headword <mathjax>$\text{saw}$</mathjax>, what is the probability that <mathjax>$\text{man}$</mathjax> is the headword of <mathjax>$\text{NP}$</mathjax>?</p>
<p>Then we used smoothed estimation for the two parameter estimates (we're using linear interpolation):</p>
<p><mathjax>$$
q(\text{S} \to_2 \text{NP VP}|\text{S},\text{saw}) = \lambda_1 q_{\text{ML}}(\text{S} \to_2 \text{NP VP}|\text{S, saw}) + \lambda_2 q_{\text{ML}}(\text{S} \to_2 \text{NP VP}|\text{S})
$$</mathjax></p>
<p>Again, <mathjax>$\lambda_1, \lambda_2 \geq 0, \lambda_1 + \lambda_2 = 1$</mathjax>.</p>
<p>To clarify:</p>
<p><mathjax>$$
\begin{aligned}
q_{\text{ML}}(\text{S} \to_2 \text{NP VP}|\text{S, saw}) &amp;= \frac{\text{Count}(\text{S(saw)} \to_2 \text{NP VP})}{\text{Count}(\text{S(saw)})} \\
q_{\text{ML}}(\text{S} \to_2 \text{NP VP}|\text{S}) &amp;= \frac{\text{Count}(\text{S} \to_2 \text{NP VP})}{\text{Count}(\text{S})}
\end{aligned}
$$</mathjax></p>
<p>Here is the linear interpolation for the second parameter:</p>
<p><mathjax>$$
q(\text{man}|\text{S} \to_2 \text{NP VP},\text{saw}) = \lambda_3 q_{\text{ML}}(\text{man}|\text{S} \to_2 \text{NP VP},\text{saw}) + \lambda_4 q_{\text{ML}}(\text{man}|\text{S} \to_2 \text{NP VP}) + \lambda_5 q_{\text{ML}}(\text{man}|\text{NP})
$$</mathjax></p>
<p>Again, <mathjax>$\lambda_3, \lambda_4, \lambda_5 \geq 0, \lambda_3 + \lambda_4 + \lambda_5 = 1$</mathjax>.</p>
<p>To clarify, <mathjax>$q_{\text{ML}}(\text{man}|\text{NP})$</mathjax> describes: given <mathjax>$\text{NP}$</mathjax>, what is the probability that its headword is <mathjax>$\text{man}$</mathjax>?</p>
<p>This presentation of PCFGs do not deal with the close attachment issue as described earlier, though there are modified forms which do.</p>
<h2>Text Classification</h2>
<p>The general text classification problem is given an input document <mathjax>$d$</mathjax> and a fixed set of classes <mathjax>$C = \{c_1, c_2, \dots, c_j\}$</mathjax> output a predicted class <mathjax>$c \in C$</mathjax>.</p>
<h3>Naive Bayes</h3>
<p>This supervised approach to classification is based on Bayes' rule. It relies on a very simple representation of the document called "bag of words", which is ignorant of the sequence or order of word occurrence (and other things), and only pays attention to their counts/frequency.</p>
<p>So you can represent the problem with Bayes' rule:</p>
<p><mathjax>$$
P(c|d) = \frac{P(d|c)P(c)}{P(d)}
$$</mathjax></p>
<p>And the particular problem at hand is finding the class which maximizes <mathjax>$P(c|d)$</mathjax>, that is:</p>
<p><mathjax>$$
\begin{aligned}
C_{MAP} &amp;= \text{argmax}_{c \in C} P(c|d)
&amp;= \text{argmax}_{c \in C} P(d|c)P(c)
\end{aligned}
$$</mathjax></p>
<p>Where <mathjax>$C_{MAP}$</mathjax> is the maximum a posteriori class.</p>
<p>Using our bag of words assumption, we represent a document as features <mathjax>$x_1, \dots x_n$</mathjax> without concern for their order:</p>
<p><mathjax>$$ C_{MAP} = \text{argmax}_{c \in C} P(x_1, x_2, \dots, x_n | c)P(c) $$</mathjax></p>
<p>We additionally assume <em>conditional independence</em>, i.e. that the presence of one word doesn't have any impact on the probability of any other word's occurrence:</p>
<p><mathjax>$$ P(x_1, x_2, \dots, x_n | c) = P(x_1 | c) \cdot P(x_2 | c) \cdot \dots \cdot P(x_n | c) $$</mathjax></p>
<p>And thus we have the <em>multinomial naive bayes classifier</em>:</p>
<p><mathjax>$$ C_{NB} = \text{argmax}_{c \in C} P(c_j) \prod_{x \in X} P(x | c) $$</mathjax></p>
<p>To calculate the prior probabilities, we use the <em>maximum likelihood estimates</em> approach:</p>
<p><mathjax>$$ P(c_j) =  \frac{\text{doccount}(C = c_j)}{N_{doc}} $$</mathjax></p>
<p>That is, the prior probability for a given class is the count of documents in that class over the total number of documents.</p>
<p>Then, for words:</p>
<p><mathjax>$$ P(w_i | c_j) = \frac{count(w_i, c_j)}{\sum_{w \in V}count(w, c_j)} $$</mathjax></p>
<p>That is, the count of a word in documents of a given class, over the total count of words in that class.</p>
<p>To get around the problem of zero probabilities (for words encountered in test input but not in training, which would cause a probability of a class to be zero since the probability of a class is the joint probability of the words encountered), you can use Laplace smoothing (see above):</p>
<p><mathjax>$$ P(w_i | c_j) = \frac{count(w_i, c_j) + 1}{(\sum_{w \in V}count(w, c_j)) + |V|} $$</mathjax></p>
<p>Note that to avoid underflow (from multiplying lots of small probabilities), you may want to work with log probabilities (see above).</p>
<p>In practice, even with all these assumptions, Naive Bayes can be quite good:</p>
<ul>
<li>Very fast, low storage requirements</li>
<li>Robust to irrelevant features (they tend to cancel each other out)</li>
<li>Very good in domains with many equally important features</li>
<li>Optimal if independence assumptions hold</li>
<li>A good, dependable baseline for text classification</li>
</ul>
<h3>Evaluating text classification</h3>
<p>The possible outcomes are:</p>
<ul>
<li>true positive: correctly identifying something as true</li>
<li>false positive: incorrectly identifying something as true</li>
<li>true negative: correctly identifying something as false</li>
<li>false negative: incorrectly identifying something as false</li>
</ul>
<p>The <em>accuracy</em> of classification is calculated as:</p>
<p><mathjax>$$ \text{accuracy} = \frac{tp + tn}{tp + fp + fn + fn} $$</mathjax></p>
<p>Though as a metric it isn't very useful if you are dealing with situations where the correct class is sparse and most words you encounter are not in the correct class:</p>
<blockquote>
<p>Say you're looking for a word that only occurs 0.01% of the time. you have a classifier you run on 100,000 docs and the word appears in 10 docs (so 10 docs are correct, 99,990 are not correct). but you can have that classifier classify all docs as not correct and get an amazing accuracy of 99,990/100,000 = 99.99% but the classifier didn't actually do anything!</p>
</blockquote>
<p>So other metrics are needed.</p>
<p><em>Precision</em> measures the percent of selected items that are correct:</p>
<p><mathjax>$$ \text{precision} = \frac{tp}{tp + fp} $$</mathjax></p>
<p><em>Recall</em> measures the percent of correct items that are selected:</p>
<p><mathjax>$$ \text{recall} = \frac{tp}{tp = fn} $$</mathjax></p>
<p>Typically, there is a trade off between recall and precision - the improvement of one comes at the sacrifice of the other.</p>
<p>The <em>F measure</em> combines both precision and recall into a single metric:</p>
<p><mathjax>$$ F = \frac{1}{\alpha \frac{1}{P} + (1-\alpha) \frac{1}{R}} = \frac{(\beta^2 + 1)PR}{\beta^2 P + R} $$</mathjax></p>
<p>Where <mathjax>$\alpha$</mathjax> is a weighting value so you can assign more importance to either precision or recall.</p>
<p>People usually use the <em>balanced F1 measure</em>, where <mathjax>$\beta = 1$</mathjax> (that is, <mathjax>$\alpha = 1/2$</mathjax>):</p>
<p><mathjax>$$ F = \frac{2PR}{P+R} $$</mathjax></p>
<h2>Tagging</h2>
<p>A class of NLP problems in which we want to assign a tag to each word in an input sentence.</p>
<ul>
<li><strong>Part-of-speech tagging</strong>: Given an input sentence, output a POS tag for each word. Like in many NLP problems, ambiguity makes this a difficult task.</li>
<li><strong>Named entity recognition</strong>: Given an input sentence, identify the <em>named entities</em> in the sentence (e.g. a company, or location, or person, etc) and what type the entity is (other words are tagged as non-entities). Entities can span multiple words, so there will often be "start" and "continue" tags (e.g. for "Wall Street", "Wall" is tagged as "start company", and "Street" is tagged as "continue company").</li>
</ul>
<p>There are two types of constraints in tagging problems:</p>
<ul>
<li><em>local</em>: words with multiple meanings can have a bias (a "local preference") towards one meaning (i.e. one meaning is more likely than the others)</li>
<li><em>contextual</em>: certain meanings of a word are more likely in certain contexts</li>
</ul>
<p>These constraints can sometimes conflict.</p>
<h3>Generative models</h3>
<p>One approach to tagging problems (and supervised learning in general) is to use a <em>conditional model</em> (often called a <em>discriminative model</em>), i.e. to learn the distribution <mathjax>$p(y|x)$</mathjax> and select <mathjax>$\argmax_y p(y|x)$</mathjax> as the label.</p>
<p>Alternatively, we can use a <em>generative model</em> which instead learns the distribution <mathjax>$p(x,y)$</mathjax>. We often have <mathjax>$p(x,y) = p(y)p(x|y)$</mathjax>, where <mathjax>$p(y)$</mathjax> is the <em>prior</em> and <mathjax>$p(x|y)$</mathjax> is the <em>conditional generative model</em>.</p>
<p>This is generative because we can use this to generate new sentences by sampling the distribution given the words we have so far.</p>
<p>We can apply Bayes' Rule as well to derive the conditional distribution as well:</p>
<p><mathjax>$$
p(y|x) = \frac{p(y)p(x|y)}{p(x)}
$$</mathjax></p>
<p>Where <mathjax>$p(x) = \sum_y p(y)p(x|y)$</mathjax>.</p>
<p>Again, we can select <mathjax>$\argmax_y p(y|x)$</mathjax> as the label, but we can apply Bayes' Rule to equivalently get <mathjax>$\argmax_y \frac{p(y)p(x|y)}{p(x)}$</mathjax>. But note that <mathjax>$p(x)$</mathjax> does not vary with <mathjax>$y$</mathjax> (i.e. it is constant), so it does not affect the <mathjax>$\argmax$</mathjax>, and we can just drop it to get <mathjax>$\argmax_y p(x)p(x|y)$</mathjax>.</p>
<h3>Hidden Markov Models (HMM)</h3>
<p>An example of a generative model.</p>
<p>We have an input sentence <mathjax>$x = x_1, x_2, \dots, x_n$</mathjax> where <mathjax>$x_i$</mathjax> is the <mathjax>$i$</mathjax>th word in the sentence.</p>
<p>We also have a tag sequence <mathjax>$y = y_1, y_2, \dots, y_n$</mathjax> where <mathjax>$y_i$</mathjax> is the tag for the <mathjax>$i$</mathjax>th word in the sentence.</p>
<p>We can use a HMM to define the joint distribution <mathjax>$p(x_1, x_2, \dots, x_n, y_1, y_2, \dots, y_n)$</mathjax>.</p>
<p>Then the most likely tag sequence for <mathjax>$x$</mathjax> is <mathjax>$\argmax_{y_1,\dots,y_n} p(x_1, x_2, \dots, x_n, y_1, y_2, \dots, y_n)$</mathjax>.</p>
<h4>Trigram HMMs</h4>
<p>For any sentence <mathjax>$x_1, \dots, x_n$</mathjax> where <mathjax>$x_i \in V$</mathjax> for <mathjax>$i = 1, \dots, n$</mathjax> and any tag sequence <mathjax>$y_1, \dots, y_{n+1}$</mathjax> where <mathjax>$y_i \in S$</mathjax> for <mathjax>$i = 1, \dots, n$</mathjax> and <mathjax>$y_{n+1} = \text{STOP}$</mathjax> (where <mathjax>$S$</mathjax> is the set of possible tags, e.g. DT, NN, VB, P, ADV, etc), the joint probability of the sentence and tag sequence is:</p>
<p><mathjax>$$
p(x_1, \dots, x_n, y_1, \dots, y_{n+1}) = \prod_{i=1}^{n+1} q(y_i|y_{i-2}, y_{i-1}) \prod_{i=1}^n e(x_i|y_i)
$$</mathjax></p>
<p>Again we assume that <mathjax>$x_0 = x_{-1} = *$</mathjax>.</p>
<p>The parameters for this model are:</p>
<table>
<thead>
<tr>
<th>- $q(s</th>
<th>u,v)<mathjax>$ for any $</mathjax>s \in S \cup {\text{STOP}}, u, v \in S \cup {*}$</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>The first product is the (second-order) Markov chain, quite similar to the trigram Markov chain used before for language modeling, and the <mathjax>$e(x_i|y_i)$</mathjax> terms of the second product are what we have observed. Combined, these produce a hidden Markov model (the Markov chain is "hidden", since we don't observe the tag sequences, we only observe the <mathjax>$x_i$</mathjax>s).</p>
<h4>Parameter estimation in HMMs</h4>
<p>For the <mathjax>$q(y_i|y_{i-2},y_{i-1})$</mathjax> parameters, we can again use a linear interpolation with maximum likelihood estimates approach as before with the trigram language model.</p>
<p>For the emission parameters, we can also use a maximum likelihood estimate:</p>
<p><mathjax>$$
e(x|y) = \frac{\text{Count}(y, x)}{\text{Count}(y)}
$$</mathjax></p>
<p>However, we again have the issue that <mathjax>$e(x|y) = 0$</mathjax> for all <mathjax>$y$</mathjax> if we have never seen <mathjax>$x$</mathjax> in the training data. This will cause the entire joint probability <mathjax>$p(x_1, \dots, x_n, y_1, \dots, y_{n+1})$</mathjax> to become 0.</p>
<p>How do we deal with low-frequency words then?</p>
<p>We can split the vocabulary into two sets:</p>
<ul>
<li>frequent words: occurring <mathjax>$\geq t$</mathjax> times in the training data, where <mathjax>$t$</mathjax> is some threshold (e.g. <mathjax>$t=5$</mathjax>)</li>
<li>low-frequency words: all other words, including those not seen in the training data</li>
</ul>
<p>Then map low-frequency words into a small, finite set depending on textual features, such as prefixes, suffixes, etc. For example, we may map all all-caps words (e.g. IBM, MTA, etc) to a word class "allCaps", and we may map all four-digit numbers (e.g. 1988, 2010, etc) to a word class "fourDigitNum", or all first words of sentences to a word class "firstWord", and so on.</p>
<h3>The Viterbi algorithm</h3>
<p>We want to compute <mathjax>$\argmax_{y_1,\dots,y_n} p(x_1, x_2, \dots, x_n, y_1, y_2, \dots, y_n)$</mathjax>, but we don't want to do so via brute-force search. The search space is far too large, growing exponentially with <mathjax>$n$</mathjax> (the search space's size is <mathjax>$|S|^n$</mathjax>).</p>
<p>A more efficient way of computing this is to use the <strong>Viterbi algorithm</strong>:</p>
<p>Define <mathjax>$S_k$</mathjax> for <mathjax>$k=-1, \dots, n$</mathjax> to be the set of possible tags at position <mathjax>$k$</mathjax>:</p>
<p><mathjax>$$
\begin{aligned}
S_{-1} &amp;= S_0 = \{*\} \\
S_k &amp;= S \forall k \in \{1, \dots, n\}
\end{aligned}
$$</mathjax></p>
<p>Then we define:</p>
<p><mathjax>$$
r(y_{-1}, y_0, y_1, \dots, y_k) = \prod_{i=1}^k q(y_i|y_{i-2}, y_{i-1}) \prod_{i=1}^k e(x_i|y_i)
$$</mathjax></p>
<p>This computes the probability from our HMM for a given sequence of tags, <mathjax>$y_{-1}, y_0, y_1, \dots, y_k$</mathjax>, but only up to the <mathjax>$k$</mathjax>th position.</p>
<p>We define a dynamic programming table: <mathjax>$\pi(k,u,v)$</mathjax> as the maximum probability of a tag sequence ending in tags <mathjax>$u, v$</mathjax> at position <mathjax>$k$</mathjax>, i.e:</p>
<p><mathjax>$$
\pi(k,u,v) = \max_{(y_{-1}, y_0, y_1, \dots, y_k):y_{k-1}=u,y_k=v} r(y_{-1}, y_0, y_1, \dots, y_k)
$$</mathjax></p>
<p>To clarify: <mathjax>$k \in \{1, \dots, n\}, u \in S_{k-1}, v \in S_k$</mathjax>.</p>
<p>For example: say we have the sentence "The man saw the dog with the telescope", which we re-write as "START START The Man saw the dog with the telescope". We'll set <mathjax>$S_k=\{D,N,V,P\}$</mathjax> for <mathjax>$k \geq 1$</mathjax> and <mathjax>$S_{-1}=S_0=\{*\}$</mathjax>.</p>
<p>If we want to compute <mathjax>$\pi(7,P,D)$</mathjax>, then <mathjax>$k=7$</mathjax> so then fix the 7th term with the <mathjax>$D$</mathjax> tag and the <mathjax>$k-1$</mathjax> term with the <mathjax>$P$</mathjax> tag. Then we consider all possible tag sequences (ending with <mathjax>$P, D$</mathjax>) up to the 7th term (e.g. <mathjax>$*, D, N, V, P, P, P, D$</mathjax> and so on) and get the probability of the most likely sequence.</p>
<p>We can re-define the above recursively.</p>
<p>The base case is <mathjax>$\pi(0, *, *) = 1$</mathjax> since we always have the two START tokens tagged as <mathjax>$*$</mathjax> at the beginning.</p>
<p>Then, for any <mathjax>$k \in \{1, \dots, n\}$</mathjax> for any <mathjax>$u \in S_{k-1}$</mathjax> and <mathjax>$v \in S_k$</mathjax>:</p>
<p><mathjax>$$
\pi(k, u, v) = \max_{w \in S_{k-2}} (\pi(k-1, w, u)q(v|w,u)e(x_k|v))
$$</mathjax></p>
<p>The <strong>Viterbi algorithm</strong> is just the application of this recursive definition while keeping backpointers to the tag sequences with max probability:</p>
<ul>
<li>For <mathjax>$k=1, \dots, n$</mathjax><ul>
<li>For <mathjax>$u \in S_{k-1}, v \in S_k$</mathjax><table>
<thead>
<tr>
<th>- $\pi(k, u, v) = \max_{w \in S_{k-2}} (\pi(k-1, w, u)q(v</th>
<th>w,u)e(x_k</th>
<th>v))$</th>
</tr>
</thead>
<tbody></tbody>
</table>
</li>
</ul>
</li>
<li>Set <mathjax>$(y_{n-1}, y_n) = \argmax_{(u,v)} (\pi(n,u,v)q(\text{STOP}|u,v))$</mathjax></li>
<li>For <mathjax>$k=(n-2), \dots, 1, y_k = bp(k+2, y_{k_1}, y_{k+2})$</mathjax></li>
<li>Return the tag sequence <mathjax>$y_1, \dots, y_n$</mathjax></li>
</ul>
<p>It has the runtime <mathjax>$O(n|S|^3)$</mathjax> because of the loop over <mathjax>$k$</mathjax> value (for <mathjax>$k=1, \dots, n$</mathjax>, so this happens <mathjax>$n$</mathjax> times), then its inner loops over <mathjax>$S$</mathjax> twice (for <mathjax>$u \in S_{k-1}$</mathjax> and for <mathjax>$v \in S_k$</mathjax>), with each loop searching over <mathjax>$|S|$</mathjax>.</p>
<h2>Named Entity Recognition (NER)</h2>
<p>Named entity recognition is the extraction of <em>entities</em> - people, places, organizations, etc - from a text.</p>
<p>Many systems use a combination of statistical techniques, linguistic parsing, and gazetteers to maximize detection recall &amp; precision.  Distant supervision and unsupervised techniques can also help with training, limiting the amount of gold-standard data necessary to build a statistical model.</p>
<p><em>Boundary errors</em> are common in NER:</p>
<blockquote>
<p>First <em>Bank of Chicago</em> announced earnings...</p>
</blockquote>
<p>Here, the extractor extracted "Bank of Chicago" when the correct entity is the "First Bank of Chicago".</p>
<p>A general NER approach is to use supervised learning:</p>
<ol>
<li>Collect a set of training documents</li>
<li>Label each entity with its entity type or <code>O</code> for "other".</li>
<li>Design feature extractors</li>
<li>Train a sequence classifier to predict the labels from the data.</li>
</ol>
<h2>Relation Extraction</h2>
<blockquote>
<p>International Business Machines Corporation (IBM or the company) was incorporate in the State of New York on June 16, 1911, as the Computing-Tabulating-Recording Co. (C-T-R)...</p>
</blockquote>
<p>From such a text you could extract the following <em>relation triples</em>:</p>
<pre><code>Founder-year(IBM,1911)
Founding-location(IBM,New York)
</code></pre>
<p>These relations may be represented as <em>resource description framework (RDF) triples</em> in the form of <code>subject predicate object</code>.</p>
<blockquote>
<p>Golden Gate Park location San Francisco</p>
</blockquote>
<h3>Ontological Relations</h3>
<ul>
<li>
<p><code>IS-A</code> describes a subsumption between classes, called a <em>hypernum</em>:</p>
<blockquote>
<p>Giraffe IS-A ruminant IS-A ungulate IS-A mammal IS-A vertebrate IS-A animal...</p>
</blockquote>
</li>
<li>
<p><code>instance-of</code> relation between individual and class</p>
<blockquote>
<p>San Francisco instance-of city</p>
</blockquote>
</li>
</ul>
<p>There may be many domain-specific ontological relations as well, such as <code>founded</code> (between a <code>PERSON</code> and an <code>ORGANIZATION</code>), <code>cures</code> (between a <code>DRUG</code> and a <code>DISEASE</code>), etc.</p>
<h3>Methods</h3>
<p>Relation extractors can be built using:</p>
<ul>
<li>handwritten patterns</li>
<li>supervised machine learning</li>
<li>semi-supervised and unsupervised<ul>
<li>bootstrapping (using seeds)</li>
<li>distance supervision</li>
<li>unsupervised learning from the web</li>
</ul>
</li>
</ul>
<h4>Handwritten patterns</h4>
<ul>
<li>Advantages:<ul>
<li>can take advantage of domain expertise</li>
<li>human patterns tend to be high-precision</li>
</ul>
</li>
<li>Disadvantages:<ul>
<li>human patterns are often low-recall</li>
<li>hard to capture all possible patterns</li>
</ul>
</li>
</ul>
<h4>Supervised</h4>
<ul>
<li>Advantages:<ul>
<li>can get high accuracy if...<ul>
<li>there's enough hand-labeled training data</li>
<li>if the test is similar enough to training</li>
</ul>
</li>
</ul>
</li>
<li>Disadvantages:<ul>
<li>labeling a large training set is expensive</li>
<li>don't generalize well</li>
</ul>
</li>
</ul>
<p>You could use classifiers: find all pairs of named entities, then use a classifier to determine if the two are related or not.</p>
<h4>Unsupervised</h4>
<p>If you have no training set and either only a few seed tuples or a few high-precision patterns, you can <em>bootstrap</em> and use the seeds to accumulate more data.</p>
<p>The general approach is:</p>
<ol>
<li>Gather a set of seed pairs that have a relation <mathjax>$R$</mathjax></li>
<li>Iterate:<ol>
<li>Find sentences with these pairs</li>
<li>Look at the context between or around the pair</li>
<li>Generalize the context to create patterns</li>
<li>Use these patterns to find more pairs</li>
</ol>
</li>
</ol>
<p>For example, say we have the seed tuple <mathjax>$&lt;\text{Mark Twain, Elmira}&gt;$</mathjax>. We could use Google or some other set of documents to search based on this tuple. We might find:</p>
<ul>
<li>"Mark Twain is buried in Elmira, NY"</li>
<li>"The grave of Mark Twain is in Elmira"</li>
<li>"Elmira is Mark Twain's final resting place"</li>
</ul>
<p>which gives us the patterns:</p>
<ul>
<li>"X is buried in Y"</li>
<li>"The grave of X is in Y"</li>
<li>"Y is X's final resting place"</li>
</ul>
<p>Then we can use these patterns to search and find more tuples, then use those tuples to find more patterns, etc.</p>
<p>Two algorithms for this bootstrapping is the Dipre algorithm and the Snowball algorithm, which is a version of Dipre which requires the strings be named entities rather than any string.</p>
<p>Another semi-supervised algorithm is <em>distance supervision</em>, which mixes bootstrapping and supervised learning. Instead of a few seeds, you use a large database to extract a large number of seed examples and go from there:</p>
<ol>
<li>For each relation <mathjax>$R$</mathjax></li>
<li>For each tuple in a big database</li>
<li>Find sentences in a large corpus with both entities of the tuple</li>
<li>Extract frequent contextual features/patterns</li>
<li>Train a supervised classifier using the extracted patterns</li>
</ol>
<h2>Sentiment Analysis</h2>
<p>In general, sentiment analysis involves trying to figure out if a sentence/doc/etc is positive/favorable or negative/unfavorable; i.e. detecting <em>attitudes</em> in a text.</p>
<p>The attitude may be</p>
<ul>
<li>a simple weighted polarity (positive, negative, neutral), which is more common</li>
<li>from a set of types (like, love, hate, value, desire, etc)</li>
</ul>
<p>When using multinomial Naive Bayes for sentiment analysis, it's often better to use <em>binarized</em> multinomial Naive Bayes under the assumption that word occurrence matters more than word frequency: seeing "fantastic" five times may not tell us much more than seeing it once. So in this version, you would cap word frequencies at one.</p>
<p>An alternate approach is to use <mathjax>$\log(freq(w))$</mathjax> instead of 1 for the count.</p>
<p>However, sometimes raw word counts don't work well either. In the case of IMDB ratings, the word "bad" appears in more 10-star reviews than it does in 2-star reviews!</p>
<p>Instead, you'd calculate the <em>likelihood</em> of that word occurring in an <mathjax>$n$</mathjax>-star review:</p>
<p><mathjax>$$
P(w|c) = \frac{f(w,c)}{\sum_{w \in C} f(w,c)}
$$</mathjax></p>
<p>And then you'd used the <em>scaled likelihood</em> to make these likelihoods comparable between words:</p>
<p><mathjax>$$
\frac{P(w|c)}{P(w)}
$$</mathjax></p>
<h3>Sentiment Lexicons</h3>
<p>Certain words have specific sentiment; there are a variety of sentiment lexicons which specify those relationships.</p>
<h3>Challenges</h3>
<h4>Negation</h4>
<p>"I <em>didn't</em> like this movie" vs "I <em>really</em> like this movie."</p>
<p>One way to handle negation is to prefix every word following a negation word with <code>NOT_</code>, e.g. "I didn't NOT_like NOT_this NOT_movie".</p>
<h4>"Thwarted Expectations" problem</h4>
<p>For example, a film review which talks about how great a film <em>should</em> be, but fails to live up to those expectations:</p>
<blockquote>
<p>This film should be <em>brilliant</em>. It sounds like a <em>great</em> plot, the actors are <em>first grade</em>, and the supporting cast is <em>good</em> as well, and Stallone is attempting to deliver a good performance. However, it <em>can't hold up</em>.</p>
</blockquote>
<h2>Summarization</h2>
<p>Generally, sumamrization is about producing an abridged version of a text without or with minimal loss of important information.</p>
<p>There are a few ways to categorize summarization problems.</p>
<ul>
<li>Single-document vs multi-document summarization: summarizing a single document, yielding an abstract or outline or headline, or producing a gist of the content of multiple documents?</li>
<li>Generic vs query-focused summarization: give a general summary of the document, or a summary tailored to a particular user query?</li>
<li>Extractive vs abstractive: create a summary from sentences pulled from the document, or generate new text for the summary?</li>
</ul>
<p>Here, extractive summarization will be the focus (abstractive summarization is really hard).</p>
<p>The <em>baseline</em> used in summarization, which often works surprisingly well, is just to take the first sentence of a document.</p>
<h3>The general approach</h3>
<p>Summarization usually uses this process:</p>
<ol>
<li>
<p>Content Selection: choose what sentences to use from the document.</p>
<ul>
<li>
<p>You may weight salient words based on tf-idf, its presence in the query (if there is one), or based on topic signature.</p>
<ul>
<li>
<p>For the latter, you can use <em>log-likelihood ratio</em> (LLR):</p>
<p><mathjax>$$ weight(w_i) = \begin{cases} 1 &amp; \text{if} -2\log\lambda(w_i)&gt;10 \\ 0 &amp; \text{otherwise} \end{cases} $$</mathjax></p>
</li>
</ul>
</li>
<li>
<p>Weight a sentence (or a part of a sentence, i.e. a <em>window</em>) by the weights of its words:</p>
<p><mathjax>$$ weight(s) = \frac{1}{|S|} \sum_{w \in S} weight(w) $$</mathjax></p>
</li>
<li>
<p>You can combine LLR with <em>maximal marginal relevance</em> (MMR), which is a greedy algorithm which selects sentences by their similarity to the query and by their dissimilarity (novelty) to already-selected sentences to avoid redundancy.</p>
</li>
</ul>
</li>
<li>
<p>Information Ordering: choose the order for the sentences in the summary.</p>
<ul>
<li>If you are summarizing documents with some chronological order to them, such as the news, then it makes sense to order sentences chronologically (if you are, for example, summarizing a set of news articles).</li>
<li>You can also use <em>topical ordering</em>, and order sentences by the order of topics in the source documents.</li>
<li>You can also use <em>coherence</em>:<ul>
<li>Choose orderings that make neighboring sentences (cosine) similar.</li>
<li>Choose orderings in which neighboring sentences discuss the same entity.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Sentence Realization: clean up the sentences so that the summary is coherent or remove unnecessary content. You could remove:</p>
<ul>
<li><em>appositives</em>: "Rajam[, an artist living in Philadelphia], found inspiration in the back of city magazines."</li>
<li><em>attribution clauses</em>: "Sources said Wednesday"</li>
<li><em>initial adverbials</em>: "For example", "At this point"</li>
</ul>
</li>
</ol>
<h2>Machine Translation</h2>
<h3>Challenges in machine translation</h3>
<ul>
<li><strong>lexical ambiguity</strong> (e.g. "bank" as financial institution, or as in a "river bank")</li>
<li>differing <strong>word orders</strong> (e.g. English is subject-verb-object and Japanese is subject-object-verb)</li>
<li><strong>syntactic structure</strong> can vary across languages (e.g. "The bottle floated into the cave" when translated into Spanish has the literal meaning "the bottle entered the cave floating"; the verb "floated" becomes an adverb "floating" modifying "entered")</li>
<li><strong>syntactic ambiguity</strong> (e.g. "John hit the dog with the stick" can have two different translations depending on whether "with the stick" attaches to "John" or to "hit the dog")</li>
<li><strong>pronoun resolution</strong> (e.g. "The computer outputs the data; it is stored in ASCII" - what is "it" referring to?)</li>
</ul>
<h3>Classical machine translation methods</h3>
<p>Early machine translation methods used <em>direct</em> machine translation, which involved translating word-by-word by using a set of rules for translating particular words. Once the words are translated, reordering rules are applied.</p>
<p>But such rule-based systems quickly become unwieldy and fail to encompass the variety of ways words can be used in languages.</p>
<p>There are also <em>transfer-based</em> approaches, which have three phases:</p>
<ol>
<li>Analysis: analyze the source language sentence (e.g. a syntactic analysis to generate a parse tree)</li>
<li>Transfer: convert the source-language parse tree to a target-language parse tree based on a set of rules</li>
<li>Generation: convert the target-language parse tree to an output sentence</li>
</ol>
<p>Another approach is <em>interlingua-based</em> translation, which involves two phases:</p>
<ol>
<li>Analysis: analyze the source language sentence into a language-independent representation of its meaning</li>
<li>Generation: convert the meaning representation into an output sentence</li>
</ol>
<h3>Statistical machine translation methods</h3>
<p>If we have parallel corpora (parallel meaning that they "line up") for the source and target languages, we can use these as training sets for translation (that is, used a supervised learning approach rather than a rule-based one).</p>
<h4>The Noisy Channel Model</h4>
<p>The noisy channel model has two components:</p>
<ul>
<li><mathjax>$p(e)$</mathjax>, the language model (trained from just the target corpus, could be, for example, a trigram model)</li>
<li><mathjax>$p(f|e)$</mathjax>, the translation model</li>
</ul>
<p>Where <mathjax>$e$</mathjax> is a target language sentence (e.g. English) and <mathjax>$f$</mathjax> is a source language sentence (e.g. French).</p>
<p>We want to generate a model <mathjax>$p(e|f)$</mathjax> which estimates the conditional probability of a target sentence <mathjax>$e$</mathjax> given the source sentence <mathjax>$f$</mathjax>.</p>
<p>So we have the following, using Bayes' Rule:</p>
<p><mathjax>$$
\begin{aligned}
p(e|f) &amp;= \frac{p(e,f)}{p(f)} = \frac{p(e)p(f|e)}{\sum_e p(e)p(f|e)} \\
\argmax_e p(e|f) &amp;= \argmax_e p(e)p(f|e)
\end{aligned}
$$</mathjax></p>
<h4>IBM translation models</h4>
<h5>IBM Model 1</h5>
<p>We want to model <mathjax>$p(f|e)$</mathjax>, where <mathjax>$e$</mathjax> is the source language sentence with <mathjax>$l$</mathjax> words, and <mathjax>$f$</mathjax> is the target language sentence with <mathjax>$m$</mathjax> words.</p>
<p>We say that an <em>alignment</em> <mathjax>$a$</mathjax> identifies which source word each target word originated from; that is, <mathjax>$a = \{a_1, \dots, a_m \}$</mathjax> where each <mathjax>$a_j \in \{0, \dots, l\}$</mathjax>, and if <mathjax>$a_j=0$</mathjax> then it does not align to any word.</p>
<p>There are <mathjax>$(l+1)^m$</mathjax> possible alignments.</p>
<p>Then we define models for <mathjax>$p(a|e,m)$</mathjax> (the distribution of possible alignments) and <mathjax>$p(f|a,e,m)$</mathjax>, giving:</p>
<p><mathjax>$$
\begin{aligned}
p(f,a|e,m) &amp;= p(a|e,m) p(f|a,e,m) \\
p(f|e,m) &amp;= \sum_{a \in A} p(a|e,m)p(f|a,e,m)
\end{aligned}
$$</mathjax></p>
<p>Where <mathjax>$A$</mathjax> is the set of all possible alignments.</p>
<p>We can also use the model <mathjax>$p(f,a|e,m)$</mathjax> to get the distribution of alignments given two sentences:</p>
<p><mathjax>$$
p(a|f,e,m) = \frac{p(f,a|e,m)}{\sum_{a \in A}p(f,a|e,m)}
$$</mathjax></p>
<p>Which we can then use to compute the most likely alignment for a sentence pair <mathjax>$f, e$</mathjax>:</p>
<p><mathjax>$$
a^* = \argmax_a p(a|f,e,m)
$$</mathjax></p>
<p>When we start, we assume that all alignments <mathjax>$a$</mathjax> are equally likely:</p>
<p><mathjax>$$
p(a|e,m) = \frac{1}{(l+1)^m}
$$</mathjax></p>
<p>Which is a big simplification but provides a starting point.</p>
<p>We want to estimate <mathjax>$p(f|a,e,m)$</mathjax>, which is:</p>
<p><mathjax>$$
p(f|a,e,m) = \prod_{j=1}^m t(f_j|e_{a_j})
$$</mathjax></p>
<p>Where <mathjax>$t(f_j|e_{a_j})$</mathjax> is the probability of the source word <mathjax>$e_{a_j}$</mathjax> being aligned with <mathjax>$f_j$</mathjax>. These are the parameters we are interested in learning.</p>
<p>So the general generative process is as follows:</p>
<ol>
<li>Pick an alignment <mathjax>$a$</mathjax> with probability <mathjax>$\frac{1}{(l+1)^m}$</mathjax></li>
<li>Pick the target language words with probability:</li>
</ol>
<p><mathjax>$$
p(f|a,e,m) = \prod_{j=1}^m t(f_j|e_{a_j})
$$</mathjax></p>
<p>Then we get our final model:</p>
<p><mathjax>$$
p(f,a|e,m) = p(a|e,m) p(f|a,e,m) = \frac{1}{(l+1)^m} \prod_{j=1}^m t(f_j|e_{a_j})
$$</mathjax></p>
<h5>IBM Model 2</h5>
<p>An extension of IBM Model 1; it introduces alignment (also called <em>distortion</em>) parameters <mathjax>$q(i|j,l,m)$</mathjax>, which is the probability that the <mathjax>$j$</mathjax>th target word is connected to the <mathjax>$i$</mathjax>th source word. That is, we no longer assume alignments have uniform probability.</p>
<p>We define:</p>
<p><mathjax>$$
p(a|e,m) = \prod_{j=1}^m q(a_j|j,l,m)
$$</mathjax></p>
<p>where <mathjax>$a = \{a_1, \dots, a_m\}$</mathjax>.</p>
<p>This now gives us the following as our final model:</p>
<p><mathjax>$$
p(f,a|e,m) = \prod_{i=1}^m q(a_j|j,l,m) t(f_j|e_{a_j})
$$</mathjax></p>
<p>In overview, the generative process for IBM model 2 is:</p>
<ol>
<li>Pick an alignment <mathjax>$a = \{a_1, a_2, \dots, a_m \}$</mathjax> with probability:</li>
</ol>
<p><mathjax>$$
\prod_{j=1}^m q(a_j | j,l,m)
$$</mathjax></p>
<ol start="2">
<li>Pick the target language words with probability:</li>
</ol>
<p><mathjax>$$
p(f,a|e,m) = \prod_{j=1}^m t(f_j|e_{a_j})
$$</mathjax></p>
<p>Which is equivalent to the final model described above.</p>
<p>Then we can use this model to get the most likely alignment for any sentence pair:</p>
<p>Given a sentence pair <mathjax>$e_1, e_2, \dots, e_l$</mathjax> and <mathjax>$f_1, f_2, \dots, f_m$</mathjax>:</p>
<p><mathjax>$$
a_j = \argmax_{a \in \{0, \dots, l\}} q(a|j,l,m) t(f_j|e_a)
$$</mathjax></p>
<p>For <mathjax>$j = 1, \dots, m$</mathjax>.</p>
<h5>Estimating the <mathjax>$q$</mathjax> and <mathjax>$t$</mathjax> parameters</h5>
<p>We need to estimate our <mathjax>$q(i|j,l,m)$</mathjax> and <mathjax>$t(f|e)$</mathjax> parameters. We have a parallel corpus of sentence pairs, a single example of which is notated <mathjax>$(e^{(k)}, f^{(k)})$</mathjax> for <mathjax>$k = 1, \dots, n$</mathjax>.</p>
<p>Our training examples <em>do not</em> have alignments annotated (if we did, we could just use maximum likelihood estimates, e.g. <mathjax>$t_{\text{ML}}(f|e) = \frac{\text{Count}(e,f)}{\text{Count}(e)}$</mathjax> and <mathjax>$q_{\text{ML}}(j|i,l,m) = \frac{\text{Count}(j|i,l,m)}{\text{Count}(i,l,m)}$</mathjax>).</p>
<p>We can use the Expectation Maximization algorithm to estimate these parameters.</p>
<p>We initialize our <mathjax>$q$</mathjax> and <mathjax>$t$</mathjax> parameters to random values. Then we iteratively do the following until convergence:</p>
<ol>
<li>Compute "counts" (called <em>expected counts</em>) based on the data and our current parameter estimates</li>
<li>Re-estimate the parameters with these counts</li>
</ol>
<p>The amount we increment counts by is:</p>
<p><mathjax>$$
\delta (k,i,j) = \frac{q(j|i,l_k,m_k)t(f_i^{(k)}|e_j^{(k)})}{\sum_{j=0}^{l_k} q(j|i,l_k,m_k)t(f_i^{(k)}|e_j^{(k)})}
$$</mathjax></p>
<p>The algorithm for updating counts <mathjax>$c$</mathjax> is:</p>
<ul>
<li>For <mathjax>$k = 1, \dots, n$</mathjax></li>
<li>For <mathjax>$i=1, \dots, m_k$</mathjax>, for <mathjax>$j=0, \dots, l_k$</mathjax><ul>
<li><mathjax>$c(e_j^{(k)}, f_i^{(k)}) += \delta(k,i,j)$</mathjax></li>
<li><mathjax>$c(e_j^{(k)}) += \delta(k,i,j)$</mathjax></li>
<li><mathjax>$c(j|i,l,m) += \delta(k,i,j)$</mathjax></li>
<li><mathjax>$c(i,l,m) += \delta(k,i,j)$</mathjax></li>
</ul>
</li>
</ul>
<p>Then recalculate the parameters:</p>
<p><mathjax>$$
\begin{aligned}
t(f|e) &amp;= \frac{c(e,f)}{c(e)} \\
q(j|i,l,m) &amp;= \frac{c(j|i,l,m)}{c(i,l,m)}
\end{aligned}
$$</mathjax></p>
<p>How does this method work?</p>
<p>First we define the log-likelihood function as a function of our <mathjax>$t$</mathjax> and <mathjax>$q$</mathjax> parameters:</p>
<p><mathjax>$$
L(t, q) = \sum_{k=1}^n \log p(f^{(k)}|e^{(k)}) = \sum_{k=1}^n \log \sum_a p(f^{(k)} a| e^{(k)})
$$</mathjax></p>
<p>Which quantifies how well our current parameter estimates fit the data.</p>
<p>So the maximum likelihood estimates are just:</p>
<p><mathjax>$$
\argmax_{t,q} L(t,q)
$$</mathjax></p>
<p>Though the EM algorithm will converge only to a local maximum of the log-likelihood function.</p>
<h3>Phrase-Based Translation</h3>
<p>Phrase-based models must extract a <em>phrase-based (PB) lexicon</em>, which consists of pairs of matching phrases (consisting of one or more words), one from the source language, from the target language.</p>
<p>This phrase lexicon can be learned from alignments.</p>
<p>However, alignments are many-to-one; that is, multiple words in the target language can map to a single word in the source language, but the reverse cannot happen. A workaround is to learn alignments in both ways (i.e. from source to target and from target to source), then look at the intersections of these alignments as (a starting point) the phrase lexicon.</p>
<p>This phrase lexicon can be expanded ("grown") through some heuristics (not covered here).</p>
<p>This phrase lexicon can be noisy, so we want to apply some heuristics to clean it up. In particular, we want phrase pairs that are <em>consistent</em>. A phrase pair <mathjax>$(e,f)$</mathjax> is consistent if:</p>
<ol>
<li>There is at least one word in <mathjax>$e$</mathjax> aligned to a word in <mathjax>$f$</mathjax></li>
<li>There are no words in <mathjax>$f$</mathjax> aligned to words outside <mathjax>$e$</mathjax></li>
<li>There are no words in <mathjax>$e$</mathjax> aligned to words outside <mathjax>$f$</mathjax></li>
</ol>
<p>We discard any phrase pairs that are not consistent.</p>
<p>We can use these phrases to estimate the parameter <mathjax>$t(f|e)$</mathjax> easily:</p>
<p><mathjax>$$
t(f|e) = \frac{\text{Count}(f,e)}{\text{Count}(e)}
$$</mathjax></p>
<p>We give each phrase pair <mathjax>$(f,e)$</mathjax> a score <mathjax>$g(f,e)$</mathjax>. For example:</p>
<p><mathjax>$$
g(f,e) = \log(\frac{\text{Count}(f,e)}{\text{Count}(e)})
$$</mathjax></p>
<p>A phrase-based model consists of:</p>
<ul>
<li>a phrase-based lexicon, with a way of computing a score for each phrase pair</li>
<li>a trigram language model with parameters <mathjax>$q(w|u,v)$</mathjax></li>
<li>a <em>distortion parameter</em> <mathjax>$\eta$</mathjax>, which is typically negative</li>
</ul>
<p>Given an input (source language) sentence <mathjax>$x_1, \dots, x_n$</mathjax>, a phrase is a tuple <mathjax>$(s,t,e)$</mathjax> which indicates that the subsequence <mathjax>$x_s, \dots, x_t$</mathjax> can be translated to the string <mathjax>$e$</mathjax> in the target language using a phrase pair in the lexicon.</p>
<p>We denote <mathjax>$P$</mathjax> as the set of all phrases for a sentence.</p>
<p>For any phrase <mathjax>$p$</mathjax>, <mathjax>$s(p), t(p), e(p)$</mathjax> correspond to its components in the tuple. <mathjax>$g(p)$</mathjax> is the score for the phrase.</p>
<p>A <em>derivation</em> <mathjax>$y$</mathjax> is a finite sequence of phrases <mathjax>$p_1, p_2, \dots, p_L$</mathjax> where each phrase is in <mathjax>$P$</mathjax>. The underlying translation defined by <mathjax>$y$</mathjax> is denoted <mathjax>$e(y)$</mathjax> (that is, <mathjax>$e(y)$</mathjax> just represents the combined string of <mathjax>$y$</mathjax>'s phrases).</p>
<p>For an input sentence <mathjax>$x = x_1, \dots, x_n$</mathjax>, we refer to the set of <em>valid derivations</em> for <mathjax>$x$</mathjax> as <mathjax>$Y(x)$</mathjax>. It is a set of all finite length sequences of phrases <mathjax>$p_1, p_2, \dots, p_L$</mathjax> such that:</p>
<ul>
<li>Each phrase <mathjax>$p_k, k \in \{1, \dots, L\}$</mathjax> is a member of the set of phrases <mathjax>$P$</mathjax></li>
<li>Each word in <mathjax>$x$</mathjax> is translated exactly once</li>
<li>For all <mathjax>$k \in \{1, \dots, (L-1)\}, |t(p_k) + 1 - s(p_{k+1})| \leq d$</mathjax> where <mathjax>$d \geq 0$</mathjax> is a parameter of the model. We must also have <mathjax>$|1 - s(p_1) \leq d$</mathjax>. <mathjax>$d$</mathjax> is the <em>distortion limit</em> which constrains how far phrases can move (a typical value is <mathjax>$d=4$</mathjax>). Empirically, this results in better translations, and it also reduces the search space of possible translations.</li>
</ul>
<p><mathjax>$Y(x)$</mathjax> is exponential in size (it grows exponentially with sentence length), so it gets quite large.</p>
<p>Now we want to score these derivations and select the highest-scoring one as the translation, i.e.</p>
<p><mathjax>$$
\argmax_{y \in Y(x)} f(y)
$$</mathjax></p>
<p>Where <mathjax>$f(y)$</mathjax> is the scoring function. It typically involves a product of a language model and a translation model.</p>
<p>In particular, we have the scoring function:</p>
<p><mathjax>$$
f(y) = h(e(y)) + \sum_{k=1}^L g(p_k) + \sum_{k=0}^{L-1} \eta |t(p_k) + 1 - s(p_{k+1})
$$</mathjax></p>
<p>Where <mathjax>$e(y)$</mathjax> is the sequence of words in the translation, <mathjax>$h(e(y))$</mathjax> is the score of the sequence of words under the language model (e.g. a trigram language model), <mathjax>$g(p_k)$</mathjax> is the score for the phrase <mathjax>$p_k$</mathjax>, and the last summation is the <em>distortion score</em>, which penalizes distortions (so that we favor smaller distortions).</p>
<p>We also define <mathjax>$t(p_0) = 0$</mathjax>.</p>
<p>Because <mathjax>$Y(x)$</mathjax> is exponential in size, we want to avoid a brute-force method for identifying the highest-scoring derivation. In fact, it is an NP-Hard problem, so we must apply a heuristic method - in particular, using beam search.</p>
<p>For this algorithm, called the <em>Decoding Algorithm</em>, we keep a state as a tuple <mathjax>$(e_1, e_2, b, r, \alpha)$</mathjax> where <mathjax>$e_1, e_2$</mathjax> are target words, <mathjax>$b$</mathjax> is a bit-string of length <mathjax>$n$</mathjax> (that is, the same length of the input sentence) which indicates which words in the source sentence have been translated, <mathjax>$r$</mathjax> is the integer specifying the endpoint of the last phrase in the state, and <mathjax>$\alpha$</mathjax> is a score for the state.</p>
<p>The initial state is <mathjax>$q_0 = (*,*,0^n,0,0)$</mathjax>, where <mathjax>$0^n$</mathjax> is a bit-string of length <mathjax>$n$</mathjax> with all zeros.</p>
<p>We can represent the state of possible translations as a graph of these states, e.g. the source sentence has many initial possible translation states, which each also lead to many other possible states, etc. As mentioned earlier, this graph becomes far too large to brute-force search through.</p>
<p>We define <mathjax>$ph(q)$</mathjax> as a function which returns the set of phrases that can follow state <mathjax>$q$</mathjax>.</p>
<p>For a phrase <mathjax>$p$</mathjax> to be a member of <mathjax>$ph(q)$</mathjax>, it must satisfy the following:</p>
<ul>
<li><mathjax>$p$</mathjax> must not overlap with the bit-string <mathjax>$b$</mathjax>, i.e. <mathjax>$b_i = 0$</mathjax> for <mathjax>$i \in \{s(p), \dots, t(p)\}$</mathjax>. This formalizes the fact that we don't want to translate the same word twice.</li>
<li>The distortion limit must not be violated (i.e. <mathjax>$|r + 1 - s(p)| \leq d$</mathjax>)</li>
</ul>
<p>We also define <mathjax>$\text{next}(q,p)$</mathjax> to be the state formed by combining the state <mathjax>$q$</mathjax> with the phrase <mathjax>$p$</mathjax> (i.e. it is a transition function for the state graph).</p>
<p>Formally, we have a state <mathjax>$q = (e_1, e_2, b, r, \alpha)$</mathjax> and a phrase <mathjax>$p = (s,t,\epsilon_1, \dots, \epsilon_M)$</mathjax> where <mathjax>$\epsilon_i$</mathjax> is a word in the phrase. The transition function <mathjax>$\text{next}(q,p)$</mathjax> yields the state $q' = (e_1', e_2', b', r', alpha'), defined as follows:</p>
<ul>
<li>Define <mathjax>$\epsilon_{-1} = e_1, \epsilon_0 = e_2$</mathjax></li>
<li>Define <mathjax>$e_1' = \epsilon_{M-1}, e_2' = \epsilon_M$</mathjax></li>
<li>Define <mathjax>$b_i' = 1$</mathjax> for <mathjax>$i \in \{s, \dots, t\}$</mathjax>. Define <mathjax>$b_i' = b_i$</mathjax> for <mathjax>$i \notin \{s, \dots, t\}$</mathjax>.</li>
<li>Define <mathjax>$r' = t$</mathjax></li>
<li>Define:</li>
</ul>
<p><mathjax>$$
\alpha' = \alpha + g(p) + \sum_{i=1}^M \log q(\epsilon_i|\epsilon_{i-2}, \epsilon_{i-1}) + \eta |r+1-s|
$$</mathjax></p>
<p>We also define a simple equality function, <mathjax>$eq(q, q')$</mathjax> which returns true or false if the two states are equal, ignoring scores (that is, if all their components are equal, without requiring that their scores are equal).</p>
<p>The final decoding algorithm:</p>
<ul>
<li>Inputs:</li>
<li>a sentence <mathjax>$x_1, \dots, x_n$</mathjax></li>
<li>a phrase-based model <mathjax>$(L, h, d, \eta)$</mathjax>, where <mathjax>$L$</mathjax> is the lexicon, <mathjax>$h$</mathjax> is the language model, <mathjax>$d$</mathjax> is the distortion limit, and <mathjax>$\eta$</mathjax> is the distortion parameter. This model defines the functions <mathjax>$ph(q)$</mathjax> and <mathjax>$\text{next}(q,p)$</mathjax>.</li>
<li>Initialization: set <mathjax>$Q_0 = \{q_0\}, Q_i = \emptyset$</mathjax> for <mathjax>$i = 1, \dots, n$</mathjax>, where <mathjax>$q_0$</mathjax> is the initial state as defined earlier. Each <mathjax>$Q_i$</mathjax> contains possible states in which <mathjax>$i$</mathjax> words are translated.</li>
<li>For <mathjax>$i = 0, \dots, n-1$</mathjax></li>
<li>For each state <mathjax>$q \in \text{beam}(Q_i)$</mathjax>, for each phrase <mathjax>$p \in ph(q)$</mathjax>:<ul>
<li><mathjax>$q' = \text{next}(q,p)$</mathjax></li>
<li>Add <mathjax>$\text{Add}(Q_i, q', q, p)$</mathjax> where <mathjax>$i = \text{len}(q')$</mathjax></li>
</ul>
</li>
<li>Return: highest scoring state in <mathjax>$Q_n$</mathjax>. Backpointers can be used to find the underlying sequence of phrases.</li>
</ul>
<p><mathjax>$\text{Add}(Q, q', q, p)$</mathjax> is defined:</p>
<ul>
<li>If there is some <mathjax>$q'' \in Q$</mathjax> such that <mathjax>$eq(q'', q)$</mathjax> is true:</li>
<li>if <mathjax>$\alpha(q') &gt; \alpha(q'')$</mathjax><ul>
<li><mathjax>$Q = \{q'\} \cup Q \ \{q''\}$</mathjax> (remove the lower scoring state, add the higher scoring one)</li>
<li>set <mathjax>$bp(q') = (q,p)$</mathjax></li>
</ul>
</li>
<li>else return</li>
<li>Else</li>
<li><mathjax>$Q = Q \cup \{q'\}$</mathjax></li>
<li>set <mathjax>$bp(q') = (q,p)$</mathjax></li>
</ul>
<p>That is, if we already have an equivalent state, keep the higher scoring of the two, and we keep a backpointer of how we got there.</p>
<p><mathjax>$\text{beam}(Q)$</mathjax> is defined:</p>
<p>First define <mathjax>$\alpha* = \argmax_{q \in Q} \alpha(q)$</mathjax>. We define <mathjax>$\beta \geq 0$</mathjax> to be the <em>beam-width</em> parameter. Then <mathjax>$\text{beam}(Q) = \{q \in Q : \alpha(q) \geq \alpha* - \beta \}$</mathjax></p>
<h2>Word Clustering</h2>
<p>The <strong>Brown clustering algorithm</strong> is an unsupervised method which take as input some large quantity of sentences, and from that, learns useful representations of words, outputting a hierarchical word clustering (e.g. weekdays and weekends might be clustered together, months may be clustered together, family relations may be clustered, etc).</p>
<p>The general intuition is that similar words appear in similar contexts - that is, they have similar distributions of words to their immediate left and right.</p>
<p>We have a set of all words seen in the corpus <mathjax>$V = \{w_1, w_2, \dots, w_T \}$</mathjax>. Say <mathjax>$C : V \to \{1,2,\dots,k\}$</mathjax> is a partition of the vocabulary into <mathjax>$k$</mathjax> classes (that is, <mathjax>$C$</mathjax> maps each word to a class label).</p>
<p>The model is as follows, where <mathjax>$C(w_0)$</mathjax> is a special start state:</p>
<p><mathjax>$$
p(w_1, w_2, \dots, w_T) = \prod_{i=1}^n e(w_i|C(w_i))q(C(w_i)|C(w_{i-1}))
$$</mathjax></p>
<p>Which can be restated:<br />
<mathjax>$$
\log p(w_1, w_2, \dots, w_T) = \sum_{i=1}^n \log e(w_i|C(w_i))q(C(w_i)|C(w_{i-1}))
$$</mathjax></p>
<p>So we want to learn the parameters <mathjax>$e(v|c)$</mathjax> for every <mathjax>$v \in V, c \in \{1, \dots, k \}$</mathjax> and <mathjax>$q(c'|c)$</mathjax> for every <mathjax>$c', c \in \{1, \dots, k\}$</mathjax>.</p>
<p>We first need to measure the quality of a partition <mathjax>$C$</mathjax>:</p>
<p><mathjax>$$
\begin{aligned}
\text{Quality}(C) &amp;= \sum_{i=1}^n \log e(w_i|C(w_i))q(C(w_i)|C(w_{i-1})) \\
&amp;= \sum_{c=1}^k \sum_{c'=1}^k p(c,c') \log \frac{p(c,c')}{p(c)p(c')} + G
\end{aligned}
$$</mathjax></p>
<p>Where <mathjax>$G$</mathjax> is some constant. This basically computes the likelihood of this corpus under <mathjax>$C$</mathjax>.</p>
<p>Here:</p>
<p><mathjax>$$
p(c,c') = \frac{n(c,c')}{\sum_{c,c'} n(c,c')}, p(c) = \frac{n(c)}{\sum_c n(c)}
$$</mathjax></p>
<p>Where <mathjax>$n(c)$</mathjax> is the number of times class <mathjax>$c$</mathjax> occurs in the corpus, <mathjax>$n(c,c')$</mathjax> is the number of times <mathjax>$c'$</mathjax> is seen following <mathjax>$c$</mathjax>, under the function <mathjax>$C$</mathjax>.</p>
<p>The basic algorithm for Brown clustering is as follows:</p>
<table>
<thead>
<tr>
<th>- Start with $</th>
<th>V</th>
<th align="right"><mathjax>$ clusters (each word gets its own cluster, but by the end we will find $</mathjax>k$ clusters)</th>
</tr>
</thead>
<tbody>
<tr>
<td>- At each merge step, we pick two clusters <mathjax>$c_i, c_j$</mathjax> and merge them into a single cluster</td>
<td></td>
<td align="right"></td>
</tr>
<tr>
<td>- We greedily pick merges such that <mathjax>$\text{Quality}(C)$</mathjax> for the clustering <mathjax>$C$</mathjax> after the merge step is maximized at each stage</td>
<td></td>
<td align="right"></td>
</tr>
</tbody>
</table>
<p>This approach is inefficient: <mathjax>$O(|V|^5)$</mathjax> though it can be improved to <mathjax>$O(|V|^3)$</mathjax>, which is still quite slow.</p>
<p>There is a better way based on this approach:</p>
<ul>
<li>We specify a parameter <mathjax>$m$</mathjax>, e.g. <mathjax>$m=1000$</mathjax></li>
<li>We take the top <mathjax>$m$</mathjax> most frequent words and puts each into its own cluster, <mathjax>$c_1, c_2, \dots, c_m$</mathjax>.</li>
<li>For <mathjax>$i = (m+1) \dots |V|$</mathjax></li>
<li>Create a new cluster <mathjax>$c_{m+1}$</mathjax> for the <mathjax>$i$</mathjax>th most frequent word. We now have <mathjax>$m+1$</mathjax> clusters</li>
<li>Choose two clusters from <mathjax>$c_1, \dots, c_{m+1}$</mathjax> to be merged, picking the merge that gives a max value for <mathjax>$\text{Quality}(C)$</mathjax> (now we just have <mathjax>$m$</mathjax> clusters again)</li>
<li>Carry out <mathjax>$(m-1)$</mathjax> final merges to create a full hierarchy.</li>
</ul>
<p>This has the run time of <mathjax>$O(|V|m^2+n)$</mathjax>, where <mathjax>$n$</mathjax> is the corpus length.</p>
<h2>Neural Networks and NLP</h2>
<p>Typically when words are represented as vectors, it is as a one-hot representation, that is, a vector of length <mathjax>$|V|$</mathjax> where <mathjax>$V$</mathjax> is the vocabulary, with all elements 0 except for the one corresponding to the particular word being represented (that is, it is a sparse representation).</p>
<p>This can be quite unwieldy as it has dimensionality of <mathjax>$|V|$</mathjax>, which is typically quite large.</p>
<p>We can instead use neural networks to learn dense representations of words ("word embeddings") of a fixed dimension (the particular dimensionality is specified as a hyperparameter, there is not as of this time a theoretical understanding of how to choose this value) and can capture other properties of words (such as analogies).</p>
<p>Representing a sentence can be accomplished by concatenating the embeddings of its words, but this can be problematic in that typically fixed-size vectors are required, and sentences are variable in their word length.</p>
<p>A way around this is to use the <em>continuous bag of words</em> (CBOW) representation, in which, like the traditional bag-of-words representation, we throw out word order information and combine the embeddings by summing or averaging them, e.g. given a set of word embeddings <mathjax>$v_1, \dots, v_k$</mathjax>:</p>
<p><mathjax>$$
\text{CBOW}(v_1, \dots, v_k) = \frac{1}{k} \sum_{i=1}^k v_i
$$</mathjax></p>
<p>An extension of this method is the weighted CBOW (WCBOW) which is just a weighted average of the embeddings.</p>
<p>How are these word embeddings learned? Typically, it is by training a neural network (specifically for learning the embeddings) on an auxiliary task. For instance, context prediction is a common embedding training task, in which we try to predict a word given its surrounding context (under the assumption that words which appear in similar contexts are similar in other important ways).</p>
<h3>Word Embeddings</h3>
<p>A word embedding <mathjax>$W : \text{words} \to \mathbb R^n$</mathjax> is a parameterized function that maps words to high-dimensional vectors (typically 200-500 dimensions).</p>
<p>This function is typically a lookup table parameterized by a matrix <mathjax>$\theta$</mathjax>, where each row represents a word. That is, the function is often <mathjax>$W_{\theta}(w_n) = \theta_n$</mathjax>. <mathjax>$\theta$</mathjax> is initialized with random vectors for each word.</p>
<p>So given a task involving words, we want to learn <mathjax>$W$</mathjax> so that we have good representations for each word.</p>
<p>You can visualize a word embedding space using t-SNE (a technique for visualizing high-dimensional data):</p>
<figure><img alt="Visualizing a word embedding space with t-SNE (Turian et al (2010))" src="../assets/Turian-WordTSNE.png" /><figcaption>Visualizing a word embedding space with t-SNE (<a href="http://www.iro.umontreal.ca/~lisa/pointeurs/turian-wordrepresentations-acl10.pdf">Turian et al (2010)</a>)</figcaption>
</figure>
<p>As you can see, words that are similar in meaning tend to be closer together. Intuitively this makes sense - if words have similar meaning, they are somewhat interchangeable, so we expect that their vectors be similar too.</p>
<p>We'll also see the vectors capture notions of analogy, for example "Paris" is to "France" as "Tokyo" is to "Japan". These kinds of analogies can be represented as vector addition: "Paris" - "France" + "Japan" = "Tokyo".</p>
<p>The best part is the neural network is not explicitly told to learn representations with these properties - it is just a side effect. This is one of the remarkable properties of neural networks - they learn good ways of representing the data more or less on their own.</p>
<p>And these representations can be portable. That is, maybe you learn <mathjax>$W$</mathjax> for one natural language task, but you may be able to re-use <mathjax>$W$</mathjax> for another natural language task (provided it's using a similar vocabulary). This practice is sometimes called "pretraining" or "transfer learning" or "multi-task learning".</p>
<p>You can also map multiple words to a single representation, e.g. if you are doing a multilingual task. For example, the English and French words for "dog" could map to the same representation since they mean the same thing (in which case we could call this a "bilingual word embedding").</p>
<p>Here's an example visualization of a Chinese and English bilingual word embedding:</p>
<figure><img alt="A Chinese and English word embedding (Socher et al (2013a))" src="../assets/Socher-BillingualTSNE.png" /><figcaption>A Chinese and English word embedding (<a href="http://ai.stanford.edu/~wzou/emnlp2013_ZouSocherCerManning.pdf">Socher et al (2013a)</a>)</figcaption>
</figure>
<p>You can even go a step further and learn image and word representations together, so that vectors representing images of horses are close to the vector for the word "horse".</p>
<p>Two main techniques for learning word embeddings are:</p>
<ul>
<li>CBOW: predicting the probability of context words given a word</li>
<li>Skip-gram: predicting the probability of a word given context words</li>
</ul>
<h3>CNNs for NLP</h3>
<p>CBOW representations lose word-ordering information, which can be important for some tasks (e.g. sentiment analysis).</p>
<p>CNNs are useful in such situations because they avoid the need of going to, for instance, bigram methods. They can automatically learn important local structures (much as they do with image recognition).</p>
<h3>References</h3>
<ul>
<li><a href="http://arxiv.org/abs/1510.00726">A Primer on Neural Network Models for Natural Language Processing</a>. Yoav Goldberg. October 5, 2015.</li>
<li><a href="https://www.coursera.org/course/nlp">Natural Language Processing</a>. Dan Jurafsky, Christopher Manning, Stanford (Coursera).</li>
<li><a href="https://www.coursera.org/course/nlangp">Natural Language Processing</a>. Michael Collins. Columbia University (Coursera).</li>
</ul>
    
    <script src="http://cdn.bootcss.com/jquery/1.11.1/jquery.js"></script>
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>
    <script src="http://ai-code.tech/ai_notes_html/js/custom.js"></script>
    <script>
        $(document).ready(function() {
            $('pre').each(function(i, e) {hljs.highlightBlock(e)});
            MathJax.Hub.Config({
                tex2jax: {
                    inlineMath: [["$","$"]],
                    displayMath: [['$$','$$']],
                    processEscapes: true
                },
                "HTML-CSS": {
                    linebreaks: { automatic: true }
                }
            });
            MathJax.Hub.Startup.onload();
        });
    </script>


</body>
</html>
